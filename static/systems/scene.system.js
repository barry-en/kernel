(function(e, a) { for(var i in a) e[i] = a[i]; }(this, /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "../../../../../../private/var/folders/k0/l6n3lg0s1qb2fkyt6f2p5z3m0000gn/T/0.19312207629577016.WebWorker.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../../../private/var/folders/k0/l6n3lg0s1qb2fkyt6f2p5z3m0000gn/T/0.19312207629577016.WebWorker.js":
/*!*************************************************************************************************!*\
  !*** /private/var/folders/k0/l6n3lg0s1qb2fkyt6f2p5z3m0000gn/T/0.19312207629577016.WebWorker.js ***!
  \*************************************************************************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _Users_Barry_go_src_barry_en_kernel_node_modules_decentraland_rpc_lib_common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/decentraland-rpc/lib/common/transports/WebWorker */ \"./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js\");\n\n\nconst imported = __webpack_require__(/*! ./packages/scene-system/scene.system.ts */ \"./packages/scene-system/scene.system.ts\")\n\nif (imported && imported.__esModule && imported['default']) {\n  new imported['default'](Object(_Users_Barry_go_src_barry_en_kernel_node_modules_decentraland_rpc_lib_common_transports_WebWorker__WEBPACK_IMPORTED_MODULE_0__[\"WebWorkerTransport\"])(self))\n}\n\n\n//# sourceURL=webpack:////private/var/folders/k0/l6n3lg0s1qb2fkyt6f2p5z3m0000gn/T/0.19312207629577016.WebWorker.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Angle.js":
/*!**************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Angle.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Angle = void 0;\n/**\n * Defines angle representation\n * @public\n */\nclass Angle {\n    /**\n     * Creates an Angle object of \"radians\" radians (float).\n     */\n    constructor(radians) {\n        this._radians = radians;\n        if (this._radians < 0.0) {\n            this._radians += 2.0 * Math.PI;\n        }\n    }\n    /**\n     * Gets a new Angle object valued with the angle value in radians between the two given vectors\n     * @param a - defines first vector\n     * @param b - defines second vector\n     * @returns a new Angle\n     */\n    static BetweenTwoPoints(a, b) {\n        const delta = b.subtract(a);\n        const theta = Math.atan2(delta.y, delta.x);\n        return new Angle(theta);\n    }\n    /**\n     * Gets a new Angle object from the given float in radians\n     * @param radians - defines the angle value in radians\n     * @returns a new Angle\n     */\n    static FromRadians(radians) {\n        return new Angle(radians);\n    }\n    /**\n     * Gets a new Angle object from the given float in degrees\n     * @param degrees - defines the angle value in degrees\n     * @returns a new Angle\n     */\n    static FromDegrees(degrees) {\n        return new Angle((degrees * Math.PI) / 180.0);\n    }\n    /**\n     * Get value in degrees\n     * @returns the Angle value in degrees (float)\n     */\n    degrees() {\n        return (this._radians * 180.0) / Math.PI;\n    }\n    /**\n     * Get value in radians\n     * @returns the Angle value in radians (float)\n     */\n    radians() {\n        return this._radians;\n    }\n}\nexports.Angle = Angle;\n//# sourceMappingURL=Angle.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Angle.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Arc2.js":
/*!*************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Arc2.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Arc2 = void 0;\nconst Angle_1 = __webpack_require__(/*! ./Angle */ \"./node_modules/@dcl/ecs-math/dist/Angle.js\");\nconst Vector2_1 = __webpack_require__(/*! ./Vector2 */ \"./node_modules/@dcl/ecs-math/dist/Vector2.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\n/**\n * This represents an arc in a 2d space.\n * @public\n */\nclass Arc2 {\n    /**\n     * Creates an Arc object from the three given points : start, middle and end.\n     * @param startPoint - Defines the start point of the arc\n     * @param midPoint - Defines the midlle point of the arc\n     * @param endPoint - Defines the end point of the arc\n     */\n    constructor(\n    /** Defines the start point of the arc */\n    startPoint, \n    /** Defines the mid point of the arc */\n    midPoint, \n    /** Defines the end point of the arc */\n    endPoint) {\n        this.startPoint = startPoint;\n        this.midPoint = midPoint;\n        this.endPoint = endPoint;\n        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);\n        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;\n        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;\n        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) -\n            (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);\n        this.centerPoint = new Vector2_1.Vector2((startToMid * (midPoint.y - endPoint.y) -\n            midToEnd * (startPoint.y - midPoint.y)) /\n            det, ((startPoint.x - midPoint.x) * midToEnd -\n            (midPoint.x - endPoint.x) * startToMid) /\n            det);\n        this.radius = this.centerPoint.subtract(this.startPoint).length();\n        this.startAngle = Angle_1.Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);\n        const a1 = this.startAngle.degrees();\n        let a2 = Angle_1.Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();\n        let a3 = Angle_1.Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();\n        // angles correction\n        if (a2 - a1 > +180.0) {\n            a2 -= 360.0;\n        }\n        if (a2 - a1 < -180.0) {\n            a2 += 360.0;\n        }\n        if (a3 - a2 > +180.0) {\n            a3 -= 360.0;\n        }\n        if (a3 - a2 < -180.0) {\n            a3 += 360.0;\n        }\n        this.orientation = a2 - a1 < 0 ? types_1.Orientation.CW : types_1.Orientation.CCW;\n        this.angle = Angle_1.Angle.FromDegrees(this.orientation === types_1.Orientation.CW ? a1 - a3 : a3 - a1);\n    }\n}\nexports.Arc2 = Arc2;\n//# sourceMappingURL=Arc2.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Arc2.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Axis.js":
/*!*************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Axis.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Axis = void 0;\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\n/**\n * Defines the 3 main axes\n * @public\n */\nclass Axis {\n}\nexports.Axis = Axis;\n/** X axis */\nAxis.X = new Vector3_1.Vector3(1.0, 0.0, 0.0);\n/** Y axis */\nAxis.Y = new Vector3_1.Vector3(0.0, 1.0, 0.0);\n/** Z axis */\nAxis.Z = new Vector3_1.Vector3(0.0, 0.0, 1.0);\n//# sourceMappingURL=Axis.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Axis.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/BezierCurve.js":
/*!********************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/BezierCurve.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BezierCurve = void 0;\n/**\n * Class used to represent a Bezier curve\n * @public\n */\nclass BezierCurve {\n    /**\n     * Returns the cubic Bezier interpolated value (float) at \"t\" (float) from the given x1, y1, x2, y2 floats\n     * @param t - defines the time\n     * @param x1 - defines the left coordinate on X axis\n     * @param y1 - defines the left coordinate on Y axis\n     * @param x2 - defines the right coordinate on X axis\n     * @param y2 - defines the right coordinate on Y axis\n     * @returns the interpolated value\n     */\n    static Interpolate(t, x1, y1, x2, y2) {\n        // Extract X (which is equal to time here)\n        const f0 = 1 - 3 * x2 + 3 * x1;\n        const f1 = 3 * x2 - 6 * x1;\n        const f2 = 3 * x1;\n        let refinedT = t;\n        for (let i = 0; i < 5; i++) {\n            const refinedT2 = refinedT * refinedT;\n            const refinedT3 = refinedT2 * refinedT;\n            const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;\n            const slope = 1.0 / (3.0 * f0 * refinedT2 + 2.0 * f1 * refinedT + f2);\n            refinedT -= (x - t) * slope;\n            refinedT = Math.min(1, Math.max(0, refinedT));\n        }\n        // Resolve cubic bezier for the given x\n        return (3 * Math.pow(1 - refinedT, 2) * refinedT * y1 +\n            3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 +\n            Math.pow(refinedT, 3));\n    }\n}\nexports.BezierCurve = BezierCurve;\n//# sourceMappingURL=BezierCurve.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/BezierCurve.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Color3.js":
/*!***************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Color3.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Color3 = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\nconst Color4_1 = __webpack_require__(/*! ./Color4 */ \"./node_modules/@dcl/ecs-math/dist/Color4.js\");\nconst Scalar_1 = __webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\");\n/**\n * Class used to hold a RBG color\n * @public\n */\nclass Color3 {\n    /**\n     * Creates a new Color3 object from red, green, blue values, all between 0 and 1\n     * @param r - defines the red component (between 0 and 1, default is 0)\n     * @param g - defines the green component (between 0 and 1, default is 0)\n     * @param b - defines the blue component (between 0 and 1, default is 0)\n     */\n    constructor(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r = 0, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g = 0, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b = 0) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n    }\n    // Statics\n    /**\n     * Creates a new Color3 from the string containing valid hexadecimal values\n     * @param hex - defines a string containing valid hexadecimal values\n     * @returns a new Color3 object\n     */\n    static FromHexString(hex) {\n        if (hex.substring(0, 1) !== '#' || hex.length !== 7) {\n            return new Color3(0, 0, 0);\n        }\n        const r = parseInt(hex.substring(1, 3), 16);\n        const g = parseInt(hex.substring(3, 5), 16);\n        const b = parseInt(hex.substring(5, 7), 16);\n        return Color3.FromInts(r, g, b);\n    }\n    /**\n     * Creates a new Vector3 from the starting index of the given array\n     * @param array - defines the source array\n     * @param offset - defines an offset in the source array\n     * @returns a new Color3 object\n     */\n    static FromArray(array, offset = 0) {\n        return new Color3(array[offset], array[offset + 1], array[offset + 2]);\n    }\n    /**\n     * Creates a new Color3 from integer values (less than 256)\n     * @param r - defines the red component to read from (value between 0 and 255)\n     * @param g - defines the green component to read from (value between 0 and 255)\n     * @param b - defines the blue component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    static FromInts(r, g, b) {\n        return new Color3(r / 255.0, g / 255.0, b / 255.0);\n    }\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param start - defines the start Color3 value\n     * @param end - defines the end Color3 value\n     * @param amount - defines the gradient value between start and end\n     * @returns a new Color3 object\n     */\n    static Lerp(start, end, amount) {\n        const result = new Color3(0.0, 0.0, 0.0);\n        Color3.LerpToRef(start, end, amount, result);\n        return result;\n    }\n    /**\n     * Creates a new Color3 with values linearly interpolated of \"amount\" between the start Color3 and the end Color3\n     * @param left - defines the start value\n     * @param right - defines the end value\n     * @param amount - defines the gradient factor\n     * @param result - defines the Color3 object where to store the result\n     */\n    static LerpToRef(left, right, amount, result) {\n        result.r = left.r + (right.r - left.r) * amount;\n        result.g = left.g + (right.g - left.g) * amount;\n        result.b = left.b + (right.b - left.b) * amount;\n    }\n    /**\n     * Returns a Color3 value containing a red color\n     * @returns a new Color3 object\n     */\n    static Red() {\n        return new Color3(1, 0, 0);\n    }\n    /**\n     * Returns a Color3 value containing a green color\n     * @returns a new Color3 object\n     */\n    static Green() {\n        return new Color3(0, 1, 0);\n    }\n    /**\n     * Returns a Color3 value containing a blue color\n     * @returns a new Color3 object\n     */\n    static Blue() {\n        return new Color3(0, 0, 1);\n    }\n    /**\n     * Returns a Color3 value containing a black color\n     * @returns a new Color3 object\n     */\n    static Black() {\n        return new Color3(0, 0, 0);\n    }\n    /**\n     * Returns a Color3 value containing a white color\n     * @returns a new Color3 object\n     */\n    static White() {\n        return new Color3(1, 1, 1);\n    }\n    /**\n     * Returns a Color3 value containing a purple color\n     * @returns a new Color3 object\n     */\n    static Purple() {\n        return new Color3(0.5, 0, 0.5);\n    }\n    /**\n     * Returns a Color3 value containing a magenta color\n     * @returns a new Color3 object\n     */\n    static Magenta() {\n        return new Color3(1, 0, 1);\n    }\n    /**\n     * Returns a Color3 value containing a yellow color\n     * @returns a new Color3 object\n     */\n    static Yellow() {\n        return new Color3(1, 1, 0);\n    }\n    /**\n     * Returns a Color3 value containing a gray color\n     * @returns a new Color3 object\n     */\n    static Gray() {\n        return new Color3(0.5, 0.5, 0.5);\n    }\n    /**\n     * Returns a Color3 value containing a teal color\n     * @returns a new Color3 object\n     */\n    static Teal() {\n        return new Color3(0, 1.0, 1.0);\n    }\n    /**\n     * Returns a Color3 value containing a random color\n     * @returns a new Color3 object\n     */\n    static Random() {\n        return new Color3(Math.random(), Math.random(), Math.random());\n    }\n    /**\n     * Creates a string with the Color3 current values\n     * @returns the string representation of the Color3 object\n     */\n    toString() {\n        return '{R: ' + this.r + ' G:' + this.g + ' B:' + this.b + '}';\n    }\n    /**\n     * Returns the string \"Color3\"\n     * @returns \"Color3\"\n     */\n    getClassName() {\n        return 'Color3';\n    }\n    /**\n     * Compute the Color3 hash code\n     * @returns an unique number that can be used to hash Color3 objects\n     */\n    getHashCode() {\n        let hash = this.r || 0;\n        hash = (hash * 397) ^ (this.g || 0);\n        hash = (hash * 397) ^ (this.b || 0);\n        return hash;\n    }\n    // Operators\n    /**\n     * Stores in the given array from the given starting index the red, green, blue values as successive elements\n     * @param array - defines the array where to store the r,g,b components\n     * @param index - defines an optional index in the target array to define where to start storing values\n     * @returns the current Color3 object\n     */\n    toArray(array, index = 0) {\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        return this;\n    }\n    /**\n     * Returns a new Color4 object from the current Color3 and the given alpha\n     * @param alpha - defines the alpha component on the new Color4 object (default is 1)\n     * @returns a new Color4 object\n     */\n    toColor4(alpha = 1) {\n        return new Color4_1.Color4(this.r, this.g, this.b, alpha);\n    }\n    /**\n     * Returns a new array populated with 3 numeric elements : red, green and blue values\n     * @returns the new array\n     */\n    asArray() {\n        const result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Returns the luminance value\n     * @returns a float value\n     */\n    toLuminance() {\n        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;\n    }\n    /**\n     * Multiply each Color3 rgb values by the given Color3 rgb values in a new Color3 object\n     * @param otherColor - defines the second operand\n     * @returns the new Color3 object\n     */\n    multiply(otherColor) {\n        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);\n    }\n    /**\n     * Multiply the rgb values of the Color3 and the given Color3 and stores the result in the object \"result\"\n     * @param otherColor - defines the second operand\n     * @param result - defines the Color3 object where to store the result\n     * @returns the current Color3\n     */\n    multiplyToRef(otherColor, result) {\n        result.r = this.r * otherColor.r;\n        result.g = this.g * otherColor.g;\n        result.b = this.b * otherColor.b;\n        return this;\n    }\n    /**\n     * Determines equality between Color3 objects\n     * @param otherColor - defines the second operand\n     * @returns true if the rgb values are equal to the given ones\n     */\n    equals(otherColor) {\n        return (otherColor &&\n            this.r === otherColor.r &&\n            this.g === otherColor.g &&\n            this.b === otherColor.b);\n    }\n    /**\n     * Determines equality between the current Color3 object and a set of r,b,g values\n     * @param r - defines the red component to check\n     * @param g - defines the green component to check\n     * @param b - defines the blue component to check\n     * @returns true if the rgb values are equal to the given ones\n     */\n    equalsFloats(r, g, b) {\n        return this.r === r && this.g === g && this.b === b;\n    }\n    /**\n     * Multiplies in place each rgb value by scale\n     * @param scale - defines the scaling factor\n     * @returns the updated Color3\n     */\n    scale(scale) {\n        return new Color3(this.r * scale, this.g * scale, this.b * scale);\n    }\n    /**\n     * Multiplies the rgb values by scale and stores the result into \"result\"\n     * @param scale - defines the scaling factor\n     * @param result - defines the Color3 object where to store the result\n     * @returns the unmodified current Color3\n     */\n    scaleToRef(scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        return this;\n    }\n    /**\n     * Scale the current Color3 values by a factor and add the result to a given Color3\n     * @param scale - defines the scale factor\n     * @param result - defines color to store the result into\n     * @returns the unmodified current Color3\n     */\n    scaleAndAddToRef(scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        return this;\n    }\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min - defines minimum clamping value (default is 0)\n     * @param max - defines maximum clamping value (default is 1)\n     * @param result - defines color to store the result into\n     * @returns the original Color3\n     */\n    clampToRef(min = 0, max = 1, result) {\n        result.r = Scalar_1.Scalar.Clamp(this.r, min, max);\n        result.g = Scalar_1.Scalar.Clamp(this.g, min, max);\n        result.b = Scalar_1.Scalar.Clamp(this.b, min, max);\n        return this;\n    }\n    /**\n     * Creates a new Color3 set with the added values of the current Color3 and of the given one\n     * @param otherColor - defines the second operand\n     * @returns the new Color3\n     */\n    add(otherColor) {\n        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);\n    }\n    /**\n     * Stores the result of the addition of the current Color3 and given one rgb values into \"result\"\n     * @param otherColor - defines the second operand\n     * @param result - defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    addToRef(otherColor, result) {\n        result.r = this.r + otherColor.r;\n        result.g = this.g + otherColor.g;\n        result.b = this.b + otherColor.b;\n        return this;\n    }\n    /**\n     * Returns a new Color3 set with the subtracted values of the given one from the current Color3\n     * @param otherColor - defines the second operand\n     * @returns the new Color3\n     */\n    subtract(otherColor) {\n        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);\n    }\n    /**\n     * Stores the result of the subtraction of given one from the current Color3 rgb values into \"result\"\n     * @param otherColor - defines the second operand\n     * @param result - defines Color3 object to store the result into\n     * @returns the unmodified current Color3\n     */\n    subtractToRef(otherColor, result) {\n        result.r = this.r - otherColor.r;\n        result.g = this.g - otherColor.g;\n        result.b = this.b - otherColor.b;\n        return this;\n    }\n    /**\n     * Copy the current object\n     * @returns a new Color3 copied the current one\n     */\n    clone() {\n        return new Color3(this.r, this.g, this.b);\n    }\n    /**\n     * Copies the rgb values from the source in the current Color3\n     * @param source - defines the source Color3 object\n     * @returns the updated Color3 object\n     */\n    copyFrom(source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        return this;\n    }\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r - defines the red component to read from\n     * @param g - defines the green component to read from\n     * @param b - defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    copyFromFloats(r, g, b) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        return this;\n    }\n    /**\n     * Updates the Color3 rgb values from the given floats\n     * @param r - defines the red component to read from\n     * @param g - defines the green component to read from\n     * @param b - defines the blue component to read from\n     * @returns the current Color3 object\n     */\n    set(r, g, b) {\n        return this.copyFromFloats(r, g, b);\n    }\n    /**\n     * Compute the Color3 hexadecimal code as a string\n     * @returns a string containing the hexadecimal representation of the Color3 object\n     */\n    toHexString() {\n        const intR = (this.r * 255) | 0;\n        const intG = (this.g * 255) | 0;\n        const intB = (this.b * 255) | 0;\n        return '#' + Scalar_1.Scalar.ToHex(intR) + Scalar_1.Scalar.ToHex(intG) + Scalar_1.Scalar.ToHex(intB);\n    }\n    /**\n     * Computes a new Color3 converted from the current one to linear space\n     * @returns a new Color3 object\n     */\n    toLinearSpace() {\n        const convertedColor = new Color3();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color3 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor - defines the Color3 object where to store the linear space version\n     * @returns the unmodified Color3\n     */\n    toLinearSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, types_1.ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, types_1.ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, types_1.ToLinearSpace);\n        return this;\n    }\n    /**\n     * Computes a new Color3 converted from the current one to gamma space\n     * @returns a new Color3 object\n     */\n    toGammaSpace() {\n        const convertedColor = new Color3();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color3 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor - defines the Color3 object where to store the gamma space version\n     * @returns the unmodified Color3\n     */\n    toGammaSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, types_1.ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, types_1.ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, types_1.ToGammaSpace);\n        return this;\n    }\n    /**\n     * Serializes Color3\n     */\n    toJSON() {\n        return {\n            r: this.r,\n            g: this.g,\n            b: this.b\n        };\n    }\n}\nexports.Color3 = Color3;\n//# sourceMappingURL=Color3.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Color3.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Color4.js":
/*!***************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Color4.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Color4 = void 0;\nconst Scalar_1 = __webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\n/**\n * Class used to hold a RBGA color\n * @public\n */\nclass Color4 {\n    /**\n     * Creates a new Color4 object from red, green, blue values, all between 0 and 1\n     * @param r - defines the red component (between 0 and 1, default is 0)\n     * @param g - defines the green component (between 0 and 1, default is 0)\n     * @param b - defines the blue component (between 0 and 1, default is 0)\n     * @param a - defines the alpha component (between 0 and 1, default is 1)\n     */\n    constructor(\n    /**\n     * Defines the red component (between 0 and 1, default is 0)\n     */\n    r = 0, \n    /**\n     * Defines the green component (between 0 and 1, default is 0)\n     */\n    g = 0, \n    /**\n     * Defines the blue component (between 0 and 1, default is 0)\n     */\n    b = 0, \n    /**\n     * Defines the alpha component (between 0 and 1, default is 1)\n     */\n    a = 1) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n    }\n    // Statics\n    /**\n     * Creates a new Color4 from the string containing valid hexadecimal values\n     * @param hex - defines a string containing valid hexadecimal values\n     * @returns a new Color4 object\n     */\n    static FromHexString(hex) {\n        if (hex.substring(0, 1) !== '#' || hex.length !== 9) {\n            return new Color4(0.0, 0.0, 0.0, 0.0);\n        }\n        const r = parseInt(hex.substring(1, 3), 16);\n        const g = parseInt(hex.substring(3, 5), 16);\n        const b = parseInt(hex.substring(5, 7), 16);\n        const a = parseInt(hex.substring(7, 9), 16);\n        return Color4.FromInts(r, g, b, a);\n    }\n    /**\n     * Creates a new Color4 object set with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left - defines the start value\n     * @param right - defines the end value\n     * @param amount - defines the gradient factor\n     * @returns a new Color4 object\n     */\n    static Lerp(left, right, amount) {\n        const result = new Color4(0.0, 0.0, 0.0, 0.0);\n        Color4.LerpToRef(left, right, amount, result);\n        return result;\n    }\n    /**\n     * Set the given \"result\" with the linearly interpolated values of \"amount\" between the left Color4 object and the right Color4 object\n     * @param left - defines the start value\n     * @param right - defines the end value\n     * @param amount - defines the gradient factor\n     * @param result - defines the Color4 object where to store data\n     */\n    static LerpToRef(left, right, amount, result) {\n        result.r = left.r + (right.r - left.r) * amount;\n        result.g = left.g + (right.g - left.g) * amount;\n        result.b = left.b + (right.b - left.b) * amount;\n        result.a = left.a + (right.a - left.a) * amount;\n    }\n    /**\n     * Returns a Color4 value containing a red color\n     * @returns a new Color3 object\n     */\n    static Red() {\n        return new Color4(1.0, 0, 0, 1.0);\n    }\n    /**\n     * Returns a Color4 value containing a green color\n     * @returns a new Color4 object\n     */\n    static Green() {\n        return new Color4(0, 1.0, 0, 1.0);\n    }\n    /**\n     * Returns a Color4 value containing a blue color\n     * @returns a new Color4 object\n     */\n    static Blue() {\n        return new Color4(0, 0, 1.0, 1.0);\n    }\n    /**\n     * Returns a Color4 value containing a black color\n     * @returns a new Color4 object\n     */\n    static Black() {\n        return new Color4(0, 0, 0, 1);\n    }\n    /**\n     * Returns a Color4 value containing a white color\n     * @returns a new Color4 object\n     */\n    static White() {\n        return new Color4(1, 1, 1, 1);\n    }\n    /**\n     * Returns a Color4 value containing a purple color\n     * @returns a new Color4 object\n     */\n    static Purple() {\n        return new Color4(0.5, 0, 0.5, 1);\n    }\n    /**\n     * Returns a Color4 value containing a magenta color\n     * @returns a new Color4 object\n     */\n    static Magenta() {\n        return new Color4(1, 0, 1, 1);\n    }\n    /**\n     * Returns a Color4 value containing a yellow color\n     * @returns a new Color4 object\n     */\n    static Yellow() {\n        return new Color4(1, 1, 0, 1);\n    }\n    /**\n     * Returns a Color4 value containing a gray color\n     * @returns a new Color4 object\n     */\n    static Gray() {\n        return new Color4(0.5, 0.5, 0.5, 1.0);\n    }\n    /**\n     * Returns a Color4 value containing a teal color\n     * @returns a new Color4 object\n     */\n    static Teal() {\n        return new Color4(0, 1.0, 1.0, 1.0);\n    }\n    /**\n     * Returns a Color4 value containing a transparent color\n     * @returns a new Color4 object\n     */\n    static Clear() {\n        return new Color4(0, 0, 0, 0);\n    }\n    /**\n     * Creates a new Color4 from a Color3 and an alpha value\n     * @param color3 - defines the source Color3 to read from\n     * @param alpha - defines the alpha component (1.0 by default)\n     * @returns a new Color4 object\n     */\n    static FromColor3(color3, alpha = 1.0) {\n        return new Color4(color3.r, color3.g, color3.b, alpha);\n    }\n    /**\n     * Creates a new Color4 from the starting index element of the given array\n     * @param array - defines the source array to read from\n     * @param offset - defines the offset in the source array\n     * @returns a new Color4 object\n     */\n    static FromArray(array, offset = 0) {\n        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    }\n    /**\n     * Creates a new Color3 from integer values (less than 256)\n     * @param r - defines the red component to read from (value between 0 and 255)\n     * @param g - defines the green component to read from (value between 0 and 255)\n     * @param b - defines the blue component to read from (value between 0 and 255)\n     * @param a - defines the alpha component to read from (value between 0 and 255)\n     * @returns a new Color3 object\n     */\n    static FromInts(r, g, b, a) {\n        return new Color4(r / 255.0, g / 255.0, b / 255.0, a / 255.0);\n    }\n    /**\n     * Check the content of a given array and convert it to an array containing RGBA data\n     * If the original array was already containing count * 4 values then it is returned directly\n     * @param colors - defines the array to check\n     * @param count - defines the number of RGBA data to expect\n     * @returns an array containing count * 4 values (RGBA)\n     */\n    static CheckColors4(colors, count) {\n        // Check if color3 was used\n        if (colors.length === count * 3) {\n            const colors4 = [];\n            for (let index = 0; index < colors.length; index += 3) {\n                const newIndex = (index / 3) * 4;\n                colors4[newIndex] = colors[index];\n                colors4[newIndex + 1] = colors[index + 1];\n                colors4[newIndex + 2] = colors[index + 2];\n                colors4[newIndex + 3] = 1.0;\n            }\n            return colors4;\n        }\n        return colors;\n    }\n    // Operators\n    /**\n     * Adds in place the given Color4 values to the current Color4 object\n     * @param right - defines the second operand\n     * @returns the current updated Color4 object\n     */\n    addInPlace(right) {\n        this.r += right.r;\n        this.g += right.g;\n        this.b += right.b;\n        this.a += right.a;\n        return this;\n    }\n    /**\n     * Creates a new array populated with 4 numeric elements : red, green, blue, alpha values\n     * @returns the new array\n     */\n    asArray() {\n        const result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Stores from the starting index in the given array the Color4 successive values\n     * @param array - defines the array where to store the r,g,b components\n     * @param index - defines an optional index in the target array to define where to start storing values\n     * @returns the current Color4 object\n     */\n    toArray(array, index = 0) {\n        array[index] = this.r;\n        array[index + 1] = this.g;\n        array[index + 2] = this.b;\n        array[index + 3] = this.a;\n        return this;\n    }\n    /**\n     * Creates a new Color4 set with the added values of the current Color4 and of the given one\n     * @param right - defines the second operand\n     * @returns a new Color4 object\n     */\n    add(right) {\n        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);\n    }\n    /**\n     * Creates a new Color4 set with the subtracted values of the given one from the current Color4\n     * @param right - defines the second operand\n     * @returns a new Color4 object\n     */\n    subtract(right) {\n        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);\n    }\n    /**\n     * Subtracts the given ones from the current Color4 values and stores the results in \"result\"\n     * @param right - defines the second operand\n     * @param result - defines the Color4 object where to store the result\n     * @returns the current Color4 object\n     */\n    subtractToRef(right, result) {\n        result.r = this.r - right.r;\n        result.g = this.g - right.g;\n        result.b = this.b - right.b;\n        result.a = this.a - right.a;\n        return this;\n    }\n    /**\n     * Creates a new Color4 with the current Color4 values multiplied by scale\n     * @param scale - defines the scaling factor to apply\n     * @returns a new Color4 object\n     */\n    scale(scale) {\n        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);\n    }\n    /**\n     * Multiplies the current Color4 values by scale and stores the result in \"result\"\n     * @param scale - defines the scaling factor to apply\n     * @param result - defines the Color4 object where to store the result\n     * @returns the current unmodified Color4\n     */\n    scaleToRef(scale, result) {\n        result.r = this.r * scale;\n        result.g = this.g * scale;\n        result.b = this.b * scale;\n        result.a = this.a * scale;\n        return this;\n    }\n    /**\n     * Scale the current Color4 values by a factor and add the result to a given Color4\n     * @param scale - defines the scale factor\n     * @param result - defines the Color4 object where to store the result\n     * @returns the unmodified current Color4\n     */\n    scaleAndAddToRef(scale, result) {\n        result.r += this.r * scale;\n        result.g += this.g * scale;\n        result.b += this.b * scale;\n        result.a += this.a * scale;\n        return this;\n    }\n    /**\n     * Clamps the rgb values by the min and max values and stores the result into \"result\"\n     * @param min - defines minimum clamping value (default is 0)\n     * @param max - defines maximum clamping value (default is 1)\n     * @param result - defines color to store the result into.\n     * @returns the cuurent Color4\n     */\n    clampToRef(min = 0, max = 1, result) {\n        result.r = Scalar_1.Scalar.Clamp(this.r, min, max);\n        result.g = Scalar_1.Scalar.Clamp(this.g, min, max);\n        result.b = Scalar_1.Scalar.Clamp(this.b, min, max);\n        result.a = Scalar_1.Scalar.Clamp(this.a, min, max);\n        return this;\n    }\n    /**\n     * Multipy an Color4 value by another and return a new Color4 object\n     * @param color - defines the Color4 value to multiply by\n     * @returns a new Color4 object\n     */\n    multiply(color) {\n        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);\n    }\n    /**\n     * Multipy a Color4 value by another and push the result in a reference value\n     * @param color - defines the Color4 value to multiply by\n     * @param result - defines the Color4 to fill the result in\n     * @returns the result Color4\n     */\n    multiplyToRef(color, result) {\n        result.r = this.r * color.r;\n        result.g = this.g * color.g;\n        result.b = this.b * color.b;\n        result.a = this.a * color.a;\n        return result;\n    }\n    /**\n     * Creates a string with the Color4 current values\n     * @returns the string representation of the Color4 object\n     */\n    toString() {\n        return ('{R: ' + this.r + ' G:' + this.g + ' B:' + this.b + ' A:' + this.a + '}');\n    }\n    /**\n     * Returns the string \"Color4\"\n     * @returns \"Color4\"\n     */\n    getClassName() {\n        return 'Color4';\n    }\n    /**\n     * Compute the Color4 hash code\n     * @returns an unique number that can be used to hash Color4 objects\n     */\n    getHashCode() {\n        let hash = this.r || 0;\n        hash = (hash * 397) ^ (this.g || 0);\n        hash = (hash * 397) ^ (this.b || 0);\n        hash = (hash * 397) ^ (this.a || 0);\n        return hash;\n    }\n    /**\n     * Creates a new Color4 copied from the current one\n     * @returns a new Color4 object\n     */\n    clone() {\n        return new Color4(this.r, this.g, this.b, this.a);\n    }\n    /**\n     * Copies the given Color4 values into the current one\n     * @param source - defines the source Color4 object\n     * @returns the current updated Color4 object\n     */\n    copyFrom(source) {\n        this.r = source.r;\n        this.g = source.g;\n        this.b = source.b;\n        this.a = source.a;\n        return this;\n    }\n    /**\n     * Copies the given float values into the current one\n     * @param r - defines the red component to read from\n     * @param g - defines the green component to read from\n     * @param b - defines the blue component to read from\n     * @param a - defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    copyFromFloats(r, g, b, a) {\n        this.r = r;\n        this.g = g;\n        this.b = b;\n        this.a = a;\n        return this;\n    }\n    /**\n     * Copies the given float values into the current one\n     * @param r - defines the red component to read from\n     * @param g - defines the green component to read from\n     * @param b - defines the blue component to read from\n     * @param a - defines the alpha component to read from\n     * @returns the current updated Color4 object\n     */\n    set(r, g, b, a) {\n        return this.copyFromFloats(r, g, b, a);\n    }\n    /**\n     * Compute the Color4 hexadecimal code as a string\n     * @returns a string containing the hexadecimal representation of the Color4 object\n     */\n    toHexString() {\n        const intR = (this.r * 255) | 0;\n        const intG = (this.g * 255) | 0;\n        const intB = (this.b * 255) | 0;\n        const intA = (this.a * 255) | 0;\n        return ('#' +\n            Scalar_1.Scalar.ToHex(intR) +\n            Scalar_1.Scalar.ToHex(intG) +\n            Scalar_1.Scalar.ToHex(intB) +\n            Scalar_1.Scalar.ToHex(intA));\n    }\n    /**\n     * Computes a new Color4 converted from the current one to linear space\n     * @returns a new Color4 object\n     */\n    toLinearSpace() {\n        const convertedColor = new Color4();\n        this.toLinearSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color4 values to linear space and stores the result in \"convertedColor\"\n     * @param convertedColor - defines the Color4 object where to store the linear space version\n     * @returns the unmodified Color4\n     */\n    toLinearSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, types_1.ToLinearSpace);\n        convertedColor.g = Math.pow(this.g, types_1.ToLinearSpace);\n        convertedColor.b = Math.pow(this.b, types_1.ToLinearSpace);\n        convertedColor.a = this.a;\n        return this;\n    }\n    /**\n     * Computes a new Color4 converted from the current one to gamma space\n     * @returns a new Color4 object\n     */\n    toGammaSpace() {\n        const convertedColor = new Color4();\n        this.toGammaSpaceToRef(convertedColor);\n        return convertedColor;\n    }\n    /**\n     * Converts the Color4 values to gamma space and stores the result in \"convertedColor\"\n     * @param convertedColor - defines the Color4 object where to store the gamma space version\n     * @returns the unmodified Color4\n     */\n    toGammaSpaceToRef(convertedColor) {\n        convertedColor.r = Math.pow(this.r, types_1.ToGammaSpace);\n        convertedColor.g = Math.pow(this.g, types_1.ToGammaSpace);\n        convertedColor.b = Math.pow(this.b, types_1.ToGammaSpace);\n        convertedColor.a = this.a;\n        return this;\n    }\n}\nexports.Color4 = Color4;\n//# sourceMappingURL=Color4.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Color4.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Curve3d.js":
/*!****************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Curve3d.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Curve3 = void 0;\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\n/**\n * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n * A Curve3 is designed from a series of successive Vector3.\n * {@link https://doc.babylonjs.com/how_to/how_to_use_curve3 }\n * @public\n */\nclass Curve3 {\n    /**\n     * A Curve3 object is a logical object, so not a mesh, to handle curves in the 3D geometric space.\n     * A Curve3 is designed from a series of successive Vector3.\n     * {@link http://doc.babylonjs.com/tutorials/How_to_use_Curve3#curve3-object | Tutorial }\n     * @param points - points which make up the curve\n     */\n    constructor(points) {\n        this._length = 0.0;\n        this._points = points;\n        this._length = this._computeLength(points);\n    }\n    /**\n     * Returns a Curve3 object along a Quadratic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#quadratic-bezier-curve\n     * @param v0 - (Vector3) the origin point of the Quadratic Bezier\n     * @param v1 - (Vector3) the control point\n     * @param v2 - (Vector3) the end point of the Quadratic Bezier\n     * @param nbPoints - (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    static CreateQuadraticBezier(v0, v1, v2, nbPoints) {\n        // tslint:disable-next-line:no-parameter-reassignment\n        nbPoints = nbPoints > 2 ? nbPoints : 3;\n        const bez = new Array();\n        const equation = (t, val0, val1, val2) => {\n            const res = (1.0 - t) * (1.0 - t) * val0 + 2.0 * t * (1.0 - t) * val1 + t * t * val2;\n            return res;\n        };\n        for (let i = 0; i <= nbPoints; i++) {\n            bez.push(new Vector3_1.Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));\n        }\n        return new Curve3(bez);\n    }\n    /**\n     * Returns a Curve3 object along a Cubic Bezier curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#cubic-bezier-curve\n     * @param v0 - (Vector3) the origin point of the Cubic Bezier\n     * @param v1 - (Vector3) the first control point\n     * @param v2 - (Vector3) the second control point\n     * @param v3 - (Vector3) the end point of the Cubic Bezier\n     * @param nbPoints - (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {\n        // tslint:disable-next-line:no-parameter-reassignment\n        nbPoints = nbPoints > 3 ? nbPoints : 4;\n        const bez = new Array();\n        const equation = (t, val0, val1, val2, val3) => {\n            const res = (1.0 - t) * (1.0 - t) * (1.0 - t) * val0 +\n                3.0 * t * (1.0 - t) * (1.0 - t) * val1 +\n                3.0 * t * t * (1.0 - t) * val2 +\n                t * t * t * val3;\n            return res;\n        };\n        for (let i = 0; i <= nbPoints; i++) {\n            bez.push(new Vector3_1.Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));\n        }\n        return new Curve3(bez);\n    }\n    /**\n     * Returns a Curve3 object along a Hermite Spline curve : http://doc.babylonjs.com/tutorials/How_to_use_Curve3#hermite-spline\n     * @param p1 - (Vector3) the origin point of the Hermite Spline\n     * @param t1 - (Vector3) the tangent vector at the origin point\n     * @param p2 - (Vector3) the end point of the Hermite Spline\n     * @param t2 - (Vector3) the tangent vector at the end point\n     * @param nbPoints - (integer) the wanted number of points in the curve\n     * @returns the created Curve3\n     */\n    static CreateHermiteSpline(p1, t1, p2, t2, nbPoints) {\n        const hermite = new Array();\n        const step = 1.0 / nbPoints;\n        for (let i = 0; i <= nbPoints; i++) {\n            hermite.push(Vector3_1.Vector3.Hermite(p1, t1, p2, t2, i * step));\n        }\n        return new Curve3(hermite);\n    }\n    /**\n     * Returns a Curve3 object along a CatmullRom Spline curve :\n     * @param points - (array of Vector3) the points the spline must pass through. At least, four points required\n     * @param nbPoints - (integer) the wanted number of points between each curve control points\n     * @param closed - (boolean) optional with default false, when true forms a closed loop from the points\n     * @returns the created Curve3\n     */\n    static CreateCatmullRomSpline(points, nbPoints, closed) {\n        const catmullRom = new Array();\n        const step = 1.0 / nbPoints;\n        let amount = 0.0;\n        if (closed) {\n            const pointsCount = points.length;\n            for (let i = 0; i < pointsCount; i++) {\n                amount = 0;\n                for (let c = 0; c < nbPoints; c++) {\n                    catmullRom.push(Vector3_1.Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));\n                    amount += step;\n                }\n            }\n            catmullRom.push(catmullRom[0]);\n        }\n        else {\n            const totalPoints = new Array();\n            totalPoints.push(points[0].clone());\n            Array.prototype.push.apply(totalPoints, points);\n            totalPoints.push(points[points.length - 1].clone());\n            let i = 0;\n            for (i = 0; i < totalPoints.length - 3; i++) {\n                amount = 0;\n                for (let c = 0; c < nbPoints; c++) {\n                    catmullRom.push(Vector3_1.Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n                    amount += step;\n                }\n            }\n            i--;\n            catmullRom.push(Vector3_1.Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));\n        }\n        return new Curve3(catmullRom);\n    }\n    /**\n     * @returns the Curve3 stored array of successive Vector3\n     */\n    getPoints() {\n        return this._points;\n    }\n    /**\n     * @returns the computed length (float) of the curve.\n     */\n    length() {\n        return this._length;\n    }\n    /**\n     * Returns a new instance of Curve3 object : var curve = curveA.continue(curveB);\n     * This new Curve3 is built by translating and sticking the curveB at the end of the curveA.\n     * curveA and curveB keep unchanged.\n     * @param curve - the curve to continue from this curve\n     * @returns the newly constructed curve\n     */\n    continue(curve) {\n        const lastPoint = this._points[this._points.length - 1];\n        const continuedPoints = this._points.slice();\n        const curvePoints = curve.getPoints();\n        for (let i = 1; i < curvePoints.length; i++) {\n            continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));\n        }\n        const continuedCurve = new Curve3(continuedPoints);\n        return continuedCurve;\n    }\n    _computeLength(path) {\n        let l = 0;\n        for (let i = 1; i < path.length; i++) {\n            l += path[i].subtract(path[i - 1]).length();\n        }\n        return l;\n    }\n}\nexports.Curve3 = Curve3;\n//# sourceMappingURL=Curve3d.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Curve3d.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Furstum.js":
/*!****************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Furstum.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Frustum = void 0;\nconst Plane_1 = __webpack_require__(/*! ./Plane */ \"./node_modules/@dcl/ecs-math/dist/Plane.js\");\n/**\n * Reprasents a camera frustum\n * @public\n */\nclass Frustum {\n    /**\n     * Gets the planes representing the frustum\n     * @param transform - matrix to be applied to the returned planes\n     * @returns a new array of 6 Frustum planes computed by the given transformation matrix.\n     */\n    static GetPlanes(transform) {\n        const frustumPlanes = [];\n        for (let index = 0; index < 6; index++) {\n            frustumPlanes.push(new Plane_1.Plane(0.0, 0.0, 0.0, 0.0));\n        }\n        Frustum.GetPlanesToRef(transform, frustumPlanes);\n        return frustumPlanes;\n    }\n    /**\n     * Gets the near frustum plane transformed by the transform matrix\n     * @param transform - transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane - the resuling frustum plane\n     */\n    static GetNearPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] + m[2];\n        frustumPlane.normal.y = m[7] + m[6];\n        frustumPlane.normal.z = m[11] + m[10];\n        frustumPlane.d = m[15] + m[14];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the far frustum plane transformed by the transform matrix\n     * @param transform - transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane - the resuling frustum plane\n     */\n    static GetFarPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] - m[2];\n        frustumPlane.normal.y = m[7] - m[6];\n        frustumPlane.normal.z = m[11] - m[10];\n        frustumPlane.d = m[15] - m[14];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the left frustum plane transformed by the transform matrix\n     * @param transform - transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane - the resuling frustum plane\n     */\n    static GetLeftPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] + m[0];\n        frustumPlane.normal.y = m[7] + m[4];\n        frustumPlane.normal.z = m[11] + m[8];\n        frustumPlane.d = m[15] + m[12];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the right frustum plane transformed by the transform matrix\n     * @param transform - transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane - the resuling frustum plane\n     */\n    static GetRightPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] - m[0];\n        frustumPlane.normal.y = m[7] - m[4];\n        frustumPlane.normal.z = m[11] - m[8];\n        frustumPlane.d = m[15] - m[12];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the top frustum plane transformed by the transform matrix\n     * @param transform - transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane - the resuling frustum plane\n     */\n    static GetTopPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] - m[1];\n        frustumPlane.normal.y = m[7] - m[5];\n        frustumPlane.normal.z = m[11] - m[9];\n        frustumPlane.d = m[15] - m[13];\n        frustumPlane.normalize();\n    }\n    /**\n     * Gets the bottom frustum plane transformed by the transform matrix\n     * @param transform - transformation matrix to be applied to the resulting frustum plane\n     * @param frustumPlane - the resuling frustum plane\n     */\n    static GetBottomPlaneToRef(transform, frustumPlane) {\n        const m = transform.m;\n        frustumPlane.normal.x = m[3] + m[1];\n        frustumPlane.normal.y = m[7] + m[5];\n        frustumPlane.normal.z = m[11] + m[9];\n        frustumPlane.d = m[15] + m[13];\n        frustumPlane.normalize();\n    }\n    /**\n     * Sets the given array \"frustumPlanes\" with the 6 Frustum planes computed by the given transformation matrix.\n     * @param transform - transformation matrix to be applied to the resulting frustum planes\n     * @param frustumPlanes - the resuling frustum planes\n     */\n    static GetPlanesToRef(transform, frustumPlanes) {\n        // Near\n        Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);\n        // Far\n        Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);\n        // Left\n        Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);\n        // Right\n        Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);\n        // Top\n        Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);\n        // Bottom\n        Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);\n    }\n}\nexports.Frustum = Frustum;\n//# sourceMappingURL=Furstum.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Furstum.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Matrix.js":
/*!***************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Matrix.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Matrix = void 0;\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\nconst Quaternion_1 = __webpack_require__(/*! ./Quaternion */ \"./node_modules/@dcl/ecs-math/dist/Quaternion.js\");\nconst preallocatedVariables_1 = __webpack_require__(/*! ./preallocatedVariables */ \"./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js\");\nconst Vector4_1 = __webpack_require__(/*! ./Vector4 */ \"./node_modules/@dcl/ecs-math/dist/Vector4.js\");\n/**\n * Class used to store matrix data (4x4)\n * @public\n */\nclass Matrix {\n    /**\n     * Creates an empty matrix (filled with zeros)\n     */\n    constructor() {\n        this._isIdentity = false;\n        this._isIdentityDirty = true;\n        this._isIdentity3x2 = true;\n        this._isIdentity3x2Dirty = true;\n        this._m = [\n            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n        ];\n        this._updateIdentityStatus(false);\n    }\n    /**\n     * Gets the internal data of the matrix\n     */\n    get m() {\n        return this._m;\n    }\n    /**\n     * Gets an identity matrix that must not be updated\n     */\n    static get IdentityReadOnly() {\n        return Matrix._identityReadOnly;\n    }\n    // Statics\n    /**\n     * Creates a matrix from an array\n     * @param array - defines the source array\n     * @param offset - defines an offset in the source array\n     * @returns a new Matrix set from the starting index of the given array\n     */\n    static FromArray(array, offset = 0) {\n        const result = new Matrix();\n        Matrix.FromArrayToRef(array, offset, result);\n        return result;\n    }\n    /**\n     * Copy the content of an array into a given matrix\n     * @param array - defines the source array\n     * @param offset - defines an offset in the source array\n     * @param result - defines the target matrix\n     */\n    static FromArrayToRef(array, offset, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] = array[index + offset];\n        }\n        result._markAsUpdated();\n    }\n    /**\n     * Stores an array into a matrix after having multiplied each component by a given factor\n     * @param array - defines the source array\n     * @param offset - defines the offset in the source array\n     * @param scale - defines the scaling factor\n     * @param result - defines the target matrix\n     */\n    static FromFloatArrayToRefScaled(array, offset, scale, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] = array[index + offset] * scale;\n        }\n        result._markAsUpdated();\n    }\n    /**\n     * Stores a list of values (16) inside a given matrix\n     * @param initialM11 - defines 1st value of 1st row\n     * @param initialM12 - defines 2nd value of 1st row\n     * @param initialM13 - defines 3rd value of 1st row\n     * @param initialM14 - defines 4th value of 1st row\n     * @param initialM21 - defines 1st value of 2nd row\n     * @param initialM22 - defines 2nd value of 2nd row\n     * @param initialM23 - defines 3rd value of 2nd row\n     * @param initialM24 - defines 4th value of 2nd row\n     * @param initialM31 - defines 1st value of 3rd row\n     * @param initialM32 - defines 2nd value of 3rd row\n     * @param initialM33 - defines 3rd value of 3rd row\n     * @param initialM34 - defines 4th value of 3rd row\n     * @param initialM41 - defines 1st value of 4th row\n     * @param initialM42 - defines 2nd value of 4th row\n     * @param initialM43 - defines 3rd value of 4th row\n     * @param initialM44 - defines 4th value of 4th row\n     * @param result - defines the target matrix\n     */\n    static FromValuesToRef(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {\n        const m = result._m;\n        m[0] = initialM11;\n        m[1] = initialM12;\n        m[2] = initialM13;\n        m[3] = initialM14;\n        m[4] = initialM21;\n        m[5] = initialM22;\n        m[6] = initialM23;\n        m[7] = initialM24;\n        m[8] = initialM31;\n        m[9] = initialM32;\n        m[10] = initialM33;\n        m[11] = initialM34;\n        m[12] = initialM41;\n        m[13] = initialM42;\n        m[14] = initialM43;\n        m[15] = initialM44;\n        result._markAsUpdated();\n    }\n    /**\n     * Creates new matrix from a list of values (16)\n     * @param initialM11 - defines 1st value of 1st row\n     * @param initialM12 - defines 2nd value of 1st row\n     * @param initialM13 - defines 3rd value of 1st row\n     * @param initialM14 - defines 4th value of 1st row\n     * @param initialM21 - defines 1st value of 2nd row\n     * @param initialM22 - defines 2nd value of 2nd row\n     * @param initialM23 - defines 3rd value of 2nd row\n     * @param initialM24 - defines 4th value of 2nd row\n     * @param initialM31 - defines 1st value of 3rd row\n     * @param initialM32 - defines 2nd value of 3rd row\n     * @param initialM33 - defines 3rd value of 3rd row\n     * @param initialM34 - defines 4th value of 3rd row\n     * @param initialM41 - defines 1st value of 4th row\n     * @param initialM42 - defines 2nd value of 4th row\n     * @param initialM43 - defines 3rd value of 4th row\n     * @param initialM44 - defines 4th value of 4th row\n     * @returns the new matrix\n     */\n    static FromValues(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {\n        const result = new Matrix();\n        const m = result._m;\n        m[0] = initialM11;\n        m[1] = initialM12;\n        m[2] = initialM13;\n        m[3] = initialM14;\n        m[4] = initialM21;\n        m[5] = initialM22;\n        m[6] = initialM23;\n        m[7] = initialM24;\n        m[8] = initialM31;\n        m[9] = initialM32;\n        m[10] = initialM33;\n        m[11] = initialM34;\n        m[12] = initialM41;\n        m[13] = initialM42;\n        m[14] = initialM43;\n        m[15] = initialM44;\n        result._markAsUpdated();\n        return result;\n    }\n    /**\n     * Creates a new matrix composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n     * @param scale - defines the scale vector3\n     * @param rotation - defines the rotation quaternion\n     * @param translation - defines the translation vector3\n     * @returns a new matrix\n     */\n    static Compose(scale, rotation, translation) {\n        const result = new Matrix();\n        Matrix.ComposeToRef(scale, rotation, translation, result);\n        return result;\n    }\n    /**\n     * Sets a matrix to a value composed by merging scale (vector3), rotation (quaternion) and translation (vector3)\n     * @param scale - defines the scale vector3\n     * @param rotation - defines the rotation quaternion\n     * @param translation - defines the translation vector3\n     * @param result - defines the target matrix\n     */\n    static ComposeToRef(scale, rotation, translation, result) {\n        Matrix.ScalingToRef(scale.x, scale.y, scale.z, preallocatedVariables_1.MathTmp.Matrix[1]);\n        rotation.toRotationMatrix(preallocatedVariables_1.MathTmp.Matrix[0]);\n        preallocatedVariables_1.MathTmp.Matrix[1].multiplyToRef(preallocatedVariables_1.MathTmp.Matrix[0], result);\n        result.setTranslation(translation);\n    }\n    /**\n     * Creates a new identity matrix\n     * @returns a new identity matrix\n     */\n    static Identity() {\n        const identity = Matrix.FromValues(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0);\n        identity._updateIdentityStatus(true);\n        return identity;\n    }\n    /**\n     * Creates a new identity matrix and stores the result in a given matrix\n     * @param result - defines the target matrix\n     */\n    static IdentityToRef(result) {\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(true);\n    }\n    /**\n     * Creates a new zero matrix\n     * @returns a new zero matrix\n     */\n    static Zero() {\n        const zero = Matrix.FromValues(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0);\n        zero._updateIdentityStatus(false);\n        return zero;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the X axis\n     * @param angle - defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationX(angle) {\n        const result = new Matrix();\n        Matrix.RotationXToRef(angle, result);\n        return result;\n    }\n    /**\n     * Creates a new matrix as the invert of a given matrix\n     * @param source - defines the source matrix\n     * @returns the new matrix\n     */\n    static Invert(source) {\n        const result = new Matrix();\n        source.invertToRef(result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the X axis and stores it in a given matrix\n     * @param angle - defines the angle (in radians) to use\n     * @param result - defines the target matrix\n     */\n    static RotationXToRef(angle, result) {\n        const s = Math.sin(angle);\n        const c = Math.cos(angle);\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis\n     * @param angle - defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationY(angle) {\n        const result = new Matrix();\n        Matrix.RotationYToRef(angle, result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Y axis and stores it in a given matrix\n     * @param angle - defines the angle (in radians) to use\n     * @param result - defines the target matrix\n     */\n    static RotationYToRef(angle, result) {\n        const s = Math.sin(angle);\n        const c = Math.cos(angle);\n        Matrix.FromValuesToRef(c, 0.0, -s, 0.0, 0.0, 1.0, 0.0, 0.0, s, 0.0, c, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis\n     * @param angle - defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationZ(angle) {\n        const result = new Matrix();\n        Matrix.RotationZToRef(angle, result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the Z axis and stores it in a given matrix\n     * @param angle - defines the angle (in radians) to use\n     * @param result - defines the target matrix\n     */\n    static RotationZToRef(angle, result) {\n        const s = Math.sin(angle);\n        const c = Math.cos(angle);\n        Matrix.FromValuesToRef(c, s, 0.0, 0.0, -s, c, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(c === 1 && s === 0);\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the given axis\n     * @param axis - defines the axis to use\n     * @param angle - defines the angle (in radians) to use\n     * @returns the new matrix\n     */\n    static RotationAxis(axis, angle) {\n        const result = new Matrix();\n        Matrix.RotationAxisToRef(axis, angle, result);\n        return result;\n    }\n    /**\n     * Creates a new rotation matrix for \"angle\" radians around the given axis and stores it in a given matrix\n     * @param axis - defines the axis to use\n     * @param angle - defines the angle (in radians) to use\n     * @param result - defines the target matrix\n     */\n    static RotationAxisToRef(axis, angle, result) {\n        const s = Math.sin(-angle);\n        const c = Math.cos(-angle);\n        const c1 = 1 - c;\n        axis.normalize();\n        const m = result._m;\n        m[0] = axis.x * axis.x * c1 + c;\n        m[1] = axis.x * axis.y * c1 - axis.z * s;\n        m[2] = axis.x * axis.z * c1 + axis.y * s;\n        m[3] = 0.0;\n        m[4] = axis.y * axis.x * c1 + axis.z * s;\n        m[5] = axis.y * axis.y * c1 + c;\n        m[6] = axis.y * axis.z * c1 - axis.x * s;\n        m[7] = 0.0;\n        m[8] = axis.z * axis.x * c1 - axis.y * s;\n        m[9] = axis.z * axis.y * c1 + axis.x * s;\n        m[10] = axis.z * axis.z * c1 + c;\n        m[11] = 0.0;\n        m[12] = 0.0;\n        m[13] = 0.0;\n        m[14] = 0.0;\n        m[15] = 1.0;\n        result._markAsUpdated();\n    }\n    /**\n     * Creates a rotation matrix\n     * @param yaw - defines the yaw angle in radians (Y axis)\n     * @param pitch - defines the pitch angle in radians (X axis)\n     * @param roll - defines the roll angle in radians (X axis)\n     * @returns the new rotation matrix\n     */\n    static RotationYawPitchRoll(yaw, pitch, roll) {\n        const result = new Matrix();\n        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);\n        return result;\n    }\n    /**\n     * Creates a rotation matrix and stores it in a given matrix\n     * @param yaw - defines the yaw angle in radians (Y axis)\n     * @param pitch - defines the pitch angle in radians (X axis)\n     * @param roll - defines the roll angle in radians (X axis)\n     * @param result - defines the target matrix\n     */\n    static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\n        Quaternion_1.Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, preallocatedVariables_1.MathTmp.Quaternion[0]);\n        preallocatedVariables_1.MathTmp.Quaternion[0].toRotationMatrix(result);\n    }\n    /**\n     * Creates a scaling matrix\n     * @param x - defines the scale factor on X axis\n     * @param y - defines the scale factor on Y axis\n     * @param z - defines the scale factor on Z axis\n     * @returns the new matrix\n     */\n    static Scaling(x, y, z) {\n        const result = new Matrix();\n        Matrix.ScalingToRef(x, y, z, result);\n        return result;\n    }\n    /**\n     * Creates a scaling matrix and stores it in a given matrix\n     * @param x - defines the scale factor on X axis\n     * @param y - defines the scale factor on Y axis\n     * @param z - defines the scale factor on Z axis\n     * @param result - defines the target matrix\n     */\n    static ScalingToRef(x, y, z, result) {\n        Matrix.FromValuesToRef(x, 0.0, 0.0, 0.0, 0.0, y, 0.0, 0.0, 0.0, 0.0, z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);\n    }\n    /**\n     * Creates a translation matrix\n     * @param x - defines the translation on X axis\n     * @param y - defines the translation on Y axis\n     * @param z - defines the translationon Z axis\n     * @returns the new matrix\n     */\n    static Translation(x, y, z) {\n        const result = new Matrix();\n        Matrix.TranslationToRef(x, y, z, result);\n        return result;\n    }\n    /**\n     * Creates a translation matrix and stores it in a given matrix\n     * @param x - defines the translation on X axis\n     * @param y - defines the translation on Y axis\n     * @param z - defines the translationon Z axis\n     * @param result - defines the target matrix\n     */\n    static TranslationToRef(x, y, z, result) {\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, x, y, z, 1.0, result);\n        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);\n    }\n    /**\n     * Returns a new Matrix whose values are the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n     * @param startValue - defines the start value\n     * @param endValue - defines the end value\n     * @param gradient - defines the gradient factor\n     * @returns the new matrix\n     */\n    static Lerp(startValue, endValue, gradient) {\n        const result = new Matrix();\n        Matrix.LerpToRef(startValue, endValue, gradient, result);\n        return result;\n    }\n    /**\n     * Set the given matrix \"result\" as the interpolated values for \"gradient\" (float) between the ones of the matrices \"startValue\" and \"endValue\".\n     * @param startValue - defines the start value\n     * @param endValue - defines the end value\n     * @param gradient - defines the gradient factor\n     * @param result - defines the Matrix object where to store data\n     */\n    static LerpToRef(startValue, endValue, gradient, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] =\n                startValue._m[index] * (1.0 - gradient) + endValue._m[index] * gradient;\n        }\n        result._markAsUpdated();\n    }\n    /**\n     * Builds a new matrix whose values are computed by:\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n     * @param startValue - defines the first matrix\n     * @param endValue - defines the second matrix\n     * @param gradient - defines the gradient between the two matrices\n     * @returns the new matrix\n     */\n    static DecomposeLerp(startValue, endValue, gradient) {\n        const result = new Matrix();\n        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);\n        return result;\n    }\n    /**\n     * Update a matrix to values which are computed by:\n     * * decomposing the the \"startValue\" and \"endValue\" matrices into their respective scale, rotation and translation matrices\n     * * interpolating for \"gradient\" (float) the values between each of these decomposed matrices between the start and the end\n     * * recomposing a new matrix from these 3 interpolated scale, rotation and translation matrices\n     * @param startValue - defines the first matrix\n     * @param endValue - defines the second matrix\n     * @param gradient - defines the gradient between the two matrices\n     * @param result - defines the target matrix\n     */\n    static DecomposeLerpToRef(startValue, endValue, gradient, result) {\n        const startScale = preallocatedVariables_1.MathTmp.Vector3[0];\n        const startRotation = preallocatedVariables_1.MathTmp.Quaternion[0];\n        const startTranslation = preallocatedVariables_1.MathTmp.Vector3[1];\n        startValue.decompose(startScale, startRotation, startTranslation);\n        const endScale = preallocatedVariables_1.MathTmp.Vector3[2];\n        const endRotation = preallocatedVariables_1.MathTmp.Quaternion[1];\n        const endTranslation = preallocatedVariables_1.MathTmp.Vector3[3];\n        endValue.decompose(endScale, endRotation, endTranslation);\n        const resultScale = preallocatedVariables_1.MathTmp.Vector3[4];\n        Vector3_1.Vector3.LerpToRef(startScale, endScale, gradient, resultScale);\n        const resultRotation = preallocatedVariables_1.MathTmp.Quaternion[2];\n        Quaternion_1.Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);\n        const resultTranslation = preallocatedVariables_1.MathTmp.Vector3[5];\n        Vector3_1.Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);\n        Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);\n    }\n    /**\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n     * This function works in left handed mode\n     * @param eye - defines the final position of the entity\n     * @param target - defines where the entity should look at\n     * @param up - defines the up vector for the entity\n     * @returns the new matrix\n     */\n    static LookAtLH(eye, target, up) {\n        const result = new Matrix();\n        Matrix.LookAtLHToRef(eye, target, up, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n     * This function works in left handed mode\n     * @param eye - defines the final position of the entity\n     * @param target - defines where the entity should look at\n     * @param up - defines the up vector for the entity\n     * @param result - defines the target matrix\n     */\n    static LookAtLHToRef(eye, target, up, result) {\n        const xAxis = preallocatedVariables_1.MathTmp.Vector3[0];\n        const yAxis = preallocatedVariables_1.MathTmp.Vector3[1];\n        const zAxis = preallocatedVariables_1.MathTmp.Vector3[2];\n        // Z axis\n        target.subtractToRef(eye, zAxis);\n        zAxis.normalize();\n        // X axis\n        Vector3_1.Vector3.CrossToRef(up, zAxis, xAxis);\n        const xSquareLength = xAxis.lengthSquared();\n        if (xSquareLength === 0) {\n            xAxis.x = 1.0;\n        }\n        else {\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n        }\n        // Y axis\n        Vector3_1.Vector3.CrossToRef(zAxis, xAxis, yAxis);\n        yAxis.normalize();\n        // Eye angles\n        const ex = -Vector3_1.Vector3.Dot(xAxis, eye);\n        const ey = -Vector3_1.Vector3.Dot(yAxis, eye);\n        const ez = -Vector3_1.Vector3.Dot(zAxis, eye);\n        Matrix.FromValuesToRef(xAxis.x, yAxis.x, zAxis.x, 0.0, xAxis.y, yAxis.y, zAxis.y, 0.0, xAxis.z, yAxis.z, zAxis.z, 0.0, ex, ey, ez, 1.0, result);\n    }\n    /**\n     * Gets a new rotation matrix used to rotate an entity so as it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\"\n     * This function works in right handed mode\n     * @param eye - defines the final position of the entity\n     * @param target - defines where the entity should look at\n     * @param up - defines the up vector for the entity\n     * @returns the new matrix\n     */\n    static LookAtRH(eye, target, up) {\n        const result = new Matrix();\n        Matrix.LookAtRHToRef(eye, target, up, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" Matrix to a rotation matrix used to rotate an entity so that it looks at the target vector3, from the eye vector3 position, the up vector3 being oriented like \"up\".\n     * This function works in right handed mode\n     * @param eye - defines the final position of the entity\n     * @param target - defines where the entity should look at\n     * @param up - defines the up vector for the entity\n     * @param result - defines the target matrix\n     */\n    static LookAtRHToRef(eye, target, up, result) {\n        const xAxis = preallocatedVariables_1.MathTmp.Vector3[0];\n        const yAxis = preallocatedVariables_1.MathTmp.Vector3[1];\n        const zAxis = preallocatedVariables_1.MathTmp.Vector3[2];\n        // Z axis\n        eye.subtractToRef(target, zAxis);\n        zAxis.normalize();\n        // X axis\n        Vector3_1.Vector3.CrossToRef(up, zAxis, xAxis);\n        const xSquareLength = xAxis.lengthSquared();\n        if (xSquareLength === 0) {\n            xAxis.x = 1.0;\n        }\n        else {\n            xAxis.normalizeFromLength(Math.sqrt(xSquareLength));\n        }\n        // Y axis\n        Vector3_1.Vector3.CrossToRef(zAxis, xAxis, yAxis);\n        yAxis.normalize();\n        // Eye angles\n        const ex = -Vector3_1.Vector3.Dot(xAxis, eye);\n        const ey = -Vector3_1.Vector3.Dot(yAxis, eye);\n        const ez = -Vector3_1.Vector3.Dot(zAxis, eye);\n        Matrix.FromValuesToRef(xAxis.x, yAxis.x, zAxis.x, 0.0, xAxis.y, yAxis.y, zAxis.y, 0.0, xAxis.z, yAxis.z, zAxis.z, 0.0, ex, ey, ez, 1.0, result);\n    }\n    /**\n     * Create a left-handed orthographic projection matrix\n     * @param width - defines the viewport width\n     * @param height - defines the viewport height\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @returns a new matrix as a left-handed orthographic projection matrix\n     */\n    static OrthoLH(width, height, znear, zfar) {\n        const matrix = new Matrix();\n        Matrix.OrthoLHToRef(width, height, znear, zfar, matrix);\n        return matrix;\n    }\n    /**\n     * Store a left-handed orthographic projection to a given matrix\n     * @param width - defines the viewport width\n     * @param height - defines the viewport height\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @param result - defines the target matrix\n     */\n    static OrthoLHToRef(width, height, znear, zfar, result) {\n        const n = znear;\n        const f = zfar;\n        const a = 2.0 / width;\n        const b = 2.0 / height;\n        const c = 2.0 / (f - n);\n        const d = -(f + n) / (f - n);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, 0.0, 0.0, d, 1.0, result);\n        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);\n    }\n    /**\n     * Create a left-handed orthographic projection matrix\n     * @param left - defines the viewport left coordinate\n     * @param right - defines the viewport right coordinate\n     * @param bottom - defines the viewport bottom coordinate\n     * @param top - defines the viewport top coordinate\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @returns a new matrix as a left-handed orthographic projection matrix\n     */\n    static OrthoOffCenterLH(left, right, bottom, top, znear, zfar) {\n        const matrix = new Matrix();\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix);\n        return matrix;\n    }\n    /**\n     * Stores a left-handed orthographic projection into a given matrix\n     * @param left - defines the viewport left coordinate\n     * @param right - defines the viewport right coordinate\n     * @param bottom - defines the viewport bottom coordinate\n     * @param top - defines the viewport top coordinate\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @param result - defines the target matrix\n     */\n    static OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result) {\n        const n = znear;\n        const f = zfar;\n        const a = 2.0 / (right - left);\n        const b = 2.0 / (top - bottom);\n        const c = 2.0 / (f - n);\n        const d = -(f + n) / (f - n);\n        const i0 = (left + right) / (left - right);\n        const i1 = (top + bottom) / (bottom - top);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 0.0, i0, i1, d, 1.0, result);\n        result._markAsUpdated();\n    }\n    /**\n     * Creates a right-handed orthographic projection matrix\n     * @param left - defines the viewport left coordinate\n     * @param right - defines the viewport right coordinate\n     * @param bottom - defines the viewport bottom coordinate\n     * @param top - defines the viewport top coordinate\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @returns a new matrix as a right-handed orthographic projection matrix\n     */\n    static OrthoOffCenterRH(left, right, bottom, top, znear, zfar) {\n        const matrix = new Matrix();\n        Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix);\n        return matrix;\n    }\n    /**\n     * Stores a right-handed orthographic projection into a given matrix\n     * @param left - defines the viewport left coordinate\n     * @param right - defines the viewport right coordinate\n     * @param bottom - defines the viewport bottom coordinate\n     * @param top - defines the viewport top coordinate\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @param result - defines the target matrix\n     */\n    static OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result) {\n        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result);\n        result._m[10] *= -1; // No need to call _markAsUpdated as previous function already called it and let _isIdentityDirty to true\n    }\n    /**\n     * Creates a left-handed perspective projection matrix\n     * @param width - defines the viewport width\n     * @param height - defines the viewport height\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @returns a new matrix as a left-handed perspective projection matrix\n     */\n    static PerspectiveLH(width, height, znear, zfar) {\n        const matrix = new Matrix();\n        const n = znear;\n        const f = zfar;\n        const a = (2.0 * n) / width;\n        const b = (2.0 * n) / height;\n        const c = (f + n) / (f - n);\n        const d = (-2.0 * f * n) / (f - n);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, matrix);\n        matrix._updateIdentityStatus(false);\n        return matrix;\n    }\n    /**\n     * Creates a left-handed perspective projection matrix\n     * @param fov - defines the horizontal field of view\n     * @param aspect - defines the aspect ratio\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @returns a new matrix as a left-handed perspective projection matrix\n     */\n    static PerspectiveFovLH(fov, aspect, znear, zfar) {\n        const matrix = new Matrix();\n        Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix);\n        return matrix;\n    }\n    /**\n     * Stores a left-handed perspective projection into a given matrix\n     * @param fov - defines the horizontal field of view\n     * @param aspect - defines the aspect ratio\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @param result - defines the target matrix\n     * @param isVerticalFovFixed - defines it the fov is vertically fixed (default) or horizontally\n     */\n    static PerspectiveFovLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true) {\n        const n = znear;\n        const f = zfar;\n        const t = 1.0 / Math.tan(fov * 0.5);\n        const a = isVerticalFovFixed ? t / aspect : t;\n        const b = isVerticalFovFixed ? t : t * aspect;\n        const c = (f + n) / (f - n);\n        const d = (-2.0 * f * n) / (f - n);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, 1.0, 0.0, 0.0, d, 0.0, result);\n        result._updateIdentityStatus(false);\n    }\n    /**\n     * Creates a right-handed perspective projection matrix\n     * @param fov - defines the horizontal field of view\n     * @param aspect - defines the aspect ratio\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @returns a new matrix as a right-handed perspective projection matrix\n     */\n    static PerspectiveFovRH(fov, aspect, znear, zfar) {\n        const matrix = new Matrix();\n        Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix);\n        return matrix;\n    }\n    /**\n     * Stores a right-handed perspective projection into a given matrix\n     * @param fov - defines the horizontal field of view\n     * @param aspect - defines the aspect ratio\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @param result - defines the target matrix\n     * @param isVerticalFovFixed - defines it the fov is vertically fixed (default) or horizontally\n     */\n    static PerspectiveFovRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true) {\n        /* alternatively this could be expressed as:\n        //    m = PerspectiveFovLHToRef\n        //    m[10] *= -1.0;\n        //    m[11] *= -1.0;\n        */\n        const n = znear;\n        const f = zfar;\n        const t = 1.0 / Math.tan(fov * 0.5);\n        const a = isVerticalFovFixed ? t / aspect : t;\n        const b = isVerticalFovFixed ? t : t * aspect;\n        const c = -(f + n) / (f - n);\n        const d = (-2 * f * n) / (f - n);\n        Matrix.FromValuesToRef(a, 0.0, 0.0, 0.0, 0.0, b, 0.0, 0.0, 0.0, 0.0, c, -1.0, 0.0, 0.0, d, 0.0, result);\n        result._updateIdentityStatus(false);\n    }\n    /**\n     * Stores a perspective projection for WebVR info a given matrix\n     * @param fov - defines the field of view\n     * @param znear - defines the near clip plane\n     * @param zfar - defines the far clip plane\n     * @param result - defines the target matrix\n     * @param rightHanded - defines if the matrix must be in right-handed mode (false by default)\n     */\n    static PerspectiveFovWebVRToRef(fov, znear, zfar, result, rightHanded = false) {\n        const rightHandedFactor = rightHanded ? -1 : 1;\n        const upTan = Math.tan((fov.upDegrees * Math.PI) / 180.0);\n        const downTan = Math.tan((fov.downDegrees * Math.PI) / 180.0);\n        const leftTan = Math.tan((fov.leftDegrees * Math.PI) / 180.0);\n        const rightTan = Math.tan((fov.rightDegrees * Math.PI) / 180.0);\n        const xScale = 2.0 / (leftTan + rightTan);\n        const yScale = 2.0 / (upTan + downTan);\n        const m = result._m;\n        m[0] = xScale;\n        m[1] = m[2] = m[3] = m[4] = 0.0;\n        m[5] = yScale;\n        m[6] = m[7] = 0.0;\n        m[8] = (leftTan - rightTan) * xScale * 0.5;\n        m[9] = -((upTan - downTan) * yScale * 0.5);\n        m[10] = -zfar / (znear - zfar);\n        m[11] = 1.0 * rightHandedFactor;\n        m[12] = m[13] = m[15] = 0.0;\n        m[14] = -(2.0 * zfar * znear) / (zfar - znear);\n        result._markAsUpdated();\n    }\n    /**\n     * Extracts a 2x2 matrix from a given matrix and store the result in a FloatArray\n     * @param matrix - defines the matrix to use\n     * @returns a new FloatArray array with 4 elements : the 2x2 matrix extracted from the given matrix\n     */\n    static GetAsMatrix2x2(matrix) {\n        return [matrix._m[0], matrix._m[1], matrix._m[4], matrix._m[5]];\n    }\n    /**\n     * Extracts a 3x3 matrix from a given matrix and store the result in a FloatArray\n     * @param matrix - defines the matrix to use\n     * @returns a new FloatArray array with 9 elements : the 3x3 matrix extracted from the given matrix\n     */\n    static GetAsMatrix3x3(matrix) {\n        return [\n            matrix._m[0],\n            matrix._m[1],\n            matrix._m[2],\n            matrix._m[4],\n            matrix._m[5],\n            matrix._m[6],\n            matrix._m[8],\n            matrix._m[9],\n            matrix._m[10]\n        ];\n    }\n    /**\n     * Compute the transpose of a given matrix\n     * @param matrix - defines the matrix to transpose\n     * @returns the new matrix\n     */\n    static Transpose(matrix) {\n        const result = new Matrix();\n        Matrix.TransposeToRef(matrix, result);\n        return result;\n    }\n    /**\n     * Compute the transpose of a matrix and store it in a target matrix\n     * @param matrix - defines the matrix to transpose\n     * @param result - defines the target matrix\n     */\n    static TransposeToRef(matrix, result) {\n        const rm = result._m;\n        const mm = matrix._m;\n        rm[0] = mm[0];\n        rm[1] = mm[4];\n        rm[2] = mm[8];\n        rm[3] = mm[12];\n        rm[4] = mm[1];\n        rm[5] = mm[5];\n        rm[6] = mm[9];\n        rm[7] = mm[13];\n        rm[8] = mm[2];\n        rm[9] = mm[6];\n        rm[10] = mm[10];\n        rm[11] = mm[14];\n        rm[12] = mm[3];\n        rm[13] = mm[7];\n        rm[14] = mm[11];\n        rm[15] = mm[15];\n        // identity-ness does not change when transposing\n        result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);\n    }\n    /**\n     * Computes a reflection matrix from a plane\n     * @param plane - defines the reflection plane\n     * @returns a new matrix\n     */\n    static Reflection(plane) {\n        const matrix = new Matrix();\n        Matrix.ReflectionToRef(plane, matrix);\n        return matrix;\n    }\n    /**\n     * Computes a reflection matrix from a plane\n     * @param plane - defines the reflection plane\n     * @param result - defines the target matrix\n     */\n    static ReflectionToRef(plane, result) {\n        plane.normalize();\n        const x = plane.normal.x;\n        const y = plane.normal.y;\n        const z = plane.normal.z;\n        const temp = -2 * x;\n        const temp2 = -2 * y;\n        const temp3 = -2 * z;\n        Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0.0, temp * y, temp2 * y + 1, temp3 * y, 0.0, temp * z, temp2 * z, temp3 * z + 1, 0.0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1.0, result);\n    }\n    /**\n     * Sets the given matrix as a rotation matrix composed from the 3 left handed axes\n     * @param xaxis - defines the value of the 1st axis\n     * @param yaxis - defines the value of the 2nd axis\n     * @param zaxis - defines the value of the 3rd axis\n     * @param result - defines the target matrix\n     */\n    static FromXYZAxesToRef(xaxis, yaxis, zaxis, result) {\n        Matrix.FromValuesToRef(xaxis.x, xaxis.y, xaxis.z, 0.0, yaxis.x, yaxis.y, yaxis.z, 0.0, zaxis.x, zaxis.y, zaxis.z, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n    }\n    /**\n     * Creates a rotation matrix from a quaternion and stores it in a target matrix\n     * @param quat - defines the quaternion to use\n     * @param result - defines the target matrix\n     */\n    static FromQuaternionToRef(quat, result) {\n        const xx = quat.x * quat.x;\n        const yy = quat.y * quat.y;\n        const zz = quat.z * quat.z;\n        const xy = quat.x * quat.y;\n        const zw = quat.z * quat.w;\n        const zx = quat.z * quat.x;\n        const yw = quat.y * quat.w;\n        const yz = quat.y * quat.z;\n        const xw = quat.x * quat.w;\n        result._m[0] = 1.0 - 2.0 * (yy + zz);\n        result._m[1] = 2.0 * (xy + zw);\n        result._m[2] = 2.0 * (zx - yw);\n        result._m[3] = 0.0;\n        result._m[4] = 2.0 * (xy - zw);\n        result._m[5] = 1.0 - 2.0 * (zz + xx);\n        result._m[6] = 2.0 * (yz + xw);\n        result._m[7] = 0.0;\n        result._m[8] = 2.0 * (zx + yw);\n        result._m[9] = 2.0 * (yz - xw);\n        result._m[10] = 1.0 - 2.0 * (yy + xx);\n        result._m[11] = 0.0;\n        result._m[12] = 0.0;\n        result._m[13] = 0.0;\n        result._m[14] = 0.0;\n        result._m[15] = 1.0;\n        result._markAsUpdated();\n    }\n    /** @internal */\n    _markAsUpdated() {\n        this.updateFlag = Matrix._updateFlagSeed++;\n        this._isIdentity = false;\n        this._isIdentity3x2 = false;\n        this._isIdentityDirty = true;\n        this._isIdentity3x2Dirty = true;\n    }\n    // Properties\n    /**\n     * Check if the current matrix is identity\n     * @returns true is the matrix is the identity matrix\n     */\n    isIdentity() {\n        if (this._isIdentityDirty) {\n            this._isIdentityDirty = false;\n            const m = this._m;\n            this._isIdentity =\n                m[0] === 1.0 &&\n                    m[1] === 0.0 &&\n                    m[2] === 0.0 &&\n                    m[3] === 0.0 &&\n                    m[4] === 0.0 &&\n                    m[5] === 1.0 &&\n                    m[6] === 0.0 &&\n                    m[7] === 0.0 &&\n                    m[8] === 0.0 &&\n                    m[9] === 0.0 &&\n                    m[10] === 1.0 &&\n                    m[11] === 0.0 &&\n                    m[12] === 0.0 &&\n                    m[13] === 0.0 &&\n                    m[14] === 0.0 &&\n                    m[15] === 1.0;\n        }\n        return this._isIdentity;\n    }\n    /**\n     * Check if the current matrix is identity as a texture matrix (3x2 store in 4x4)\n     * @returns true is the matrix is the identity matrix\n     */\n    isIdentityAs3x2() {\n        if (this._isIdentity3x2Dirty) {\n            this._isIdentity3x2Dirty = false;\n            if (this._m[0] !== 1.0 || this._m[5] !== 1.0 || this._m[15] !== 1.0) {\n                this._isIdentity3x2 = false;\n            }\n            else if (this._m[1] !== 0.0 ||\n                this._m[2] !== 0.0 ||\n                this._m[3] !== 0.0 ||\n                this._m[4] !== 0.0 ||\n                this._m[6] !== 0.0 ||\n                this._m[7] !== 0.0 ||\n                this._m[8] !== 0.0 ||\n                this._m[9] !== 0.0 ||\n                this._m[10] !== 0.0 ||\n                this._m[11] !== 0.0 ||\n                this._m[12] !== 0.0 ||\n                this._m[13] !== 0.0 ||\n                this._m[14] !== 0.0) {\n                this._isIdentity3x2 = false;\n            }\n            else {\n                this._isIdentity3x2 = true;\n            }\n        }\n        return this._isIdentity3x2;\n    }\n    /**\n     * Gets the determinant of the matrix\n     * @returns the matrix determinant\n     */\n    determinant() {\n        if (this._isIdentity === true) {\n            return 1;\n        }\n        const m = this._m;\n        // tslint:disable-next-line:one-variable-per-declaration\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n        // tslint:disable-next-line:one-variable-per-declaration\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n        // tslint:disable-next-line:one-variable-per-declaration\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n        // tslint:disable-next-line:one-variable-per-declaration\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n        /*\n        // https://en.wikipedia.org/wiki/Laplace_expansion\n        // to compute the deterrminant of a 4x4 Matrix we compute the cofactors of any row or column,\n        // then we multiply each Cofactor by its corresponding matrix value and sum them all to get the determinant\n        // Cofactor(i, j) = sign(i,j) * det(Minor(i, j))\n        // where\n        //  - sign(i,j) = (i+j) % 2 === 0 ? 1 : -1\n        //  - Minor(i, j) is the 3x3 matrix we get by removing row i and column j from current Matrix\n        //\n        // Here we do that for the 1st row.\n        */\n        // tslint:disable:variable-name\n        const det_22_33 = m22 * m33 - m32 * m23;\n        const det_21_33 = m21 * m33 - m31 * m23;\n        const det_21_32 = m21 * m32 - m31 * m22;\n        const det_20_33 = m20 * m33 - m30 * m23;\n        const det_20_32 = m20 * m32 - m22 * m30;\n        const det_20_31 = m20 * m31 - m30 * m21;\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n        // tslint:enable:variable-name\n        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n    }\n    // Methods\n    /**\n     * Returns the matrix as a FloatArray\n     * @returns the matrix underlying array\n     */\n    toArray() {\n        return this._m;\n    }\n    /**\n     * Returns the matrix as a FloatArray\n     * @returns the matrix underlying array.\n     */\n    asArray() {\n        return this._m;\n    }\n    /**\n     * Inverts the current matrix in place\n     * @returns the current inverted matrix\n     */\n    invert() {\n        this.invertToRef(this);\n        return this;\n    }\n    /**\n     * Sets all the matrix elements to zero\n     * @returns the current matrix\n     */\n    reset() {\n        Matrix.FromValuesToRef(0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, this);\n        this._updateIdentityStatus(false);\n        return this;\n    }\n    /**\n     * Adds the current matrix with a second one\n     * @param other - defines the matrix to add\n     * @returns a new matrix as the addition of the current matrix and the given one\n     */\n    add(other) {\n        const result = new Matrix();\n        this.addToRef(other, result);\n        return result;\n    }\n    /**\n     * Sets the given matrix \"result\" to the addition of the current matrix and the given one\n     * @param other - defines the matrix to add\n     * @param result - defines the target matrix\n     * @returns the current matrix\n     */\n    addToRef(other, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] = this._m[index] + other._m[index];\n        }\n        result._markAsUpdated();\n        return this;\n    }\n    /**\n     * Adds in place the given matrix to the current matrix\n     * @param other - defines the second operand\n     * @returns the current updated matrix\n     */\n    addToSelf(other) {\n        for (let index = 0; index < 16; index++) {\n            this._m[index] += other._m[index];\n        }\n        this._markAsUpdated();\n        return this;\n    }\n    /**\n     * Sets the given matrix to the current inverted Matrix\n     * @param other - defines the target matrix\n     * @returns the unmodified current matrix\n     */\n    invertToRef(other) {\n        if (this._isIdentity === true) {\n            Matrix.IdentityToRef(other);\n            return this;\n        }\n        // the inverse of a Matrix is the transpose of cofactor matrix divided by the determinant\n        const m = this._m;\n        // tslint:disable:one-variable-per-declaration\n        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];\n        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];\n        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];\n        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];\n        // tslint:enable:one-variable-per-declaration\n        // tslint:disable:variable-name\n        const det_22_33 = m22 * m33 - m32 * m23;\n        const det_21_33 = m21 * m33 - m31 * m23;\n        const det_21_32 = m21 * m32 - m31 * m22;\n        const det_20_33 = m20 * m33 - m30 * m23;\n        const det_20_32 = m20 * m32 - m22 * m30;\n        const det_20_31 = m20 * m31 - m30 * m21;\n        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);\n        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);\n        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);\n        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);\n        const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;\n        if (det === 0) {\n            // not invertible\n            other.copyFrom(this);\n            return this;\n        }\n        const detInv = 1 / det;\n        const det_12_33 = m12 * m33 - m32 * m13;\n        const det_11_33 = m11 * m33 - m31 * m13;\n        const det_11_32 = m11 * m32 - m31 * m12;\n        const det_10_33 = m10 * m33 - m30 * m13;\n        const det_10_32 = m10 * m32 - m30 * m12;\n        const det_10_31 = m10 * m31 - m30 * m11;\n        const det_12_23 = m12 * m23 - m22 * m13;\n        const det_11_23 = m11 * m23 - m21 * m13;\n        const det_11_22 = m11 * m22 - m21 * m12;\n        const det_10_23 = m10 * m23 - m20 * m13;\n        const det_10_22 = m10 * m22 - m20 * m12;\n        const det_10_21 = m10 * m21 - m20 * m11;\n        const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);\n        const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);\n        const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);\n        const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);\n        const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);\n        const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);\n        const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);\n        const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);\n        const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);\n        const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);\n        const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);\n        const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);\n        Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);\n        // tslint:enable:variable-name\n        return this;\n    }\n    /**\n     * add a value at the specified position in the current Matrix\n     * @param index - the index of the value within the matrix. between 0 and 15.\n     * @param value - the value to be added\n     * @returns the current updated matrix\n     */\n    addAtIndex(index, value) {\n        this._m[index] += value;\n        this._markAsUpdated();\n        return this;\n    }\n    /**\n     * mutiply the specified position in the current Matrix by a value\n     * @param index - the index of the value within the matrix. between 0 and 15.\n     * @param value - the value to be added\n     * @returns the current updated matrix\n     */\n    multiplyAtIndex(index, value) {\n        this._m[index] *= value;\n        this._markAsUpdated();\n        return this;\n    }\n    /**\n     * Inserts the translation vector (using 3 floats) in the current matrix\n     * @param x - defines the 1st component of the translation\n     * @param y - defines the 2nd component of the translation\n     * @param z - defines the 3rd component of the translation\n     * @returns the current updated matrix\n     */\n    setTranslationFromFloats(x, y, z) {\n        this._m[12] = x;\n        this._m[13] = y;\n        this._m[14] = z;\n        this._markAsUpdated();\n        return this;\n    }\n    /**\n     * Inserts the translation vector in the current matrix\n     * @param vector3 - defines the translation to insert\n     * @returns the current updated matrix\n     */\n    setTranslation(vector3) {\n        return this.setTranslationFromFloats(vector3.x, vector3.y, vector3.z);\n    }\n    /**\n     * Gets the translation value of the current matrix\n     * @returns a new Vector3 as the extracted translation from the matrix\n     */\n    getTranslation() {\n        return new Vector3_1.Vector3(this._m[12], this._m[13], this._m[14]);\n    }\n    /**\n     * Fill a Vector3 with the extracted translation from the matrix\n     * @param result - defines the Vector3 where to store the translation\n     * @returns the current matrix\n     */\n    getTranslationToRef(result) {\n        result.x = this._m[12];\n        result.y = this._m[13];\n        result.z = this._m[14];\n        return this;\n    }\n    /**\n     * Remove rotation and scaling part from the matrix\n     * @returns the updated matrix\n     */\n    removeRotationAndScaling() {\n        const m = this.m;\n        Matrix.FromValuesToRef(1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 0.0, m[12], m[13], m[14], m[15], this);\n        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);\n        return this;\n    }\n    /**\n     * Multiply two matrices\n     * @param other - defines the second operand\n     * @returns a new matrix set with the multiplication result of the current Matrix and the given one\n     */\n    multiply(other) {\n        const result = new Matrix();\n        this.multiplyToRef(other, result);\n        return result;\n    }\n    /**\n     * Copy the current matrix from the given one\n     * @param other - defines the source matrix\n     * @returns the current updated matrix\n     */\n    copyFrom(other) {\n        other.copyToArray(this._m);\n        const o = other;\n        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);\n        return this;\n    }\n    /**\n     * Populates the given array from the starting index with the current matrix values\n     * @param array - defines the target array\n     * @param offset - defines the offset in the target array where to start storing values\n     * @returns the current matrix\n     */\n    copyToArray(array, offset = 0) {\n        for (let index = 0; index < 16; index++) {\n            array[offset + index] = this._m[index];\n        }\n        return this;\n    }\n    /**\n     * Sets the given matrix \"result\" with the multiplication result of the current Matrix and the given one\n     * @param other - defines the second operand\n     * @param result - defines the matrix where to store the multiplication\n     * @returns the current matrix\n     */\n    multiplyToRef(other, result) {\n        if (this._isIdentity) {\n            result.copyFrom(other);\n            return this;\n        }\n        if (other._isIdentity) {\n            result.copyFrom(this);\n            return this;\n        }\n        this.multiplyToArray(other, result._m, 0);\n        result._markAsUpdated();\n        return this;\n    }\n    /**\n     * Sets the FloatArray \"result\" from the given index \"offset\" with the multiplication of the current matrix and the given one\n     * @param other - defines the second operand\n     * @param result - defines the array where to store the multiplication\n     * @param offset - defines the offset in the target array where to start storing values\n     * @returns the current matrix\n     */\n    multiplyToArray(other, result, offset) {\n        const m = this._m;\n        const otherM = other.m;\n        // tslint:disable:one-variable-per-declaration\n        const tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];\n        const tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];\n        const tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];\n        const tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];\n        const om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];\n        const om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];\n        const om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];\n        const om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];\n        // tslint:enable:one-variable-per-declaration\n        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;\n        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;\n        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;\n        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;\n        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;\n        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;\n        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;\n        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;\n        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;\n        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;\n        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;\n        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;\n        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;\n        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;\n        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;\n        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;\n        return this;\n    }\n    /**\n     * Check equality between this matrix and a second one\n     * @param value - defines the second matrix to compare\n     * @returns true is the current matrix and the given one values are strictly equal\n     */\n    equals(value) {\n        const other = value;\n        if (!other) {\n            return false;\n        }\n        if (this._isIdentity || other._isIdentity) {\n            if (!this._isIdentityDirty && !other._isIdentityDirty) {\n                return this._isIdentity && other._isIdentity;\n            }\n        }\n        const m = this.m;\n        const om = other.m;\n        return (m[0] === om[0] &&\n            m[1] === om[1] &&\n            m[2] === om[2] &&\n            m[3] === om[3] &&\n            m[4] === om[4] &&\n            m[5] === om[5] &&\n            m[6] === om[6] &&\n            m[7] === om[7] &&\n            m[8] === om[8] &&\n            m[9] === om[9] &&\n            m[10] === om[10] &&\n            m[11] === om[11] &&\n            m[12] === om[12] &&\n            m[13] === om[13] &&\n            m[14] === om[14] &&\n            m[15] === om[15]);\n    }\n    /**\n     * Clone the current matrix\n     * @returns a new matrix from the current matrix\n     */\n    clone() {\n        const matrix = new Matrix();\n        matrix.copyFrom(this);\n        return matrix;\n    }\n    /**\n     * Returns the name of the current matrix class\n     * @returns the string \"Matrix\"\n     */\n    getClassName() {\n        return 'Matrix';\n    }\n    /**\n     * Gets the hash code of the current matrix\n     * @returns the hash code\n     */\n    getHashCode() {\n        let hash = this._m[0] || 0;\n        for (let i = 1; i < 16; i++) {\n            hash = (hash * 397) ^ (this._m[i] || 0);\n        }\n        return hash;\n    }\n    /**\n     * Decomposes the current Matrix into a translation, rotation and scaling components\n     * @param scale - defines the scale vector3 given as a reference to update\n     * @param rotation - defines the rotation quaternion given as a reference to update\n     * @param translation - defines the translation vector3 given as a reference to update\n     * @returns true if operation was successful\n     */\n    decompose(scale, rotation, translation) {\n        if (this._isIdentity) {\n            if (translation) {\n                translation.setAll(0);\n            }\n            if (scale) {\n                scale.setAll(1);\n            }\n            if (rotation) {\n                rotation.copyFromFloats(0, 0, 0, 1);\n            }\n            return true;\n        }\n        const m = this._m;\n        if (translation) {\n            translation.copyFromFloats(m[12], m[13], m[14]);\n        }\n        const usedScale = scale || preallocatedVariables_1.MathTmp.Vector3[0];\n        usedScale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);\n        usedScale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);\n        usedScale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);\n        if (this.determinant() <= 0) {\n            usedScale.y *= -1;\n        }\n        if (usedScale.x === 0 || usedScale.y === 0 || usedScale.z === 0) {\n            if (rotation) {\n                rotation.copyFromFloats(0.0, 0.0, 0.0, 1.0);\n            }\n            return false;\n        }\n        if (rotation) {\n            // tslint:disable-next-line:one-variable-per-declaration\n            const sx = 1 / usedScale.x, sy = 1 / usedScale.y, sz = 1 / usedScale.z;\n            Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, preallocatedVariables_1.MathTmp.Matrix[0]);\n            Quaternion_1.Quaternion.FromRotationMatrixToRef(preallocatedVariables_1.MathTmp.Matrix[0], rotation);\n        }\n        return true;\n    }\n    /**\n     * Gets specific row of the matrix\n     * @param index - defines the number of the row to get\n     * @returns the index-th row of the current matrix as a new Vector4\n     */\n    getRow(index) {\n        if (index < 0 || index > 3) {\n            return null;\n        }\n        const i = index * 4;\n        return new Vector4_1.Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);\n    }\n    /**\n     * Sets the index-th row of the current matrix to the vector4 values\n     * @param index - defines the number of the row to set\n     * @param row - defines the target vector4\n     * @returns the updated current matrix\n     */\n    setRow(index, row) {\n        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);\n    }\n    /**\n     * Compute the transpose of the matrix\n     * @returns the new transposed matrix\n     */\n    transpose() {\n        return Matrix.Transpose(this);\n    }\n    /**\n     * Compute the transpose of the matrix and store it in a given matrix\n     * @param result - defines the target matrix\n     * @returns the current matrix\n     */\n    transposeToRef(result) {\n        Matrix.TransposeToRef(this, result);\n        return this;\n    }\n    /**\n     * Sets the index-th row of the current matrix with the given 4 x float values\n     * @param index - defines the row index\n     * @param x - defines the x component to set\n     * @param y - defines the y component to set\n     * @param z - defines the z component to set\n     * @param w - defines the w component to set\n     * @returns the updated current matrix\n     */\n    setRowFromFloats(index, x, y, z, w) {\n        if (index < 0 || index > 3) {\n            return this;\n        }\n        const i = index * 4;\n        this._m[i + 0] = x;\n        this._m[i + 1] = y;\n        this._m[i + 2] = z;\n        this._m[i + 3] = w;\n        this._markAsUpdated();\n        return this;\n    }\n    /**\n     * Compute a new matrix set with the current matrix values multiplied by scale (float)\n     * @param scale - defines the scale factor\n     * @returns a new matrix\n     */\n    scale(scale) {\n        const result = new Matrix();\n        this.scaleToRef(scale, result);\n        return result;\n    }\n    /**\n     * Scale the current matrix values by a factor to a given result matrix\n     * @param scale - defines the scale factor\n     * @param result - defines the matrix to store the result\n     * @returns the current matrix\n     */\n    scaleToRef(scale, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] = this._m[index] * scale;\n        }\n        result._markAsUpdated();\n        return this;\n    }\n    /**\n     * Scale the current matrix values by a factor and add the result to a given matrix\n     * @param scale - defines the scale factor\n     * @param result - defines the Matrix to store the result\n     * @returns the current matrix\n     */\n    scaleAndAddToRef(scale, result) {\n        for (let index = 0; index < 16; index++) {\n            result._m[index] += this._m[index] * scale;\n        }\n        result._markAsUpdated();\n        return this;\n    }\n    /**\n     * Writes to the given matrix a normal matrix, computed from this one (using values from identity matrix for fourth row and column).\n     * @param ref - matrix to store the result\n     */\n    toNormalMatrix(ref) {\n        const tmp = preallocatedVariables_1.MathTmp.Matrix[0];\n        this.invertToRef(tmp);\n        tmp.transposeToRef(ref);\n        const m = ref._m;\n        Matrix.FromValuesToRef(m[0], m[1], m[2], 0.0, m[4], m[5], m[6], 0.0, m[8], m[9], m[10], 0.0, 0.0, 0.0, 0.0, 1.0, ref);\n    }\n    /**\n     * Gets only rotation part of the current matrix\n     * @returns a new matrix sets to the extracted rotation matrix from the current one\n     */\n    getRotationMatrix() {\n        const result = new Matrix();\n        this.getRotationMatrixToRef(result);\n        return result;\n    }\n    /**\n     * Extracts the rotation matrix from the current one and sets it as the given \"result\"\n     * @param result - defines the target matrix to store data to\n     * @returns the current matrix\n     */\n    getRotationMatrixToRef(result) {\n        const scale = preallocatedVariables_1.MathTmp.Vector3[0];\n        if (!this.decompose(scale)) {\n            Matrix.IdentityToRef(result);\n            return this;\n        }\n        const m = this._m;\n        // tslint:disable-next-line:one-variable-per-declaration\n        const sx = 1 / scale.x, sy = 1 / scale.y, sz = 1 / scale.z;\n        Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0.0, m[4] * sy, m[5] * sy, m[6] * sy, 0.0, m[8] * sz, m[9] * sz, m[10] * sz, 0.0, 0.0, 0.0, 0.0, 1.0, result);\n        return this;\n    }\n    /**\n     * Toggles model matrix from being right handed to left handed in place and vice versa\n     */\n    toggleModelMatrixHandInPlace() {\n        const m = this._m;\n        m[2] *= -1;\n        m[6] *= -1;\n        m[8] *= -1;\n        m[9] *= -1;\n        m[14] *= -1;\n        this._markAsUpdated();\n    }\n    /**\n     * Toggles projection matrix from being right handed to left handed in place and vice versa\n     */\n    toggleProjectionMatrixHandInPlace() {\n        const m = this._m;\n        m[8] *= -1;\n        m[9] *= -1;\n        m[10] *= -1;\n        m[11] *= -1;\n        this._markAsUpdated();\n    }\n    /** @internal */\n    _updateIdentityStatus(isIdentity, isIdentityDirty = false, isIdentity3x2 = false, isIdentity3x2Dirty = true) {\n        this.updateFlag = Matrix._updateFlagSeed++;\n        this._isIdentity = isIdentity;\n        this._isIdentity3x2 = isIdentity || isIdentity3x2;\n        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;\n        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;\n    }\n}\nexports.Matrix = Matrix;\nMatrix._updateFlagSeed = 0;\nMatrix._identityReadOnly = Matrix.Identity();\n//# sourceMappingURL=Matrix.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Matrix.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Path2d.js":
/*!***************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Path2d.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Path2 = void 0;\nconst Vector2_1 = __webpack_require__(/*! ./Vector2 */ \"./node_modules/@dcl/ecs-math/dist/Vector2.js\");\nconst Arc2_1 = __webpack_require__(/*! ./Arc2 */ \"./node_modules/@dcl/ecs-math/dist/Arc2.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\n/**\n * Represents a 2D path made up of multiple 2D points\n * @public\n */\nclass Path2 {\n    /**\n     * Creates a Path2 object from the starting 2D coordinates x and y.\n     * @param x - the starting points x value\n     * @param y - the starting points y value\n     */\n    constructor(x, y) {\n        /**\n         * If the path start and end point are the same\n         */\n        this.closed = false;\n        this._points = new Array();\n        this._length = 0.0;\n        this._points.push(new Vector2_1.Vector2(x, y));\n    }\n    /**\n     * Creates a new path starting from an x and y position\n     * @param x - starting x value\n     * @param y - starting y value\n     * @returns a new Path2 starting at the coordinates (x, y).\n     */\n    static StartingAt(x, y) {\n        return new Path2(x, y);\n    }\n    /**\n     * Adds a new segment until the given coordinates (x, y) to the current Path2.\n     * @param x - the added points x value\n     * @param y - the added points y value\n     * @returns the updated Path2.\n     */\n    addLineTo(x, y) {\n        if (this.closed) {\n            return this;\n        }\n        const newPoint = new Vector2_1.Vector2(x, y);\n        const previousPoint = this._points[this._points.length - 1];\n        this._points.push(newPoint);\n        this._length += newPoint.subtract(previousPoint).length();\n        return this;\n    }\n    /**\n     * Adds _numberOfSegments_ segments according to the arc definition (middle point coordinates, end point coordinates, the arc start point being the current Path2 last point) to the current Path2.\n     * @param midX - middle point x value\n     * @param midY - middle point y value\n     * @param endX - end point x value\n     * @param endY - end point y value\n     * @param numberOfSegments - (default: 36)\n     * @returns the updated Path2.\n     */\n    addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {\n        if (this.closed) {\n            return this;\n        }\n        const startPoint = this._points[this._points.length - 1];\n        const midPoint = new Vector2_1.Vector2(midX, midY);\n        const endPoint = new Vector2_1.Vector2(endX, endY);\n        const arc = new Arc2_1.Arc2(startPoint, midPoint, endPoint);\n        let increment = arc.angle.radians() / numberOfSegments;\n        if (arc.orientation === types_1.Orientation.CW) {\n            increment *= -1;\n        }\n        let currentAngle = arc.startAngle.radians() + increment;\n        for (let i = 0; i < numberOfSegments; i++) {\n            const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;\n            const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;\n            this.addLineTo(x, y);\n            currentAngle += increment;\n        }\n        return this;\n    }\n    /**\n     * Closes the Path2.\n     * @returns the Path2.\n     */\n    close() {\n        this.closed = true;\n        return this;\n    }\n    /**\n     * Gets the sum of the distance between each sequential point in the path\n     * @returns the Path2 total length (float).\n     */\n    length() {\n        let result = this._length;\n        if (!this.closed) {\n            const lastPoint = this._points[this._points.length - 1];\n            const firstPoint = this._points[0];\n            result += firstPoint.subtract(lastPoint).length();\n        }\n        return result;\n    }\n    /**\n     * Gets the points which construct the path\n     * @returns the Path2 internal array of points.\n     */\n    getPoints() {\n        return this._points;\n    }\n    /**\n     * Retreives the point at the distance aways from the starting point\n     * @param normalizedLengthPosition - the length along the path to retreive the point from\n     * @returns a new Vector2 located at a percentage of the Path2 total length on this path.\n     */\n    getPointAtLengthPosition(normalizedLengthPosition) {\n        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {\n            return Vector2_1.Vector2.Zero();\n        }\n        const lengthPosition = normalizedLengthPosition * this.length();\n        let previousOffset = 0;\n        for (let i = 0; i < this._points.length; i++) {\n            const j = (i + 1) % this._points.length;\n            const a = this._points[i];\n            const b = this._points[j];\n            const bToA = b.subtract(a);\n            const nextOffset = bToA.length() + previousOffset;\n            if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {\n                const dir = bToA.normalize();\n                const localOffset = lengthPosition - previousOffset;\n                return new Vector2_1.Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);\n            }\n            previousOffset = nextOffset;\n        }\n        return Vector2_1.Vector2.Zero();\n    }\n}\nexports.Path2 = Path2;\n//# sourceMappingURL=Path2d.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Path2d.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Path3d.js":
/*!***************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Path3d.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Path3D = void 0;\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\nconst Scalar_1 = __webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\");\n/**\n * Represents a 3D path made up of multiple 3D points\n * @public\n */\nclass Path3D {\n    /**\n     * new Path3D(path, normal, raw)\n     * Creates a Path3D. A Path3D is a logical math object, so not a mesh.\n     * please read the description in the tutorial :  http://doc.babylonjs.com/tutorials/How_to_use_Path3D\n     * @param path - an array of Vector3, the curve axis of the Path3D\n     * @param normal - (options) Vector3, the first wanted normal to the curve. Ex (0, 1, 0) for a vertical normal.\n     * @param raw - (optional, default false) : boolean, if true the returned Path3D isn't normalized. Useful to depict path acceleration or speed.\n     */\n    constructor(\n    /**\n     * an array of Vector3, the curve axis of the Path3D\n     */\n    path, firstNormal = null, raw) {\n        this.path = path;\n        this._curve = new Array();\n        this._distances = new Array();\n        this._tangents = new Array();\n        this._normals = new Array();\n        this._binormals = new Array();\n        for (let p = 0; p < path.length; p++) {\n            this._curve[p] = path[p].clone(); // hard copy\n        }\n        this._raw = raw || false;\n        this._compute(firstNormal);\n    }\n    /**\n     * Returns the Path3D array of successive Vector3 designing its curve.\n     * @returns the Path3D array of successive Vector3 designing its curve.\n     */\n    getCurve() {\n        return this._curve;\n    }\n    /**\n     * Returns an array populated with tangent vectors on each Path3D curve point.\n     * @returns an array populated with tangent vectors on each Path3D curve point.\n     */\n    getTangents() {\n        return this._tangents;\n    }\n    /**\n     * Returns an array populated with normal vectors on each Path3D curve point.\n     * @returns an array populated with normal vectors on each Path3D curve point.\n     */\n    getNormals() {\n        return this._normals;\n    }\n    /**\n     * Returns an array populated with binormal vectors on each Path3D curve point.\n     * @returns an array populated with binormal vectors on each Path3D curve point.\n     */\n    getBinormals() {\n        return this._binormals;\n    }\n    /**\n     * Returns an array populated with distances (float) of the i-th point from the first curve point.\n     * @returns an array populated with distances (float) of the i-th point from the first curve point.\n     */\n    getDistances() {\n        return this._distances;\n    }\n    /**\n     * Forces the Path3D tangent, normal, binormal and distance recomputation.\n     * @param path - path which all values are copied into the curves points\n     * @param firstNormal - which should be projected onto the curve\n     * @returns the same object updated.\n     */\n    update(path, firstNormal = null) {\n        for (let p = 0; p < path.length; p++) {\n            this._curve[p].x = path[p].x;\n            this._curve[p].y = path[p].y;\n            this._curve[p].z = path[p].z;\n        }\n        this._compute(firstNormal);\n        return this;\n    }\n    // private function compute() : computes tangents, normals and binormals\n    _compute(firstNormal) {\n        const l = this._curve.length;\n        // first and last tangents\n        this._tangents[0] = this._getFirstNonNullVector(0);\n        if (!this._raw) {\n            this._tangents[0].normalize();\n        }\n        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);\n        if (!this._raw) {\n            this._tangents[l - 1].normalize();\n        }\n        // normals and binormals at first point : arbitrary vector with _normalVector()\n        const tg0 = this._tangents[0];\n        const pp0 = this._normalVector(this._curve[0], tg0, firstNormal);\n        this._normals[0] = pp0;\n        if (!this._raw) {\n            this._normals[0].normalize();\n        }\n        this._binormals[0] = Vector3_1.Vector3.Cross(tg0, this._normals[0]);\n        if (!this._raw) {\n            this._binormals[0].normalize();\n        }\n        this._distances[0] = 0.0;\n        // normals and binormals : next points\n        let prev; // previous vector (segment)\n        let cur; // current vector (segment)\n        let curTang; // current tangent\n        // previous normal\n        let prevBinor; // previous binormal\n        for (let i = 1; i < l; i++) {\n            // tangents\n            prev = this._getLastNonNullVector(i);\n            if (i < l - 1) {\n                cur = this._getFirstNonNullVector(i);\n                this._tangents[i] = prev.add(cur);\n                this._tangents[i].normalize();\n            }\n            this._distances[i] = this._distances[i - 1] + prev.length();\n            // normals and binormals\n            // http://www.cs.cmu.edu/afs/andrew/scs/cs/15-462/web/old/asst2camera.html\n            curTang = this._tangents[i];\n            prevBinor = this._binormals[i - 1];\n            this._normals[i] = Vector3_1.Vector3.Cross(prevBinor, curTang);\n            if (!this._raw) {\n                this._normals[i].normalize();\n            }\n            this._binormals[i] = Vector3_1.Vector3.Cross(curTang, this._normals[i]);\n            if (!this._raw) {\n                this._binormals[i].normalize();\n            }\n        }\n    }\n    // returns the first non null vector from index : curve[index + N].subtract(curve[index])\n    _getFirstNonNullVector(index) {\n        let i = 1;\n        let nNVector = this._curve[index + i].subtract(this._curve[index]);\n        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {\n            i++;\n            nNVector = this._curve[index + i].subtract(this._curve[index]);\n        }\n        return nNVector;\n    }\n    // returns the last non null vector from index : curve[index].subtract(curve[index - N])\n    _getLastNonNullVector(index) {\n        let i = 1;\n        let nLVector = this._curve[index].subtract(this._curve[index - i]);\n        while (nLVector.length() === 0 && index > i + 1) {\n            i++;\n            nLVector = this._curve[index].subtract(this._curve[index - i]);\n        }\n        return nLVector;\n    }\n    // private function normalVector(v0, vt, va) :\n    // returns an arbitrary point in the plane defined by the point v0 and the vector vt orthogonal to this plane\n    // if va is passed, it returns the va projection on the plane orthogonal to vt at the point v0\n    _normalVector(v0, vt, va) {\n        let normal0;\n        let tgl = vt.length();\n        if (tgl === 0.0) {\n            tgl = 1.0;\n        }\n        if (va === undefined || va === null) {\n            let point;\n            if (!Scalar_1.Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1.0, types_1.Epsilon)) {\n                // search for a point in the plane\n                point = new Vector3_1.Vector3(0.0, -1.0, 0.0);\n            }\n            else if (!Scalar_1.Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1.0, types_1.Epsilon)) {\n                point = new Vector3_1.Vector3(1.0, 0.0, 0.0);\n            }\n            else if (!Scalar_1.Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1.0, types_1.Epsilon)) {\n                point = new Vector3_1.Vector3(0.0, 0.0, 1.0);\n            }\n            else {\n                point = Vector3_1.Vector3.Zero();\n            }\n            normal0 = Vector3_1.Vector3.Cross(vt, point);\n        }\n        else {\n            normal0 = Vector3_1.Vector3.Cross(vt, va);\n            Vector3_1.Vector3.CrossToRef(normal0, vt, normal0);\n        }\n        normal0.normalize();\n        return normal0;\n    }\n}\nexports.Path3D = Path3D;\n//# sourceMappingURL=Path3d.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Path3d.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Plane.js":
/*!**************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Plane.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Plane = void 0;\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\nconst Matrix_1 = __webpack_require__(/*! ./Matrix */ \"./node_modules/@dcl/ecs-math/dist/Matrix.js\");\nconst preallocatedVariables_1 = __webpack_require__(/*! ./preallocatedVariables */ \"./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js\");\n/**\n * Represens a plane by the equation ax + by + cz + d = 0\n * @public\n */\nclass Plane {\n    /**\n     * Creates a Plane object according to the given floats a, b, c, d and the plane equation : ax + by + cz + d = 0\n     * @param a - a component of the plane\n     * @param b - b component of the plane\n     * @param c - c component of the plane\n     * @param d - d component of the plane\n     */\n    constructor(a, b, c, d) {\n        this.normal = new Vector3_1.Vector3(a, b, c);\n        this.d = d;\n    }\n    // Statics\n    /**\n     * Creates a plane from an  array\n     * @param array - the array to create a plane from\n     * @returns a new Plane from the given array.\n     */\n    static FromArray(array) {\n        return new Plane(array[0], array[1], array[2], array[3]);\n    }\n    /**\n     * Creates a plane from three points\n     * @param point1 - point used to create the plane\n     * @param point2 - point used to create the plane\n     * @param point3 - point used to create the plane\n     * @returns a new Plane defined by the three given points.\n     */\n    static FromPoints(point1, point2, point3) {\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\n        result.copyFromPoints(point1, point2, point3);\n        return result;\n    }\n    /**\n     * Creates a plane from an origin point and a normal\n     * @param origin - origin of the plane to be constructed\n     * @param normal - normal of the plane to be constructed\n     * @returns a new Plane the normal vector to this plane at the given origin point.\n     * Note : the vector \"normal\" is updated because normalized.\n     */\n    static FromPositionAndNormal(origin, normal) {\n        const result = new Plane(0.0, 0.0, 0.0, 0.0);\n        normal.normalize();\n        result.normal = normal;\n        result.d = -(normal.x * origin.x +\n            normal.y * origin.y +\n            normal.z * origin.z);\n        return result;\n    }\n    /**\n     * Calculates the distance from a plane and a point\n     * @param origin - origin of the plane to be constructed\n     * @param normal - normal of the plane to be constructed\n     * @param point - point to calculate distance to\n     * @returns the signed distance between the plane defined by the normal vector at the \"origin\"\" point and the given other point.\n     */\n    static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {\n        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);\n        return Vector3_1.Vector3.Dot(point, normal) + d;\n    }\n    /**\n     * @returns the plane coordinates as a new array of 4 elements [a, b, c, d].\n     */\n    asArray() {\n        return [this.normal.x, this.normal.y, this.normal.z, this.d];\n    }\n    // Methods\n    /**\n     * @returns a new plane copied from the current Plane.\n     */\n    clone() {\n        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);\n    }\n    /**\n     * @returns the string \"Plane\".\n     */\n    getClassName() {\n        return 'Plane';\n    }\n    /**\n     * @returns the Plane hash code.\n     */\n    getHashCode() {\n        let hash = this.normal.getHashCode();\n        hash = (hash * 397) ^ (this.d || 0);\n        return hash;\n    }\n    /**\n     * Normalize the current Plane in place.\n     * @returns the updated Plane.\n     */\n    normalize() {\n        const norm = Math.sqrt(this.normal.x * this.normal.x +\n            this.normal.y * this.normal.y +\n            this.normal.z * this.normal.z);\n        let magnitude = 0.0;\n        if (norm !== 0) {\n            magnitude = 1.0 / norm;\n        }\n        this.normal.x *= magnitude;\n        this.normal.y *= magnitude;\n        this.normal.z *= magnitude;\n        this.d *= magnitude;\n        return this;\n    }\n    /**\n     * Applies a transformation the plane and returns the result\n     * @param transformation - the transformation matrix to be applied to the plane\n     * @returns a new Plane as the result of the transformation of the current Plane by the given matrix.\n     */\n    transform(transformation) {\n        const transposedMatrix = preallocatedVariables_1.MathTmp.Matrix[0];\n        Matrix_1.Matrix.TransposeToRef(transformation, transposedMatrix);\n        const m = transposedMatrix.m;\n        const x = this.normal.x;\n        const y = this.normal.y;\n        const z = this.normal.z;\n        const d = this.d;\n        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];\n        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];\n        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];\n        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];\n        return new Plane(normalX, normalY, normalZ, finalD);\n    }\n    /**\n     * Calcualtte the dot product between the point and the plane normal\n     * @param point - point to calculate the dot product with\n     * @returns the dot product (float) of the point coordinates and the plane normal.\n     */\n    dotCoordinate(point) {\n        return (this.normal.x * point.x +\n            this.normal.y * point.y +\n            this.normal.z * point.z +\n            this.d);\n    }\n    /**\n     * Updates the current Plane from the plane defined by the three given points.\n     * @param point1 - one of the points used to contruct the plane\n     * @param point2 - one of the points used to contruct the plane\n     * @param point3 - one of the points used to contruct the plane\n     * @returns the updated Plane.\n     */\n    copyFromPoints(point1, point2, point3) {\n        const x1 = point2.x - point1.x;\n        const y1 = point2.y - point1.y;\n        const z1 = point2.z - point1.z;\n        const x2 = point3.x - point1.x;\n        const y2 = point3.y - point1.y;\n        const z2 = point3.z - point1.z;\n        const yz = y1 * z2 - z1 * y2;\n        const xz = z1 * x2 - x1 * z2;\n        const xy = x1 * y2 - y1 * x2;\n        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);\n        let invPyth;\n        if (pyth !== 0) {\n            invPyth = 1.0 / pyth;\n        }\n        else {\n            invPyth = 0.0;\n        }\n        this.normal.x = yz * invPyth;\n        this.normal.y = xz * invPyth;\n        this.normal.z = xy * invPyth;\n        this.d = -(this.normal.x * point1.x +\n            this.normal.y * point1.y +\n            this.normal.z * point1.z);\n        return this;\n    }\n    /**\n     * Checks if the plane is facing a given direction\n     * @param direction - the direction to check if the plane is facing\n     * @param epsilon - value the dot product is compared against (returns true if dot &lt;= epsilon)\n     * @returns True is the vector \"direction\"  is the same side than the plane normal.\n     */\n    isFrontFacingTo(direction, epsilon) {\n        const dot = Vector3_1.Vector3.Dot(this.normal, direction);\n        return dot <= epsilon;\n    }\n    /**\n     * Calculates the distance to a point\n     * @param point - point to calculate distance to\n     * @returns the signed distance (float) from the given point to the Plane.\n     */\n    signedDistanceTo(point) {\n        return Vector3_1.Vector3.Dot(point, this.normal) + this.d;\n    }\n}\nexports.Plane = Plane;\n//# sourceMappingURL=Plane.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Plane.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Quaternion.js":
/*!*******************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Quaternion.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Quaternion = void 0;\nconst Matrix_1 = __webpack_require__(/*! ./Matrix */ \"./node_modules/@dcl/ecs-math/dist/Matrix.js\");\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\nconst preallocatedVariables_1 = __webpack_require__(/*! ./preallocatedVariables */ \"./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\nconst Scalar_1 = __webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\");\n/**\n * Class used to store quaternion data\n * {@link https://en.wikipedia.org/wiki/Quaternion }\n * {@link http://doc.babylonjs.com/features/position,_rotation,_scaling }\n * @public\n */\nclass Quaternion {\n    /**\n     * Creates a new Quaternion from the given floats\n     * @param x - defines the first component (0 by default)\n     * @param y - defines the second component (0 by default)\n     * @param z - defines the third component (0 by default)\n     * @param w - defines the fourth component (1.0 by default)\n     */\n    constructor(\n    /** defines the first component (0 by default) */\n    x = 0.0, \n    /** defines the second component (0 by default) */\n    y = 0.0, \n    /** defines the third component (0 by default) */\n    z = 0.0, \n    /** defines the fourth component (1.0 by default) */\n    w = 1.0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    // Statics\n    /**\n     * Creates a new quaternion from a rotation matrix\n     * @param matrix - defines the source matrix\n     * @returns a new quaternion created from the given rotation matrix values\n     */\n    static FromRotationMatrix(matrix) {\n        const result = new Quaternion();\n        Quaternion.FromRotationMatrixToRef(matrix, result);\n        return result;\n    }\n    /**\n     * Updates the given quaternion with the given rotation matrix values\n     * @param matrix - defines the source matrix\n     * @param result - defines the target quaternion\n     */\n    static FromRotationMatrixToRef(matrix, result) {\n        const data = matrix.m;\n        // tslint:disable:one-variable-per-declaration\n        const m11 = data[0], m12 = data[4], m13 = data[8];\n        const m21 = data[1], m22 = data[5], m23 = data[9];\n        const m31 = data[2], m32 = data[6], m33 = data[10];\n        // tslint:enable:one-variable-per-declaration\n        const trace = m11 + m22 + m33;\n        let s;\n        if (trace > 0) {\n            s = 0.5 / Math.sqrt(trace + 1.0);\n            result.w = 0.25 / s;\n            result.x = (m32 - m23) * s;\n            result.y = (m13 - m31) * s;\n            result.z = (m21 - m12) * s;\n        }\n        else if (m11 > m22 && m11 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m11 - m22 - m33);\n            result.w = (m32 - m23) / s;\n            result.x = 0.25 * s;\n            result.y = (m12 + m21) / s;\n            result.z = (m13 + m31) / s;\n        }\n        else if (m22 > m33) {\n            s = 2.0 * Math.sqrt(1.0 + m22 - m11 - m33);\n            result.w = (m13 - m31) / s;\n            result.x = (m12 + m21) / s;\n            result.y = 0.25 * s;\n            result.z = (m23 + m32) / s;\n        }\n        else {\n            s = 2.0 * Math.sqrt(1.0 + m33 - m11 - m22);\n            result.w = (m21 - m12) / s;\n            result.x = (m13 + m31) / s;\n            result.y = (m23 + m32) / s;\n            result.z = 0.25 * s;\n        }\n    }\n    /**\n     * Returns the dot product (float) between the quaternions \"left\" and \"right\"\n     * @param left - defines the left operand\n     * @param right - defines the right operand\n     * @returns the dot product\n     */\n    static Dot(left, right) {\n        return (left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w);\n    }\n    /**\n     * Checks if the two quaternions are close to each other\n     * @param quat0 - defines the first quaternion to check\n     * @param quat1 - defines the second quaternion to check\n     * @returns true if the two quaternions are close to each other\n     */\n    static AreClose(quat0, quat1) {\n        const dot = Quaternion.Dot(quat0, quat1);\n        return dot >= 0;\n    }\n    /**\n     * Creates an empty quaternion\n     * @returns a new quaternion set to (0.0, 0.0, 0.0)\n     */\n    static Zero() {\n        return new Quaternion(0.0, 0.0, 0.0, 0.0);\n    }\n    /**\n     * Inverse a given quaternion\n     * @param q - defines the source quaternion\n     * @returns a new quaternion as the inverted current quaternion\n     */\n    static Inverse(q) {\n        return new Quaternion(-q.x, -q.y, -q.z, q.w);\n    }\n    /**\n     * Gets a boolean indicating if the given quaternion is identity\n     * @param quaternion - defines the quaternion to check\n     * @returns true if the quaternion is identity\n     */\n    static IsIdentity(quaternion) {\n        return (quaternion &&\n            quaternion.x === 0 &&\n            quaternion.y === 0 &&\n            quaternion.z === 0 &&\n            quaternion.w === 1);\n    }\n    /**\n     * Creates a quaternion from a rotation around an axis\n     * @param axis - defines the axis to use\n     * @param angle - defines the angle to use (in Euler degrees)\n     * @returns a new quaternion created from the given axis (Vector3) and angle in radians (float)\n     */\n    static RotationAxis(axis, angle) {\n        const angleRad = angle * types_1.DEG2RAD;\n        return Quaternion.RotationAxisToRef(axis, angleRad, new Quaternion());\n    }\n    /**\n     * Creates a rotation around an axis and stores it into the given quaternion\n     * @param axis - defines the axis to use\n     * @param angle - defines the angle to use (in Euler degrees)\n     * @param result - defines the target quaternion\n     * @returns the target quaternion\n     */\n    static RotationAxisToRef(axis, angle, result) {\n        const angleRad = angle * types_1.DEG2RAD;\n        const sin = Math.sin(angleRad / 2);\n        axis.normalize();\n        result.w = Math.cos(angleRad / 2);\n        result.x = axis.x * sin;\n        result.y = axis.y * sin;\n        result.z = axis.z * sin;\n        return result;\n    }\n    /**\n     * Creates a new quaternion from data stored into an array\n     * @param array - defines the data source\n     * @param offset - defines the offset in the source array where the data starts\n     * @returns a new quaternion\n     */\n    static FromArray(array, offset = 0) {\n        return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    }\n    /**\n     * Creates a new quaternion from a set of euler angles and stores it in the target quaternion\n     */\n    static FromEulerAnglesRef(x, y, z, result) {\n        return Quaternion.RotationYawPitchRollToRef(y * types_1.DEG2RAD, x * types_1.DEG2RAD, z * types_1.DEG2RAD, result);\n    }\n    /**\n     * Creates a new quaternion from the given Euler float angles (y, x, z)\n     * @param yaw - defines the rotation around Y axis\n     * @param pitch - defines the rotation around X axis\n     * @param roll - defines the rotation around Z axis\n     * @returns the new quaternion\n     */\n    static RotationYawPitchRoll(yaw, pitch, roll) {\n        const q = new Quaternion();\n        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);\n        return q;\n    }\n    /**\n     * Creates a new rotation from the given Euler float angles (y, x, z) and stores it in the target quaternion\n     * @param yaw - defines the rotation around Y axis\n     * @param pitch - defines the rotation around X axis\n     * @param roll - defines the rotation around Z axis\n     * @param result - defines the target quaternion\n     */\n    static RotationYawPitchRollToRef(yaw, pitch, roll, result) {\n        // Implemented unity-based calculations from: https://stackoverflow.com/a/56055813\n        const halfPitch = pitch * 0.5;\n        const halfYaw = yaw * 0.5;\n        const halfRoll = roll * 0.5;\n        const c1 = Math.cos(halfPitch);\n        const c2 = Math.cos(halfYaw);\n        const c3 = Math.cos(halfRoll);\n        const s1 = Math.sin(halfPitch);\n        const s2 = Math.sin(halfYaw);\n        const s3 = Math.sin(halfRoll);\n        result.x = c2 * s1 * c3 + s2 * c1 * s3;\n        result.y = s2 * c1 * c3 - c2 * s1 * s3;\n        result.z = c2 * c1 * s3 - s2 * s1 * c3;\n        result.w = c2 * c1 * c3 + s2 * s1 * s3;\n    }\n    /**\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation\n     * @param alpha - defines the rotation around first axis\n     * @param beta - defines the rotation around second axis\n     * @param gamma - defines the rotation around third axis\n     * @returns the new quaternion\n     */\n    static RotationAlphaBetaGamma(alpha, beta, gamma) {\n        const result = new Quaternion();\n        Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);\n        return result;\n    }\n    /**\n     * Creates a new quaternion from the given Euler float angles expressed in z-x-z orientation and stores it in the target quaternion\n     * @param alpha - defines the rotation around first axis\n     * @param beta - defines the rotation around second axis\n     * @param gamma - defines the rotation around third axis\n     * @param result - defines the target quaternion\n     */\n    static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {\n        // Produces a quaternion from Euler angles in the z-x-z orientation\n        const halfGammaPlusAlpha = (gamma + alpha) * 0.5;\n        const halfGammaMinusAlpha = (gamma - alpha) * 0.5;\n        const halfBeta = beta * 0.5;\n        result.x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);\n        result.y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);\n        result.z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);\n        result.w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);\n    }\n    /**\n     * Creates a new quaternion containing the rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation)\n     * @param axis1 - defines the first axis\n     * @param axis2 - defines the second axis\n     * @param axis3 - defines the third axis\n     * @returns the new quaternion\n     */\n    static RotationQuaternionFromAxis(axis1, axis2, axis3) {\n        const quat = new Quaternion(0.0, 0.0, 0.0, 0.0);\n        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n        return quat;\n    }\n    /**\n     * Creates a rotation value to reach the target (axis1, axis2, axis3) orientation as a rotated XYZ system (axis1, axis2 and axis3 are normalized during this operation) and stores it in the target quaternion\n     * @param axis1 - defines the first axis\n     * @param axis2 - defines the second axis\n     * @param axis3 - defines the third axis\n     * @param ref - defines the target quaternion\n     */\n    static RotationQuaternionFromAxisToRef(axis1, axis2, axis3, ref) {\n        const rotMat = preallocatedVariables_1.MathTmp.Matrix[0];\n        Matrix_1.Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);\n        Quaternion.FromRotationMatrixToRef(rotMat, ref);\n    }\n    /**\n     * Interpolates between two quaternions\n     * @param left - defines first quaternion\n     * @param right - defines second quaternion\n     * @param amount - defines the gradient to use\n     * @returns the new interpolated quaternion\n     */\n    static Slerp(left, right, amount) {\n        const result = Quaternion.Identity;\n        Quaternion.SlerpToRef(left, right, amount, result);\n        return result;\n    }\n    /**\n     * Interpolates between two quaternions and stores it into a target quaternion\n     * @param left - defines first quaternion\n     * @param right - defines second quaternion\n     * @param amount - defines the gradient to use\n     * @param result - defines the target quaternion\n     */\n    static SlerpToRef(left, right, amount, result) {\n        let num2;\n        let num3;\n        let num4 = left.x * right.x + left.y * right.y + left.z * right.z + left.w * right.w;\n        let flag = false;\n        if (num4 < 0) {\n            flag = true;\n            num4 = -num4;\n        }\n        if (num4 > 0.999999) {\n            num3 = 1 - amount;\n            num2 = flag ? -amount : amount;\n        }\n        else {\n            const num5 = Math.acos(num4);\n            const num6 = 1.0 / Math.sin(num5);\n            num3 = Math.sin((1.0 - amount) * num5) * num6;\n            num2 = flag\n                ? -Math.sin(amount * num5) * num6\n                : Math.sin(amount * num5) * num6;\n        }\n        result.x = num3 * left.x + num2 * right.x;\n        result.y = num3 * left.y + num2 * right.y;\n        result.z = num3 * left.z + num2 * right.z;\n        result.w = num3 * left.w + num2 * right.w;\n    }\n    /**\n     * Interpolate between two quaternions using Hermite interpolation\n     * @param value1 - defines first quaternion\n     * @param tangent1 - defines the incoming tangent\n     * @param value2 - defines second quaternion\n     * @param tangent2 - defines the outgoing tangent\n     * @param amount - defines the target quaternion\n     * @returns the new interpolated quaternion\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const x = value1.x * part1 +\n            value2.x * part2 +\n            tangent1.x * part3 +\n            tangent2.x * part4;\n        const y = value1.y * part1 +\n            value2.y * part2 +\n            tangent1.y * part3 +\n            tangent2.y * part4;\n        const z = value1.z * part1 +\n            value2.z * part2 +\n            tangent1.z * part3 +\n            tangent2.z * part4;\n        const w = value1.w * part1 +\n            value2.w * part2 +\n            tangent1.w * part3 +\n            tangent2.w * part4;\n        return new Quaternion(x, y, z, w);\n    }\n    /**\n     * Creates an identity quaternion\n     * @returns - the identity quaternion\n     */\n    static get Identity() {\n        return new Quaternion(0.0, 0.0, 0.0, 1.0);\n    }\n    /**\n     * Returns the angle in degrees between two rotations a and b.\n     * @param quat1 - defines the first quaternion\n     * @param quat2 - defines the second quaternion\n     */\n    static Angle(quat1, quat2) {\n        const dot = Quaternion.Dot(quat1, quat2);\n        return Math.acos(Math.min(Math.abs(dot), 1)) * 2 * types_1.RAD2DEG;\n    }\n    /**\n     * Returns a rotation that rotates z degrees around the z axis, x degrees around the x axis, and y degrees around the y axis.\n     * @param x - the rotation on the x axis in euler degrees\n     * @param y - the rotation on the y axis in euler degrees\n     * @param z - the rotation on the z axis in euler degrees\n     */\n    static Euler(x, y, z) {\n        return Quaternion.RotationYawPitchRoll(y * types_1.DEG2RAD, x * types_1.DEG2RAD, z * types_1.DEG2RAD);\n    }\n    /**\n     * Creates a rotation with the specified forward and upwards directions.\n     * @param forward - the direction to look in\n     * @param up - the vector that defines in which direction up is\n     */\n    static LookRotation(forward, up = preallocatedVariables_1.MathTmp.staticUp) {\n        const forwardNew = Vector3_1.Vector3.Normalize(forward);\n        const right = Vector3_1.Vector3.Normalize(Vector3_1.Vector3.Cross(up, forwardNew));\n        const upNew = Vector3_1.Vector3.Cross(forwardNew, right);\n        const m00 = right.x;\n        const m01 = right.y;\n        const m02 = right.z;\n        const m10 = upNew.x;\n        const m11 = upNew.y;\n        const m12 = upNew.z;\n        const m20 = forwardNew.x;\n        const m21 = forwardNew.y;\n        const m22 = forwardNew.z;\n        const num8 = m00 + m11 + m22;\n        const quaternion = new Quaternion();\n        if (num8 > 0) {\n            let num = Math.sqrt(num8 + 1);\n            quaternion.w = num * 0.5;\n            num = 0.5 / num;\n            quaternion.x = (m12 - m21) * num;\n            quaternion.y = (m20 - m02) * num;\n            quaternion.z = (m01 - m10) * num;\n            return quaternion;\n        }\n        if (m00 >= m11 && m00 >= m22) {\n            const num7 = Math.sqrt(1 + m00 - m11 - m22);\n            const num4 = 0.5 / num7;\n            quaternion.x = 0.5 * num7;\n            quaternion.y = (m01 + m10) * num4;\n            quaternion.z = (m02 + m20) * num4;\n            quaternion.w = (m12 - m21) * num4;\n            return quaternion;\n        }\n        if (m11 > m22) {\n            const num6 = Math.sqrt(1 + m11 - m00 - m22);\n            const num3 = 0.5 / num6;\n            quaternion.x = (m10 + m01) * num3;\n            quaternion.y = 0.5 * num6;\n            quaternion.z = (m21 + m12) * num3;\n            quaternion.w = (m20 - m02) * num3;\n            return quaternion;\n        }\n        const num5 = Math.sqrt(1 + m22 - m00 - m11);\n        const num2 = 0.5 / num5;\n        quaternion.x = (m20 + m02) * num2;\n        quaternion.y = (m21 + m12) * num2;\n        quaternion.z = 0.5 * num5;\n        quaternion.w = (m01 - m10) * num2;\n        return quaternion;\n    }\n    /**\n     * The from quaternion is rotated towards to by an angular step of maxDegreesDelta.\n     * @param from - defines the first quaternion\n     * @param to - defines the second quaternion\n     * @param maxDegreesDelta - the interval step\n     */\n    static RotateTowards(from, to, maxDegreesDelta) {\n        const num = Quaternion.Angle(from, to);\n        if (num === 0) {\n            return to;\n        }\n        const t = Math.min(1, maxDegreesDelta / num);\n        return Quaternion.Slerp(from, to, t);\n    }\n    /**\n     * Creates a rotation which rotates from fromDirection to toDirection.\n     * @param from - defines the first direction Vector\n     * @param to - defines the target direction Vector\n     */\n    static FromToRotation(from, to, up = preallocatedVariables_1.MathTmp.staticUp) {\n        // Unity-based calculations implemented from https://forum.unity.com/threads/quaternion-lookrotation-around-an-axis.608470/#post-4069888\n        const v0 = from.normalize();\n        const v1 = to.normalize();\n        const a = Vector3_1.Vector3.Cross(v0, v1);\n        const w = Math.sqrt(v0.lengthSquared() * v1.lengthSquared()) + Vector3_1.Vector3.Dot(v0, v1);\n        if (a.lengthSquared() < 0.0001) {\n            // the vectors are parallel, check w to find direction\n            // if w is 0 then values are opposite, and we sould rotate 180 degrees around the supplied axis\n            // otherwise the vectors in the same direction and no rotation should occur\n            return Math.abs(w) < 0.0001\n                ? new Quaternion(up.x, up.y, up.z, 0).normalized\n                : Quaternion.Identity;\n        }\n        else {\n            return new Quaternion(a.x, a.y, a.z, w).normalized;\n        }\n    }\n    /**\n     * Converts this quaternion to one with the same orientation but with a magnitude of 1.\n     */\n    get normalized() {\n        return this.normalize();\n    }\n    /**\n     * Creates a rotation which rotates from fromDirection to toDirection.\n     * @param from - defines the first Vector\n     * @param to - defines the second Vector\n     * @param up - defines the direction\n     */\n    setFromToRotation(from, to, up = preallocatedVariables_1.MathTmp.staticUp) {\n        const result = Quaternion.FromToRotation(from, to, up);\n        this.x = result.x;\n        this.y = result.y;\n        this.z = result.z;\n        this.w = result.w;\n    }\n    set eulerAngles(euler) {\n        this.setEuler(euler.x, euler.y, euler.z);\n    }\n    /**\n     * Gets or sets the euler angle representation of the rotation.\n     * Implemented unity-based calculations from: https://stackoverflow.com/a/56055813\n     */\n    get eulerAngles() {\n        const out = new Vector3_1.Vector3();\n        // if the input quaternion is normalized, this is exactly one. Otherwise, this acts as a correction factor for the quaternion's not-normalizedness\n        const unit = this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n        // this will have a magnitude of 0.5 or greater if and only if this is a singularity case\n        const test = this.x * this.w - this.y * this.z;\n        if (test > 0.4995 * unit) {\n            // singularity at north pole\n            out.x = Math.PI / 2;\n            out.y = 2 * Math.atan2(this.y, this.x);\n            out.z = 0;\n        }\n        else if (test < -0.4995 * unit) {\n            // singularity at south pole\n            out.x = -Math.PI / 2;\n            out.y = -2 * Math.atan2(this.y, this.x);\n            out.z = 0;\n        }\n        else {\n            // no singularity - this is the majority of cases\n            out.x = Math.asin(2 * (this.w * this.x - this.y * this.z));\n            out.y = Math.atan2(2 * this.w * this.y + 2 * this.z * this.x, 1 - 2 * (this.x * this.x + this.y * this.y));\n            out.z = Math.atan2(2 * this.w * this.z + 2 * this.x * this.y, 1 - 2 * (this.z * this.z + this.x * this.x));\n        }\n        out.x *= types_1.RAD2DEG;\n        out.y *= types_1.RAD2DEG;\n        out.z *= types_1.RAD2DEG;\n        // ensure the degree values are between 0 and 360\n        out.x = Scalar_1.Scalar.Repeat(out.x, 360);\n        out.y = Scalar_1.Scalar.Repeat(out.y, 360);\n        out.z = Scalar_1.Scalar.Repeat(out.z, 360);\n        return out;\n    }\n    /**\n     * Gets a string representation for the current quaternion\n     * @returns a string with the Quaternion coordinates\n     */\n    toString() {\n        return `(${this.x}, ${this.y}, ${this.z}, ${this.w})`;\n    }\n    /**\n     * Gets length of current quaternion\n     * @returns the quaternion length (float)\n     */\n    get length() {\n        return Math.sqrt(this.lengthSquared);\n    }\n    /**\n     * Gets length of current quaternion\n     * @returns the quaternion length (float)\n     */\n    get lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    /**\n     * Gets the class name of the quaternion\n     * @returns the string \"Quaternion\"\n     */\n    getClassName() {\n        return 'Quaternion';\n    }\n    /**\n     * Gets a hash code for this quaternion\n     * @returns the quaternion hash code\n     */\n    getHashCode() {\n        let hash = this.x || 0;\n        hash = (hash * 397) ^ (this.y || 0);\n        hash = (hash * 397) ^ (this.z || 0);\n        hash = (hash * 397) ^ (this.w || 0);\n        return hash;\n    }\n    /**\n     * Copy the quaternion to an array\n     * @returns a new array populated with 4 elements from the quaternion coordinates\n     */\n    asArray() {\n        return [this.x, this.y, this.z, this.w];\n    }\n    /**\n     * Check if two quaternions are equals\n     * @param otherQuaternion - defines the second operand\n     * @returns true if the current quaternion and the given one coordinates are strictly equals\n     */\n    equals(otherQuaternion) {\n        return (otherQuaternion &&\n            this.x === otherQuaternion.x &&\n            this.y === otherQuaternion.y &&\n            this.z === otherQuaternion.z &&\n            this.w === otherQuaternion.w);\n    }\n    /**\n     * Clone the current quaternion\n     * @returns a new quaternion copied from the current one\n     */\n    clone() {\n        return new Quaternion(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Copy a quaternion to the current one\n     * @param other - defines the other quaternion\n     * @returns the updated current quaternion\n     */\n    copyFrom(other) {\n        this.x = other.x;\n        this.y = other.y;\n        this.z = other.z;\n        this.w = other.w;\n        return this;\n    }\n    /**\n     * Updates the current quaternion with the given float coordinates\n     * @param x - defines the x coordinate\n     * @param y - defines the y coordinate\n     * @param z - defines the z coordinate\n     * @param w - defines the w coordinate\n     * @returns the updated current quaternion\n     */\n    copyFromFloats(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    }\n    /**\n     * Updates the current quaternion from the given float coordinates\n     * @param x - defines the x coordinate\n     * @param y - defines the y coordinate\n     * @param z - defines the z coordinate\n     * @param w - defines the w coordinate\n     * @returns the updated current quaternion\n     */\n    set(x, y, z, w) {\n        return this.copyFromFloats(x, y, z, w);\n    }\n    /**\n     * Updates the current quaternion from the given euler angles\n     * @returns the updated current quaternion\n     */\n    setEuler(x, y, z) {\n        Quaternion.RotationYawPitchRollToRef(y * types_1.DEG2RAD, x * types_1.DEG2RAD, z * types_1.DEG2RAD, this);\n        return this;\n    }\n    /**\n     * @internal\n     * Adds two quaternions\n     * @param other - defines the second operand\n     * @returns a new quaternion as the addition result of the given one and the current quaternion\n     */\n    add(other) {\n        return new Quaternion(this.x + other.x, this.y + other.y, this.z + other.z, this.w + other.w);\n    }\n    /**\n     * @internal\n     * Add a quaternion to the current one\n     * @param other - defines the quaternion to add\n     * @returns the current quaternion\n     */\n    addInPlace(other) {\n        this.x += other.x;\n        this.y += other.y;\n        this.z += other.z;\n        this.w += other.w;\n        return this;\n    }\n    /**\n     * Subtract two quaternions\n     * @param other - defines the second operand\n     * @returns a new quaternion as the subtraction result of the given one from the current one\n     */\n    subtract(other) {\n        return new Quaternion(this.x - other.x, this.y - other.y, this.z - other.z, this.w - other.w);\n    }\n    /**\n     * Multiplies the current quaternion by a scale factor\n     * @param value - defines the scale factor\n     * @returns a new quaternion set by multiplying the current quaternion coordinates by the float \"scale\"\n     */\n    scale(value) {\n        return new Quaternion(this.x * value, this.y * value, this.z * value, this.w * value);\n    }\n    /**\n     * Scale the current quaternion values by a factor and stores the result to a given quaternion\n     * @param scale - defines the scale factor\n     * @param result - defines the Quaternion object where to store the result\n     * @returns the unmodified current quaternion\n     */\n    scaleToRef(scale, result) {\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        result.z = this.z * scale;\n        result.w = this.w * scale;\n        return this;\n    }\n    /**\n     * Multiplies in place the current quaternion by a scale factor\n     * @param value - defines the scale factor\n     * @returns the current modified quaternion\n     */\n    scaleInPlace(value) {\n        this.x *= value;\n        this.y *= value;\n        this.z *= value;\n        this.w *= value;\n        return this;\n    }\n    /**\n     * Scale the current quaternion values by a factor and add the result to a given quaternion\n     * @param scale - defines the scale factor\n     * @param result - defines the Quaternion object where to store the result\n     * @returns the unmodified current quaternion\n     */\n    scaleAndAddToRef(scale, result) {\n        result.x += this.x * scale;\n        result.y += this.y * scale;\n        result.z += this.z * scale;\n        result.w += this.w * scale;\n        return this;\n    }\n    /**\n     * Multiplies two quaternions\n     * @param q1 - defines the second operand\n     * @returns a new quaternion set as the multiplication result of the current one with the given one \"q1\"\n     */\n    multiply(q1) {\n        const result = new Quaternion(0, 0, 0, 1.0);\n        this.multiplyToRef(q1, result);\n        return result;\n    }\n    /**\n     * Sets the given \"result\" as the the multiplication result of the current one with the given one \"q1\"\n     * @param q1 - defines the second operand\n     * @param result - defines the target quaternion\n     * @returns the current quaternion\n     */\n    multiplyToRef(q1, result) {\n        const x = this.x * q1.w + this.y * q1.z - this.z * q1.y + this.w * q1.x;\n        const y = -this.x * q1.z + this.y * q1.w + this.z * q1.x + this.w * q1.y;\n        const z = this.x * q1.y - this.y * q1.x + this.z * q1.w + this.w * q1.z;\n        const w = -this.x * q1.x - this.y * q1.y - this.z * q1.z + this.w * q1.w;\n        result.copyFromFloats(x, y, z, w);\n        return this;\n    }\n    /**\n     * Updates the current quaternion with the multiplication of itself with the given one \"q1\"\n     * @param q1 - defines the second operand\n     * @returns the currentupdated quaternion\n     */\n    multiplyInPlace(q1) {\n        this.multiplyToRef(q1, this);\n        return this;\n    }\n    /**\n     * Conjugates (1-q) the current quaternion and stores the result in the given quaternion\n     * @param ref - defines the target quaternion\n     * @returns the current quaternion\n     */\n    conjugateToRef(ref) {\n        ref.copyFromFloats(-this.x, -this.y, -this.z, this.w);\n        return this;\n    }\n    /**\n     * Conjugates in place (1-q) the current quaternion\n     * @returns the current updated quaternion\n     */\n    conjugateInPlace() {\n        this.x *= -1;\n        this.y *= -1;\n        this.z *= -1;\n        return this;\n    }\n    /**\n     * Conjugates in place (1-q) the current quaternion\n     * @returns a new quaternion\n     */\n    conjugate() {\n        const result = new Quaternion(-this.x, -this.y, -this.z, this.w);\n        return result;\n    }\n    /**\n     * Normalize in place the current quaternion\n     * @returns the current updated quaternion\n     */\n    normalize() {\n        const length = 1.0 / this.length;\n        this.x *= length;\n        this.y *= length;\n        this.z *= length;\n        this.w *= length;\n        return this;\n    }\n    angleAxis(degress, axis) {\n        if (axis.lengthSquared() === 0) {\n            return Quaternion.Identity;\n        }\n        const result = Quaternion.Identity;\n        let radians = degress * types_1.DEG2RAD;\n        radians *= 0.5;\n        let a2 = axis.normalize();\n        a2 = axis.scaleInPlace(Math.sin(radians));\n        result.x = a2.x;\n        result.y = a2.y;\n        result.z = a2.z;\n        result.w = Math.cos(radians);\n        return result.normalize();\n    }\n    /**\n     * Updates the given rotation matrix with the current quaternion values\n     * @param result - defines the target matrix\n     * @returns the current unchanged quaternion\n     */\n    toRotationMatrix(result) {\n        Matrix_1.Matrix.FromQuaternionToRef(this, result);\n        return this;\n    }\n    /**\n     * Updates the current quaternion from the given rotation matrix values\n     * @param matrix - defines the source matrix\n     * @returns the current updated quaternion\n     */\n    fromRotationMatrix(matrix) {\n        Quaternion.FromRotationMatrixToRef(matrix, this);\n        return this;\n    }\n}\nexports.Quaternion = Quaternion;\n//# sourceMappingURL=Quaternion.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Quaternion.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Scalar.js":
/*!***************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Scalar.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Scalar = void 0;\n/**\n * Scalar computation library\n * @public\n */\nclass Scalar {\n    /**\n     * Boolean : true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     * @param a - number\n     * @param b - number\n     * @param epsilon - (default = 1.401298E-45)\n     * @returns true if the absolute difference between a and b is lower than epsilon (default = 1.401298E-45)\n     */\n    static WithinEpsilon(a, b, epsilon = 1.401298e-45) {\n        const num = a - b;\n        return -epsilon <= num && num <= epsilon;\n    }\n    /**\n     * Returns a string : the upper case translation of the number i to hexadecimal.\n     * @param i - number\n     * @returns the upper case translation of the number i to hexadecimal.\n     */\n    static ToHex(i) {\n        const str = i.toString(16);\n        if (i <= 15) {\n            return ('0' + str).toUpperCase();\n        }\n        return str.toUpperCase();\n    }\n    /**\n     * Returns -1 if value is negative and +1 is value is positive.\n     * @param _value - the value\n     * @returns the value itself if it's equal to zero.\n     */\n    static Sign(value) {\n        const _value = +value; // convert to a number\n        if (_value === 0 || isNaN(_value)) {\n            return _value;\n        }\n        return _value > 0 ? 1 : -1;\n    }\n    /**\n     * Returns the value itself if it's between min and max.\n     * Returns min if the value is lower than min.\n     * Returns max if the value is greater than max.\n     * @param value - the value to clmap\n     * @param min - the min value to clamp to (default: 0)\n     * @param max - the max value to clamp to (default: 1)\n     * @returns the clamped value\n     */\n    static Clamp(value, min = 0, max = 1) {\n        return Math.min(max, Math.max(min, value));\n    }\n    /**\n     * the log2 of value.\n     * @param value - the value to compute log2 of\n     * @returns the log2 of value.\n     */\n    static Log2(value) {\n        return Math.log(value) * Math.LOG2E;\n    }\n    /**\n     * Loops the value, so that it is never larger than length and never smaller than 0.\n     *\n     * This is similar to the modulo operator but it works with floating point numbers.\n     * For example, using 3.0 for t and 2.5 for length, the result would be 0.5.\n     * With t = 5 and length = 2.5, the result would be 0.0.\n     * Note, however, that the behaviour is not defined for negative numbers as it is for the modulo operator\n     * @param value - the value\n     * @param length - the length\n     * @returns the looped value\n     */\n    static Repeat(value, length) {\n        return value - Math.floor(value / length) * length;\n    }\n    /**\n     * Normalize the value between 0.0 and 1.0 using min and max values\n     * @param value - value to normalize\n     * @param min - max to normalize between\n     * @param max - min to normalize between\n     * @returns the normalized value\n     */\n    static Normalize(value, min, max) {\n        return (value - min) / (max - min);\n    }\n    /**\n     * Denormalize the value from 0.0 and 1.0 using min and max values\n     * @param normalized - value to denormalize\n     * @param min - max to denormalize between\n     * @param max - min to denormalize between\n     * @returns the denormalized value\n     */\n    static Denormalize(normalized, min, max) {\n        return normalized * (max - min) + min;\n    }\n    /**\n     * Calculates the shortest difference between two given angles given in degrees.\n     * @param current - current angle in degrees\n     * @param target - target angle in degrees\n     * @returns the delta\n     */\n    static DeltaAngle(current, target) {\n        let num = Scalar.Repeat(target - current, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return num;\n    }\n    /**\n     * PingPongs the value t, so that it is never larger than length and never smaller than 0.\n     * @param tx - value\n     * @param length - length\n     * @returns The returned value will move back and forth between 0 and length\n     */\n    static PingPong(tx, length) {\n        const t = Scalar.Repeat(tx, length * 2.0);\n        return length - Math.abs(t - length);\n    }\n    /**\n     * Interpolates between min and max with smoothing at the limits.\n     *\n     * This function interpolates between min and max in a similar way to Lerp. However, the interpolation will gradually speed up\n     * from the start and slow down toward the end. This is useful for creating natural-looking animation, fading and other transitions.\n     * @param from - from\n     * @param to - to\n     * @param tx - value\n     * @returns the smooth stepped value\n     */\n    static SmoothStep(from, to, tx) {\n        let t = Scalar.Clamp(tx);\n        t = -2.0 * t * t * t + 3.0 * t * t;\n        return to * t + from * (1.0 - t);\n    }\n    /**\n     * Moves a value current towards target.\n     *\n     * This is essentially the same as Mathf.Lerp but instead the function will ensure that the speed never exceeds maxDelta.\n     * Negative values of maxDelta pushes the value away from target.\n     * @param current - current value\n     * @param target - target value\n     * @param maxDelta - max distance to move\n     * @returns resulting value\n     */\n    static MoveTowards(current, target, maxDelta) {\n        let result = 0;\n        if (Math.abs(target - current) <= maxDelta) {\n            result = target;\n        }\n        else {\n            result = current + Scalar.Sign(target - current) * maxDelta;\n        }\n        return result;\n    }\n    /**\n     * Same as MoveTowards but makes sure the values interpolate correctly when they wrap around 360 degrees.\n     *\n     * Variables current and target are assumed to be in degrees. For optimization reasons, negative values of maxDelta\n     *  are not supported and may cause oscillation. To push current away from a target angle, add 180 to that angle instead.\n     * @param current - current value\n     * @param target - target value\n     * @param maxDelta - max distance to move\n     * @returns resulting angle\n     */\n    static MoveTowardsAngle(current, target, maxDelta) {\n        const num = Scalar.DeltaAngle(current, target);\n        let result = 0;\n        if (-maxDelta < num && num < maxDelta) {\n            result = target;\n        }\n        else {\n            result = Scalar.MoveTowards(current, current + num, maxDelta);\n        }\n        return result;\n    }\n    /**\n     * Creates a new scalar with values linearly interpolated of \"amount\" between the start scalar and the end scalar.\n     * @param start - start value\n     * @param end - target value\n     * @param amount - amount to lerp between\n     * @returns the lerped value\n     */\n    static Lerp(start, end, amount) {\n        return start + (end - start) * amount;\n    }\n    /**\n     * Same as Lerp but makes sure the values interpolate correctly when they wrap around 360 degrees.\n     * The parameter t is clamped to the range [0, 1]. Variables a and b are assumed to be in degrees.\n     * @param start - start value\n     * @param end - target value\n     * @param amount - amount to lerp between\n     * @returns the lerped value\n     */\n    static LerpAngle(start, end, amount) {\n        let num = Scalar.Repeat(end - start, 360.0);\n        if (num > 180.0) {\n            num -= 360.0;\n        }\n        return start + num * Scalar.Clamp(amount);\n    }\n    /**\n     * Calculates the linear parameter t that produces the interpolant value within the range [a, b].\n     * @param a - start value\n     * @param b - target value\n     * @param value - value between a and b\n     * @returns the inverseLerp value\n     */\n    static InverseLerp(a, b, value) {\n        let result = 0;\n        if (a !== b) {\n            result = Scalar.Clamp((value - a) / (b - a));\n        }\n        else {\n            result = 0.0;\n        }\n        return result;\n    }\n    /**\n     * Returns a new scalar located for \"amount\" (float) on the Hermite spline defined by the scalars \"value1\", \"value3\", \"tangent1\", \"tangent2\".\n     * {@link http://mathworld.wolfram.com/HermitePolynomial.html}\n     * @param value1 - spline value\n     * @param tangent1 - spline value\n     * @param value2 - spline value\n     * @param tangent2 - spline value\n     * @param amount - input value\n     * @returns hermite result\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;\n    }\n    /**\n     * Returns a random float number between and min and max values\n     * @param min - min value of random\n     * @param max - max value of random\n     * @returns random value\n     */\n    static RandomRange(min, max) {\n        if (min === max) {\n            return min;\n        }\n        return Math.random() * (max - min) + min;\n    }\n    /**\n     * This function returns percentage of a number in a given range.\n     *\n     * RangeToPercent(40,20,60) will return 0.5 (50%)\n     * RangeToPercent(34,0,100) will return 0.34 (34%)\n     * @param num - to convert to percentage\n     * @param min - min range\n     * @param max - max range\n     * @returns the percentage\n     */\n    static RangeToPercent(num, min, max) {\n        return (num - min) / (max - min);\n    }\n    /**\n     * This function returns number that corresponds to the percentage in a given range.\n     *\n     * PercentToRange(0.34,0,100) will return 34.\n     * @param percent - to convert to number\n     * @param min - min range\n     * @param max - max range\n     * @returns the number\n     */\n    static PercentToRange(percent, min, max) {\n        return (max - min) * percent + min;\n    }\n    /**\n     * Returns the angle converted to equivalent value between -Math.PI and Math.PI radians.\n     * @param angle - The angle to normalize in radian.\n     * @returns The converted angle.\n     */\n    static NormalizeRadians(angle) {\n        // More precise but slower version kept for reference.\n        // tslint:disable:no-commented-out-code\n        /*\n          // angle = angle % Tools.TwoPi;\n          // angle = (angle + Tools.TwoPi) % Tools.TwoPi;\n    \n          //if (angle > Math.PI) {\n          //\tangle -= Tools.TwoPi;\n          //}\n           */\n        return angle - Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);\n    }\n}\nexports.Scalar = Scalar;\n/**\n * Two pi constants convenient for computation.\n */\nScalar.TwoPi = Math.PI * 2;\n//# sourceMappingURL=Scalar.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Scalar.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Size.js":
/*!*************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Size.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Size = void 0;\n/**\n * Size containing widht and height\n * @public\n */\nclass Size {\n    /**\n     * Creates a Size object from the given width and height (floats).\n     * @param width - width of the new size\n     * @param height - height of the new size\n     */\n    constructor(width, height) {\n        this.width = width;\n        this.height = height;\n    }\n    /**\n     * The surface of the Size : width * height (float).\n     */\n    get surface() {\n        return this.width * this.height;\n    }\n    /**\n     * Create a new size of zero\n     * @returns a new Size set to (0.0, 0.0)\n     */\n    static Zero() {\n        return new Size(0.0, 0.0);\n    }\n    /**\n     * Creates a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     * @param start - starting size to lerp between\n     * @param end - end size to lerp between\n     * @param amount - amount to lerp between the start and end values\n     * @returns a new Size set at the linear interpolation \"amount\" between \"start\" and \"end\"\n     */\n    static Lerp(start, end, amount) {\n        const w = start.width + (end.width - start.width) * amount;\n        const h = start.height + (end.height - start.height) * amount;\n        return new Size(w, h);\n    }\n    /**\n     * Returns a string with the Size width and height\n     * @returns a string with the Size width and height\n     */\n    toString() {\n        return `{W: ${this.width}, H: ${this.height}}`;\n    }\n    /**\n     * \"Size\"\n     * @returns the string \"Size\"\n     */\n    getClassName() {\n        return 'Size';\n    }\n    /**\n     * Returns the Size hash code.\n     * @returns a hash code for a unique width and height\n     */\n    getHashCode() {\n        let hash = this.width || 0;\n        hash = (hash * 397) ^ (this.height || 0);\n        return hash;\n    }\n    /**\n     * Updates the current size from the given one.\n     * @param src - the given size\n     */\n    copyFrom(src) {\n        this.width = src.width;\n        this.height = src.height;\n    }\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width - width of the new size\n     * @param height - height of the new size\n     * @returns the updated Size.\n     */\n    copyFromFloats(width, height) {\n        this.width = width;\n        this.height = height;\n        return this;\n    }\n    /**\n     * Updates in place the current Size from the given floats.\n     * @param width - width to set\n     * @param height - height to set\n     * @returns the updated Size.\n     */\n    set(width, height) {\n        return this.copyFromFloats(width, height);\n    }\n    /**\n     * Multiplies the width and height by numbers\n     * @param w - factor to multiple the width by\n     * @param h - factor to multiple the height by\n     * @returns a new Size set with the multiplication result of the current Size and the given floats.\n     */\n    multiplyByFloats(w, h) {\n        return new Size(this.width * w, this.height * h);\n    }\n    /**\n     * Clones the size\n     * @returns a new Size copied from the given one.\n     */\n    clone() {\n        return new Size(this.width, this.height);\n    }\n    /**\n     * True if the current Size and the given one width and height are strictly equal.\n     * @param other - the other size to compare against\n     * @returns True if the current Size and the given one width and height are strictly equal.\n     */\n    equals(other) {\n        if (!other) {\n            return false;\n        }\n        return this.width === other.width && this.height === other.height;\n    }\n    /**\n     * Sums the width and height of two sizes\n     * @param otherSize - size to add to this size\n     * @returns a new Size set as the addition result of the current Size and the given one.\n     */\n    add(otherSize) {\n        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);\n        return r;\n    }\n    /**\n     * Subtracts the width and height of two\n     * @param otherSize - size to subtract to this size\n     * @returns a new Size set as the subtraction result of  the given one from the current Size.\n     */\n    subtract(otherSize) {\n        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);\n        return r;\n    }\n}\nexports.Size = Size;\n//# sourceMappingURL=Size.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Size.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Vector2.js":
/*!****************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Vector2.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Vector2 = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\nconst Scalar_1 = __webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\");\n/**\n * Class representing a vector containing 2 coordinates\n * @public\n */\nclass Vector2 {\n    /**\n     * Creates a new Vector2 from the given x and y coordinates\n     * @param x - defines the first coordinate\n     * @param y - defines the second coordinate\n     */\n    constructor(\n    /** defines the first coordinate */\n    x = 0, \n    /** defines the second coordinate */\n    y = 0) {\n        this.x = x;\n        this.y = y;\n    }\n    /**\n     * Gets a new Vector2(0, 0)\n     * @returns a new Vector2\n     */\n    static Zero() {\n        return new Vector2(0, 0);\n    }\n    /**\n     * Gets a new Vector2(1, 1)\n     * @returns a new Vector2\n     */\n    static One() {\n        return new Vector2(1, 1);\n    }\n    /**\n     * Returns a new Vector2 as the result of the addition of the two given vectors.\n     * @param vector1 - the first vector\n     * @param vector2 - the second vector\n     * @returns the resulting vector\n     */\n    static Add(vector1, vector2) {\n        return new Vector2(vector1.x, vector1.y).addInPlace(vector2);\n    }\n    /**\n     * Gets a new Vector2 set from the given index element of the given array\n     * @param array - defines the data source\n     * @param offset - defines the offset in the data source\n     * @returns a new Vector2\n     */\n    static FromArray(array, offset = 0) {\n        return new Vector2(array[offset], array[offset + 1]);\n    }\n    /**\n     * Sets \"result\" from the given index element of the given array\n     * @param array - defines the data source\n     * @param offset - defines the offset in the data source\n     * @param result - defines the target vector\n     */\n    static FromArrayToRef(array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n    }\n    /**\n     * Gets a new Vector2 located for \"amount\" (float) on the CatmullRom spline defined by the given four Vector2\n     * @param value1 - defines 1st point of control\n     * @param value2 - defines 2nd point of control\n     * @param value3 - defines 3rd point of control\n     * @param value4 - defines 4th point of control\n     * @param amount - defines the interpolation factor\n     * @returns a new Vector2\n     */\n    static CatmullRom(value1, value2, value3, value4, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const x = 0.5 *\n            (2.0 * value2.x +\n                (-value1.x + value3.x) * amount +\n                (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) *\n                    squared +\n                (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n        const y = 0.5 *\n            (2.0 * value2.y +\n                (-value1.y + value3.y) * amount +\n                (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) *\n                    squared +\n                (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n        return new Vector2(x, y);\n    }\n    /**\n     * Returns a new Vector2 set with same the coordinates than \"value\" ones if the vector \"value\" is in the square defined by \"min\" and \"max\".\n     * If a coordinate of \"value\" is lower than \"min\" coordinates, the returned Vector2 is given this \"min\" coordinate.\n     * If a coordinate of \"value\" is greater than \"max\" coordinates, the returned Vector2 is given this \"max\" coordinate\n     * @param value - defines the value to clamp\n     * @param min - defines the lower limit\n     * @param max - defines the upper limit\n     * @returns a new Vector2\n     */\n    static Clamp(value, min, max) {\n        let x = value.x;\n        x = x > max.x ? max.x : x;\n        x = x < min.x ? min.x : x;\n        let y = value.y;\n        y = y > max.y ? max.y : y;\n        y = y < min.y ? min.y : y;\n        return new Vector2(x, y);\n    }\n    /**\n     * Returns a new Vector2 located for \"amount\" (float) on the Hermite spline defined by the vectors \"value1\", \"value3\", \"tangent1\", \"tangent2\"\n     * @param value1 - defines the 1st control point\n     * @param tangent1 - defines the outgoing tangent\n     * @param value2 - defines the 2nd control point\n     * @param tangent2 - defines the incoming tangent\n     * @param amount - defines the interpolation factor\n     * @returns a new Vector2\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const x = value1.x * part1 +\n            value2.x * part2 +\n            tangent1.x * part3 +\n            tangent2.x * part4;\n        const y = value1.y * part1 +\n            value2.y * part2 +\n            tangent1.y * part3 +\n            tangent2.y * part4;\n        return new Vector2(x, y);\n    }\n    /**\n     * Returns a new Vector2 located for \"amount\" (float) on the linear interpolation between the vector \"start\" adn the vector \"end\".\n     * @param start - defines the start vector\n     * @param end - defines the end vector\n     * @param amount - defines the interpolation factor\n     * @returns a new Vector2\n     */\n    static Lerp(start, end, amount) {\n        const x = start.x + (end.x - start.x) * amount;\n        const y = start.y + (end.y - start.y) * amount;\n        return new Vector2(x, y);\n    }\n    /**\n     * Gets the dot product of the vector \"left\" and the vector \"right\"\n     * @param left - defines first vector\n     * @param right - defines second vector\n     * @returns the dot product (float)\n     */\n    static Dot(left, right) {\n        return left.x * right.x + left.y * right.y;\n    }\n    /**\n     * Returns a new Vector2 equal to the normalized given vector\n     * @param vector - defines the vector to normalize\n     * @returns a new Vector2\n     */\n    static Normalize(vector) {\n        const newVector = new Vector2(vector.x, vector.y);\n        newVector.normalize();\n        return newVector;\n    }\n    /**\n     * Gets a new Vector2 set with the minimal coordinate values from the \"left\" and \"right\" vectors\n     * @param left - defines 1st vector\n     * @param right - defines 2nd vector\n     * @returns a new Vector2\n     */\n    static Minimize(left, right) {\n        const x = left.x < right.x ? left.x : right.x;\n        const y = left.y < right.y ? left.y : right.y;\n        return new Vector2(x, y);\n    }\n    /**\n     * Gets a new Vecto2 set with the maximal coordinate values from the \"left\" and \"right\" vectors\n     * @param left - defines 1st vector\n     * @param right - defines 2nd vector\n     * @returns a new Vector2\n     */\n    static Maximize(left, right) {\n        const x = left.x > right.x ? left.x : right.x;\n        const y = left.y > right.y ? left.y : right.y;\n        return new Vector2(x, y);\n    }\n    /**\n     * Gets a new Vector2 set with the transformed coordinates of the given vector by the given transformation matrix\n     * @param vector - defines the vector to transform\n     * @param transformation - defines the matrix to apply\n     * @returns a new Vector2\n     */\n    static Transform(vector, transformation) {\n        const r = Vector2.Zero();\n        Vector2.TransformToRef(vector, transformation, r);\n        return r;\n    }\n    /**\n     * Transforms the given vector coordinates by the given transformation matrix and stores the result in the vector \"result\" coordinates\n     * @param vector - defines the vector to transform\n     * @param transformation - defines the matrix to apply\n     * @param result - defines the target vector\n     */\n    static TransformToRef(vector, transformation, result) {\n        const m = transformation.m;\n        const x = vector.x * m[0] + vector.y * m[4] + m[12];\n        const y = vector.x * m[1] + vector.y * m[5] + m[13];\n        result.x = x;\n        result.y = y;\n    }\n    /**\n     * Determines if a given vector is included in a triangle\n     * @param p - defines the vector to test\n     * @param p0 - defines 1st triangle point\n     * @param p1 - defines 2nd triangle point\n     * @param p2 - defines 3rd triangle point\n     * @returns true if the point \"p\" is in the triangle defined by the vertors \"p0\", \"p1\", \"p2\"\n     */\n    static PointInTriangle(p, p0, p1, p2) {\n        const a = (1 / 2) *\n            (-p1.y * p2.x +\n                p0.y * (-p1.x + p2.x) +\n                p0.x * (p1.y - p2.y) +\n                p1.x * p2.y);\n        const sign = a < 0 ? -1 : 1;\n        const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) *\n            sign;\n        const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) *\n            sign;\n        return s > 0 && t > 0 && s + t < 2 * a * sign;\n    }\n    /**\n     * Gets the distance between the vectors \"value1\" and \"value2\"\n     * @param value1 - defines first vector\n     * @param value2 - defines second vector\n     * @returns the distance between vectors\n     */\n    static Distance(value1, value2) {\n        return Math.sqrt(Vector2.DistanceSquared(value1, value2));\n    }\n    /**\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\n     * @param value1 - defines first vector\n     * @param value2 - defines second vector\n     * @returns the squared distance between vectors\n     */\n    static DistanceSquared(value1, value2) {\n        const x = value1.x - value2.x;\n        const y = value1.y - value2.y;\n        return x * x + y * y;\n    }\n    /**\n     * Gets a new Vector2 located at the center of the vectors \"value1\" and \"value2\"\n     * @param value1 - defines first vector\n     * @param value2 - defines second vector\n     * @returns a new Vector2\n     */\n    static Center(value1, value2) {\n        const center = Vector2.Add(value1, value2);\n        center.scaleInPlace(0.5);\n        return center;\n    }\n    /**\n     * Gets the shortest distance (float) between the point \"p\" and the segment defined by the two points \"segA\" and \"segB\".\n     * @param p - defines the middle point\n     * @param segA - defines one point of the segment\n     * @param segB - defines the other point of the segment\n     * @returns the shortest distance\n     */\n    static DistanceOfPointFromSegment(p, segA, segB) {\n        const l2 = Vector2.DistanceSquared(segA, segB);\n        if (l2 === 0.0) {\n            return Vector2.Distance(p, segA);\n        }\n        const v = segB.subtract(segA);\n        const t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));\n        const proj = segA.add(v.multiplyByFloats(t, t));\n        return Vector2.Distance(p, proj);\n    }\n    /**\n     * Gets a string with the Vector2 coordinates\n     * @returns a string with the Vector2 coordinates\n     */\n    toString() {\n        return '{X: ' + this.x + ' Y:' + this.y + '}';\n    }\n    /**\n     * Gets class name\n     * @returns the string \"Vector2\"\n     */\n    getClassName() {\n        return 'Vector2';\n    }\n    /**\n     * Gets current vector hash code\n     * @returns the Vector2 hash code as a number\n     */\n    getHashCode() {\n        let hash = this.x || 0;\n        hash = (hash * 397) ^ (this.y || 0);\n        return hash;\n    }\n    // Operators\n    /**\n     * Sets the Vector2 coordinates in the given array or FloatArray from the given index.\n     * @param array - defines the source array\n     * @param index - defines the offset in source array\n     * @returns the current Vector2\n     */\n    toArray(array, index = 0) {\n        array[index] = this.x;\n        array[index + 1] = this.y;\n        return this;\n    }\n    /**\n     * Copy the current vector to an array\n     * @returns a new array with 2 elements: the Vector2 coordinates.\n     */\n    asArray() {\n        const result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Sets the Vector2 coordinates with the given Vector2 coordinates\n     * @param source - defines the source Vector2\n     * @returns the current updated Vector2\n     */\n    copyFrom(source) {\n        this.x = source.x;\n        this.y = source.y;\n        return this;\n    }\n    /**\n     * Sets the Vector2 coordinates with the given floats\n     * @param x - defines the first coordinate\n     * @param y - defines the second coordinate\n     * @returns the current updated Vector2\n     */\n    copyFromFloats(x, y) {\n        this.x = x;\n        this.y = y;\n        return this;\n    }\n    /**\n     * Sets the Vector2 coordinates with the given floats\n     * @param x - defines the first coordinate\n     * @param y - defines the second coordinate\n     * @returns the current updated Vector2\n     */\n    set(x, y) {\n        return this.copyFromFloats(x, y);\n    }\n    /**\n     * Add another vector with the current one\n     * @param otherVector - defines the other vector\n     * @returns a new Vector2 set with the addition of the current Vector2 and the given one coordinates\n     */\n    add(otherVector) {\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n    }\n    /**\n     * Sets the \"result\" coordinates with the addition of the current Vector2 and the given one coordinates\n     * @param otherVector - defines the other vector\n     * @param result - defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    addToRef(otherVector, result) {\n        result.x = this.x + otherVector.x;\n        result.y = this.y + otherVector.y;\n        return this;\n    }\n    /**\n     * Set the Vector2 coordinates by adding the given Vector2 coordinates\n     * @param otherVector - defines the other vector\n     * @returns the current updated Vector2\n     */\n    addInPlace(otherVector) {\n        this.x += otherVector.x;\n        this.y += otherVector.y;\n        return this;\n    }\n    /**\n     * Gets a new Vector2 by adding the current Vector2 coordinates to the given Vector3 x, y coordinates\n     * @param otherVector - defines the other vector\n     * @returns a new Vector2\n     */\n    addVector3(otherVector) {\n        return new Vector2(this.x + otherVector.x, this.y + otherVector.y);\n    }\n    /**\n     * Gets a new Vector2 set with the subtracted coordinates of the given one from the current Vector2\n     * @param otherVector - defines the other vector\n     * @returns a new Vector2\n     */\n    subtract(otherVector) {\n        return new Vector2(this.x - otherVector.x, this.y - otherVector.y);\n    }\n    /**\n     * Sets the \"result\" coordinates with the subtraction of the given one from the current Vector2 coordinates.\n     * @param otherVector - defines the other vector\n     * @param result - defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    subtractToRef(otherVector, result) {\n        result.x = this.x - otherVector.x;\n        result.y = this.y - otherVector.y;\n        return this;\n    }\n    /**\n     * Sets the current Vector2 coordinates by subtracting from it the given one coordinates\n     * @param otherVector - defines the other vector\n     * @returns the current updated Vector2\n     */\n    subtractInPlace(otherVector) {\n        this.x -= otherVector.x;\n        this.y -= otherVector.y;\n        return this;\n    }\n    /**\n     * Multiplies in place the current Vector2 coordinates by the given ones\n     * @param otherVector - defines the other vector\n     * @returns the current updated Vector2\n     */\n    multiplyInPlace(otherVector) {\n        this.x *= otherVector.x;\n        this.y *= otherVector.y;\n        return this;\n    }\n    /**\n     * Returns a new Vector2 set with the multiplication of the current Vector2 and the given one coordinates\n     * @param otherVector - defines the other vector\n     * @returns a new Vector2\n     */\n    multiply(otherVector) {\n        return new Vector2(this.x * otherVector.x, this.y * otherVector.y);\n    }\n    /**\n     * Sets \"result\" coordinates with the multiplication of the current Vector2 and the given one coordinates\n     * @param otherVector - defines the other vector\n     * @param result - defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    multiplyToRef(otherVector, result) {\n        result.x = this.x * otherVector.x;\n        result.y = this.y * otherVector.y;\n        return this;\n    }\n    /**\n     * Gets a new Vector2 set with the Vector2 coordinates multiplied by the given floats\n     * @param x - defines the first coordinate\n     * @param y - defines the second coordinate\n     * @returns a new Vector2\n     */\n    multiplyByFloats(x, y) {\n        return new Vector2(this.x * x, this.y * y);\n    }\n    /**\n     * Returns a new Vector2 set with the Vector2 coordinates divided by the given one coordinates\n     * @param otherVector - defines the other vector\n     * @returns a new Vector2\n     */\n    divide(otherVector) {\n        return new Vector2(this.x / otherVector.x, this.y / otherVector.y);\n    }\n    /**\n     * Sets the \"result\" coordinates with the Vector2 divided by the given one coordinates\n     * @param otherVector - defines the other vector\n     * @param result - defines the target vector\n     * @returns the unmodified current Vector2\n     */\n    divideToRef(otherVector, result) {\n        result.x = this.x / otherVector.x;\n        result.y = this.y / otherVector.y;\n        return this;\n    }\n    /**\n     * Divides the current Vector2 coordinates by the given ones\n     * @param otherVector - defines the other vector\n     * @returns the current updated Vector2\n     */\n    divideInPlace(otherVector) {\n        return this.divideToRef(otherVector, this);\n    }\n    /**\n     * Gets a new Vector2 with current Vector2 negated coordinates\n     * @returns a new Vector2\n     */\n    negate() {\n        return new Vector2(-this.x, -this.y);\n    }\n    /**\n     * Multiply the Vector2 coordinates by scale\n     * @param scale - defines the scaling factor\n     * @returns the current updated Vector2\n     */\n    scaleInPlace(scale) {\n        this.x *= scale;\n        this.y *= scale;\n        return this;\n    }\n    /**\n     * Returns a new Vector2 scaled by \"scale\" from the current Vector2\n     * @param scale - defines the scaling factor\n     * @returns a new Vector2\n     */\n    scale(scale) {\n        const result = new Vector2(0, 0);\n        this.scaleToRef(scale, result);\n        return result;\n    }\n    /**\n     * Scale the current Vector2 values by a factor to a given Vector2\n     * @param scale - defines the scale factor\n     * @param result - defines the Vector2 object where to store the result\n     * @returns the unmodified current Vector2\n     */\n    scaleToRef(scale, result) {\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        return this;\n    }\n    /**\n     * Scale the current Vector2 values by a factor and add the result to a given Vector2\n     * @param scale - defines the scale factor\n     * @param result - defines the Vector2 object where to store the result\n     * @returns the unmodified current Vector2\n     */\n    scaleAndAddToRef(scale, result) {\n        result.x += this.x * scale;\n        result.y += this.y * scale;\n        return this;\n    }\n    /**\n     * Gets a boolean if two vectors are equals\n     * @param otherVector - defines the other vector\n     * @returns true if the given vector coordinates strictly equal the current Vector2 ones\n     */\n    equals(otherVector) {\n        return otherVector && this.x === otherVector.x && this.y === otherVector.y;\n    }\n    /**\n     * Gets a boolean if two vectors are equals (using an epsilon value)\n     * @param otherVector - defines the other vector\n     * @param epsilon - defines the minimal distance to consider equality\n     * @returns true if the given vector coordinates are close to the current ones by a distance of epsilon.\n     */\n    equalsWithEpsilon(otherVector, epsilon = types_1.Epsilon) {\n        return (otherVector &&\n            Scalar_1.Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n            Scalar_1.Scalar.WithinEpsilon(this.y, otherVector.y, epsilon));\n    }\n    /**\n     * Gets a new Vector2 from current Vector2 floored values\n     * @returns a new Vector2\n     */\n    floor() {\n        return new Vector2(Math.floor(this.x), Math.floor(this.y));\n    }\n    /**\n     * Gets a new Vector2 from current Vector2 floored values\n     * @returns a new Vector2\n     */\n    fract() {\n        return new Vector2(this.x - Math.floor(this.x), this.y - Math.floor(this.y));\n    }\n    // Properties\n    /**\n     * Gets the length of the vector\n     * @returns the vector length (float)\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y);\n    }\n    /**\n     * Gets the vector squared length\n     * @returns the vector squared length (float)\n     */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y;\n    }\n    // Methods\n    /**\n     * Normalize the vector\n     * @returns the current updated Vector2\n     */\n    normalize() {\n        const len = this.length();\n        if (len === 0) {\n            return this;\n        }\n        const num = 1.0 / len;\n        this.x *= num;\n        this.y *= num;\n        return this;\n    }\n    /**\n     * Gets a new Vector2 copied from the Vector2\n     * @returns a new Vector2\n     */\n    clone() {\n        return new Vector2(this.x, this.y);\n    }\n}\nexports.Vector2 = Vector2;\n//# sourceMappingURL=Vector2.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Vector2.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Vector3.js":
/*!****************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Vector3.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Vector3 = void 0;\nconst preallocatedVariables_1 = __webpack_require__(/*! ./preallocatedVariables */ \"./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\nconst Quaternion_1 = __webpack_require__(/*! ./Quaternion */ \"./node_modules/@dcl/ecs-math/dist/Quaternion.js\");\nconst Scalar_1 = __webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\");\n/**\n * Classed used to store (x,y,z) vector representation\n * A Vector3 is the main object used in 3D geometry\n * It can represent etiher the coordinates of a point the space, either a direction\n * Reminder: Babylon.js uses a left handed forward facing system\n * @public\n */\nclass Vector3 {\n    /**\n     * Creates a new Vector3 object from the given x, y, z (floats) coordinates.\n     * @param x - defines the first coordinates (on X axis)\n     * @param y - defines the second coordinates (on Y axis)\n     * @param z - defines the third coordinates (on Z axis)\n     */\n    constructor(\n    /**\n     * Defines the first coordinates (on X axis)\n     */\n    x = 0, \n    /**\n     * Defines the second coordinates (on Y axis)\n     */\n    y = 0, \n    /**\n     * Defines the third coordinates (on Z axis)\n     */\n    z = 0) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n    }\n    /**\n     * Gets a boolean indicating that the vector is non uniform meaning x, y or z are not all the same\n     */\n    get isNonUniform() {\n        const absX = Math.abs(this.x);\n        const absY = Math.abs(this.y);\n        if (absX !== absY) {\n            return true;\n        }\n        const absZ = Math.abs(this.z);\n        if (absX !== absZ) {\n            return true;\n        }\n        if (absY !== absZ) {\n            return true;\n        }\n        return false;\n    }\n    // Statics\n    /**\n     * Returns a new Vector3 as the result of the addition of the two given vectors.\n     * @param vector1 - the first vector\n     * @param vector2 - the second vector\n     * @returns the resulting vector\n     */\n    static Add(vector1, vector2) {\n        return new Vector3(vector1.x, vector1.y, vector1.z).addInPlace(vector2);\n    }\n    /**\n     * Get the clip factor between two vectors\n     * @param vector0 - defines the first operand\n     * @param vector1 - defines the second operand\n     * @param axis - defines the axis to use\n     * @param size - defines the size along the axis\n     * @returns the clip factor\n     */\n    static GetClipFactor(vector0, vector1, axis, size) {\n        const d0 = Vector3.Dot(vector0, axis) - size;\n        const d1 = Vector3.Dot(vector1, axis) - size;\n        const s = d0 / (d0 - d1);\n        return s;\n    }\n    /**\n     * Get angle between two vectors\n     * @param vector0 - angle between vector0 and vector1\n     * @param vector1 - angle between vector0 and vector1\n     * @param normal - direction of the normal\n     * @returns the angle between vector0 and vector1\n     */\n    static GetAngleBetweenVectors(vector0, vector1, normal) {\n        const v0 = vector0.normalizeToRef(preallocatedVariables_1.MathTmp.Vector3[1]);\n        const v1 = vector1.normalizeToRef(preallocatedVariables_1.MathTmp.Vector3[2]);\n        const dot = Vector3.Dot(v0, v1);\n        const n = preallocatedVariables_1.MathTmp.Vector3[3];\n        Vector3.CrossToRef(v0, v1, n);\n        if (Vector3.Dot(n, normal) > 0) {\n            return Math.acos(dot);\n        }\n        return -Math.acos(dot);\n    }\n    /**\n     * Returns a new Vector3 set from the index \"offset\" of the given array\n     * @param array - defines the source array\n     * @param offset - defines the offset in the source array\n     * @returns the new Vector3\n     */\n    static FromArray(array, offset = 0) {\n        return new Vector3(array[offset], array[offset + 1], array[offset + 2]);\n    }\n    /**\n     * Returns a new Vector3 set from the index \"offset\" of the given FloatArray\n     * This function is deprecated.  Use FromArray instead\n     * @param array - defines the source array\n     * @param offset - defines the offset in the source array\n     * @returns the new Vector3\n     */\n    static FromFloatArray(array, offset) {\n        return Vector3.FromArray(array, offset);\n    }\n    /**\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given array\n     * @param array - defines the source array\n     * @param offset - defines the offset in the source array\n     * @param result - defines the Vector3 where to store the result\n     */\n    static FromArrayToRef(array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n        result.z = array[offset + 2];\n    }\n    /**\n     * Sets the given vector \"result\" with the element values from the index \"offset\" of the given FloatArray\n     * This function is deprecated.  Use FromArrayToRef instead.\n     * @param array - defines the source array\n     * @param offset - defines the offset in the source array\n     * @param result - defines the Vector3 where to store the result\n     */\n    static FromFloatArrayToRef(array, offset, result) {\n        return Vector3.FromArrayToRef(array, offset, result);\n    }\n    /**\n     * Sets the given vector \"result\" with the given floats.\n     * @param x - defines the x coordinate of the source\n     * @param y - defines the y coordinate of the source\n     * @param z - defines the z coordinate of the source\n     * @param result - defines the Vector3 where to store the result\n     */\n    static FromFloatsToRef(x, y, z, result) {\n        result.copyFromFloats(x, y, z);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, 0.0)\n     * @returns a new empty Vector3\n     */\n    static Zero() {\n        return new Vector3(0.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set to (1.0, 1.0, 1.0)\n     * @returns a new unit Vector3\n     */\n    static One() {\n        return new Vector3(1.0, 1.0, 1.0);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 1.0, 0.0)\n     * @returns a new up Vector3\n     */\n    static Up() {\n        return new Vector3(0.0, 1.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, -1.0, 0.0)\n     * @returns a new down Vector3\n     */\n    static Down() {\n        return new Vector3(0.0, -1.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, 1.0)\n     * @returns a new forward Vector3\n     */\n    static Forward() {\n        return new Vector3(0.0, 0.0, 1.0);\n    }\n    /**\n     * Returns a new Vector3 set to (0.0, 0.0, -1.0)\n     * @returns a new forward Vector3\n     */\n    static Backward() {\n        return new Vector3(0.0, 0.0, -1.0);\n    }\n    /**\n     * Returns a new Vector3 set to (1.0, 0.0, 0.0)\n     * @returns a new right Vector3\n     */\n    static Right() {\n        return new Vector3(1.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set to (-1.0, 0.0, 0.0)\n     * @returns a new left Vector3\n     */\n    static Left() {\n        return new Vector3(-1.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector3 set with the result of the transformation by the given matrix of the given vector.\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * @param vector - defines the Vector3 to transform\n     * @param transformation - defines the transformation matrix\n     * @returns the transformed Vector3\n     */\n    static TransformCoordinates(vector, transformation) {\n        const result = Vector3.Zero();\n        Vector3.TransformCoordinatesToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given vector\n     * This method computes tranformed coordinates only, not transformed direction vectors (ie. it takes translation in account)\n     * @param vector - defines the Vector3 to transform\n     * @param transformation - defines the transformation matrix\n     * @param result - defines the Vector3 where to store the result\n     */\n    static TransformCoordinatesToRef(vector, transformation, result) {\n        return Vector3.TransformCoordinatesFromFloatsToRef(vector.x, vector.y, vector.z, transformation, result);\n    }\n    /**\n     * Sets the given vector \"result\" coordinates with the result of the transformation by the given matrix of the given floats (x, y, z)\n     * This method computes tranformed coordinates only, not transformed direction vectors\n     * @param x - define the x coordinate of the source vector\n     * @param y - define the y coordinate of the source vector\n     * @param z - define the z coordinate of the source vector\n     * @param transformation - defines the transformation matrix\n     * @param result - defines the Vector3 where to store the result\n     */\n    static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {\n        const m = transformation.m;\n        const rx = x * m[0] + y * m[4] + z * m[8] + m[12];\n        const ry = x * m[1] + y * m[5] + z * m[9] + m[13];\n        const rz = x * m[2] + y * m[6] + z * m[10] + m[14];\n        const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);\n        result.x = rx * rw;\n        result.y = ry * rw;\n        result.z = rz * rw;\n    }\n    /**\n     * Returns a new Vector3 set with the result of the normal transformation by the given matrix of the given vector\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * @param vector - defines the Vector3 to transform\n     * @param transformation - defines the transformation matrix\n     * @returns the new Vector3\n     */\n    static TransformNormal(vector, transformation) {\n        const result = Vector3.Zero();\n        Vector3.TransformNormalToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * @param vector - defines the Vector3 to transform\n     * @param transformation - defines the transformation matrix\n     * @param result - defines the Vector3 where to store the result\n     */\n    static TransformNormalToRef(vector, transformation, result) {\n        this.TransformNormalFromFloatsToRef(vector.x, vector.y, vector.z, transformation, result);\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z)\n     * This methods computes transformed normalized direction vectors only (ie. it does not apply translation)\n     * @param x - define the x coordinate of the source vector\n     * @param y - define the y coordinate of the source vector\n     * @param z - define the z coordinate of the source vector\n     * @param transformation - defines the transformation matrix\n     * @param result - defines the Vector3 where to store the result\n     */\n    static TransformNormalFromFloatsToRef(x, y, z, transformation, result) {\n        const m = transformation.m;\n        result.x = x * m[0] + y * m[4] + z * m[8];\n        result.y = x * m[1] + y * m[5] + z * m[9];\n        result.z = x * m[2] + y * m[6] + z * m[10];\n    }\n    /**\n     * Returns a new Vector3 located for \"amount\" on the CatmullRom interpolation spline defined by the vectors \"value1\", \"value2\", \"value3\", \"value4\"\n     * @param value1 - defines the first control point\n     * @param value2 - defines the second control point\n     * @param value3 - defines the third control point\n     * @param value4 - defines the fourth control point\n     * @param amount - defines the amount on the spline to use\n     * @returns the new Vector3\n     */\n    static CatmullRom(value1, value2, value3, value4, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const x = 0.5 *\n            (2.0 * value2.x +\n                (-value1.x + value3.x) * amount +\n                (2.0 * value1.x - 5.0 * value2.x + 4.0 * value3.x - value4.x) *\n                    squared +\n                (-value1.x + 3.0 * value2.x - 3.0 * value3.x + value4.x) * cubed);\n        const y = 0.5 *\n            (2.0 * value2.y +\n                (-value1.y + value3.y) * amount +\n                (2.0 * value1.y - 5.0 * value2.y + 4.0 * value3.y - value4.y) *\n                    squared +\n                (-value1.y + 3.0 * value2.y - 3.0 * value3.y + value4.y) * cubed);\n        const z = 0.5 *\n            (2.0 * value2.z +\n                (-value1.z + value3.z) * amount +\n                (2.0 * value1.z - 5.0 * value2.z + 4.0 * value3.z - value4.z) *\n                    squared +\n                (-value1.z + 3.0 * value2.z - 3.0 * value3.z + value4.z) * cubed);\n        return new Vector3(x, y, z);\n    }\n    /**\n     * Returns a new Vector3 set with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n     * @param value - defines the current value\n     * @param min - defines the lower range value\n     * @param max - defines the upper range value\n     * @returns the new Vector3\n     */\n    static Clamp(value, min, max) {\n        const v = new Vector3();\n        Vector3.ClampToRef(value, min, max, v);\n        return v;\n    }\n    /**\n     * Sets the given vector \"result\" with the coordinates of \"value\", if the vector \"value\" is in the cube defined by the vectors \"min\" and \"max\"\n     * If a coordinate value of \"value\" is lower than one of the \"min\" coordinate, then this \"value\" coordinate is set with the \"min\" one\n     * If a coordinate value of \"value\" is greater than one of the \"max\" coordinate, then this \"value\" coordinate is set with the \"max\" one\n     * @param value - defines the current value\n     * @param min - defines the lower range value\n     * @param max - defines the upper range value\n     * @param result - defines the Vector3 where to store the result\n     */\n    static ClampToRef(value, min, max, result) {\n        let x = value.x;\n        x = x > max.x ? max.x : x;\n        x = x < min.x ? min.x : x;\n        let y = value.y;\n        y = y > max.y ? max.y : y;\n        y = y < min.y ? min.y : y;\n        let z = value.z;\n        z = z > max.z ? max.z : z;\n        z = z < min.z ? min.z : z;\n        result.copyFromFloats(x, y, z);\n    }\n    /**\n     * Returns a new Vector3 located for \"amount\" (float) on the Hermite interpolation spline defined by the vectors \"value1\", \"tangent1\", \"value2\", \"tangent2\"\n     * @param value1 - defines the first control point\n     * @param tangent1 - defines the first tangent vector\n     * @param value2 - defines the second control point\n     * @param tangent2 - defines the second tangent vector\n     * @param amount - defines the amount on the interpolation spline (between 0 and 1)\n     * @returns the new Vector3\n     */\n    static Hermite(value1, tangent1, value2, tangent2, amount) {\n        const squared = amount * amount;\n        const cubed = amount * squared;\n        const part1 = 2.0 * cubed - 3.0 * squared + 1.0;\n        const part2 = -2.0 * cubed + 3.0 * squared;\n        const part3 = cubed - 2.0 * squared + amount;\n        const part4 = cubed - squared;\n        const x = value1.x * part1 +\n            value2.x * part2 +\n            tangent1.x * part3 +\n            tangent2.x * part4;\n        const y = value1.y * part1 +\n            value2.y * part2 +\n            tangent1.y * part3 +\n            tangent2.y * part4;\n        const z = value1.z * part1 +\n            value2.z * part2 +\n            tangent1.z * part3 +\n            tangent2.z * part4;\n        return new Vector3(x, y, z);\n    }\n    /**\n     * Returns a new Vector3 located for \"amount\" (float) on the linear interpolation between the vectors \"start\" and \"end\"\n     * @param start - defines the start value\n     * @param end - defines the end value\n     * @param amount - max defines amount between both (between 0 and 1)\n     * @returns the new Vector3\n     */\n    static Lerp(start, end, amount) {\n        const result = new Vector3(0, 0, 0);\n        Vector3.LerpToRef(start, end, amount, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the linear interpolation from the vector \"start\" for \"amount\" to the vector \"end\"\n     * @param start - defines the start value\n     * @param end - defines the end value\n     * @param amount - max defines amount between both (between 0 and 1)\n     * @param result - defines the Vector3 where to store the result\n     */\n    static LerpToRef(start, end, amount, result) {\n        result.x = start.x + (end.x - start.x) * amount;\n        result.y = start.y + (end.y - start.y) * amount;\n        result.z = start.z + (end.z - start.z) * amount;\n    }\n    /**\n     * Returns the dot product (float) between the vectors \"left\" and \"right\"\n     * @param left - defines the left operand\n     * @param right - defines the right operand\n     * @returns the dot product\n     */\n    static Dot(left, right) {\n        return left.x * right.x + left.y * right.y + left.z * right.z;\n    }\n    /**\n     * Returns a new Vector3 as the cross product of the vectors \"left\" and \"right\"\n     * The cross product is then orthogonal to both \"left\" and \"right\"\n     * @param left - defines the left operand\n     * @param right - defines the right operand\n     * @returns the cross product\n     */\n    static Cross(left, right) {\n        const result = Vector3.Zero();\n        Vector3.CrossToRef(left, right, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the cross product of \"left\" and \"right\"\n     * The cross product is then orthogonal to both \"left\" and \"right\"\n     * @param left - defines the left operand\n     * @param right - defines the right operand\n     * @param result - defines the Vector3 where to store the result\n     */\n    static CrossToRef(left, right, result) {\n        const x = left.y * right.z - left.z * right.y;\n        const y = left.z * right.x - left.x * right.z;\n        const z = left.x * right.y - left.y * right.x;\n        result.copyFromFloats(x, y, z);\n    }\n    /**\n     * Returns a new Vector3 as the normalization of the given vector\n     * @param vector - defines the Vector3 to normalize\n     * @returns the new Vector3\n     */\n    static Normalize(vector) {\n        const result = Vector3.Zero();\n        Vector3.NormalizeToRef(vector, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the normalization of the given first vector\n     * @param vector - defines the Vector3 to normalize\n     * @param result - defines the Vector3 where to store the result\n     */\n    static NormalizeToRef(vector, result) {\n        vector.normalizeToRef(result);\n    }\n    /**\n     * Gets the minimal coordinate values between two Vector3\n     * @param left - defines the first operand\n     * @param right - defines the second operand\n     * @returns the new Vector3\n     */\n    static Minimize(left, right) {\n        const min = new Vector3(left.x, left.y, left.z);\n        min.minimizeInPlace(right);\n        return min;\n    }\n    /**\n     * Gets the maximal coordinate values between two Vector3\n     * @param left - defines the first operand\n     * @param right - defines the second operand\n     * @returns the new Vector3\n     */\n    static Maximize(left, right) {\n        const max = new Vector3(left.x, left.y, left.z);\n        max.maximizeInPlace(right);\n        return max;\n    }\n    /**\n     * Returns the distance between the vectors \"value1\" and \"value2\"\n     * @param value1 - defines the first operand\n     * @param value2 - defines the second operand\n     * @returns the distance\n     */\n    static Distance(value1, value2) {\n        return Math.sqrt(Vector3.DistanceSquared(value1, value2));\n    }\n    /**\n     * Returns the squared distance between the vectors \"value1\" and \"value2\"\n     * @param value1 - defines the first operand\n     * @param value2 - defines the second operand\n     * @returns the squared distance\n     */\n    static DistanceSquared(value1, value2) {\n        const x = value1.x - value2.x;\n        const y = value1.y - value2.y;\n        const z = value1.z - value2.z;\n        return x * x + y * y + z * z;\n    }\n    /**\n     * Returns a new Vector3 located at the center between \"value1\" and \"value2\"\n     * @param value1 - defines the first operand\n     * @param value2 - defines the second operand\n     * @returns the new Vector3\n     */\n    static Center(value1, value2) {\n        const center = Vector3.Add(value1, value2);\n        center.scaleInPlace(0.5);\n        return center;\n    }\n    /**\n     * Given three orthogonal normalized left-handed oriented Vector3 axis in space (target system),\n     * RotationFromAxis() returns the rotation Euler angles (ex : rotation.x, rotation.y, rotation.z) to apply\n     * to something in order to rotate it from its local system to the given target system\n     * Note: axis1, axis2 and axis3 are normalized during this operation\n     * @param axis1 - defines the first axis\n     * @param axis2 - defines the second axis\n     * @param axis3 - defines the third axis\n     * @returns a new Vector3\n     */\n    static RotationFromAxis(axis1, axis2, axis3) {\n        const rotation = Vector3.Zero();\n        Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);\n        return rotation;\n    }\n    /**\n     * The same than RotationFromAxis but updates the given ref Vector3 parameter instead of returning a new Vector3\n     * @param axis1 - defines the first axis\n     * @param axis2 - defines the second axis\n     * @param axis3 - defines the third axis\n     * @param ref - defines the Vector3 where to store the result\n     */\n    static RotationFromAxisToRef(axis1, axis2, axis3, ref) {\n        const quat = preallocatedVariables_1.MathTmp.Quaternion[0];\n        Quaternion_1.Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);\n        ref.copyFrom(quat.eulerAngles);\n    }\n    /**\n     * Creates a string representation of the Vector3\n     * @returns a string with the Vector3 coordinates.\n     */\n    toString() {\n        return `(${this.x}, ${this.y}, ${this.z})`;\n    }\n    /**\n     * Gets the class name\n     * @returns the string \"Vector3\"\n     */\n    getClassName() {\n        return 'Vector3';\n    }\n    /**\n     * Creates the Vector3 hash code\n     * @returns a number which tends to be unique between Vector3 instances\n     */\n    getHashCode() {\n        let hash = this.x || 0;\n        hash = (hash * 397) ^ (this.y || 0);\n        hash = (hash * 397) ^ (this.z || 0);\n        return hash;\n    }\n    // Operators\n    /**\n     * Creates an array containing three elements : the coordinates of the Vector3\n     * @returns a new array of numbers\n     */\n    asArray() {\n        const result = [];\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Populates the given array or FloatArray from the given index with the successive coordinates of the Vector3\n     * @param array - defines the destination array\n     * @param index - defines the offset in the destination array\n     * @returns the current Vector3\n     */\n    toArray(array, index = 0) {\n        array[index] = this.x;\n        array[index + 1] = this.y;\n        array[index + 2] = this.z;\n        return this;\n    }\n    /**\n     * Converts the current Vector3 into a quaternion (considering that the Vector3 contains Euler angles representation of a rotation)\n     * @returns a new Quaternion object, computed from the Vector3 coordinates\n     */\n    toQuaternion() {\n        return Quaternion_1.Quaternion.Identity.setEuler(this.y, this.x, this.z);\n    }\n    /**\n     * Adds the given vector to the current Vector3\n     * @param otherVector - defines the second operand\n     * @returns the current updated Vector3\n     */\n    addInPlace(otherVector) {\n        return this.addInPlaceFromFloats(otherVector.x, otherVector.y, otherVector.z);\n    }\n    /**\n     * Adds the given coordinates to the current Vector3\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    addInPlaceFromFloats(x, y, z) {\n        this.x += x;\n        this.y += y;\n        this.z += z;\n        return this;\n    }\n    /**\n     * Gets a new Vector3, result of the addition the current Vector3 and the given vector\n     * @param otherVector - defines the second operand\n     * @returns the resulting Vector3\n     */\n    add(otherVector) {\n        return new Vector3(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\n    }\n    /**\n     * Adds the current Vector3 to the given one and stores the result in the vector \"result\"\n     * @param otherVector - defines the second operand\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    addToRef(otherVector, result) {\n        return result.copyFromFloats(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z);\n    }\n    /**\n     * Subtract the given vector from the current Vector3\n     * @param otherVector - defines the second operand\n     * @returns the current updated Vector3\n     */\n    subtractInPlace(otherVector) {\n        this.x -= otherVector.x;\n        this.y -= otherVector.y;\n        this.z -= otherVector.z;\n        return this;\n    }\n    /**\n     * Returns a new Vector3, result of the subtraction of the given vector from the current Vector3\n     * @param otherVector - defines the second operand\n     * @returns the resulting Vector3\n     */\n    subtract(otherVector) {\n        return new Vector3(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z);\n    }\n    /**\n     * Subtracts the given vector from the current Vector3 and stores the result in the vector \"result\".\n     * @param otherVector - defines the second operand\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    subtractToRef(otherVector, result) {\n        return this.subtractFromFloatsToRef(otherVector.x, otherVector.y, otherVector.z, result);\n    }\n    /**\n     * Returns a new Vector3 set with the subtraction of the given floats from the current Vector3 coordinates\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns the resulting Vector3\n     */\n    subtractFromFloats(x, y, z) {\n        return new Vector3(this.x - x, this.y - y, this.z - z);\n    }\n    /**\n     * Subtracts the given floats from the current Vector3 coordinates and set the given vector \"result\" with this result\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    subtractFromFloatsToRef(x, y, z, result) {\n        return result.copyFromFloats(this.x - x, this.y - y, this.z - z);\n    }\n    /**\n     * Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective\n     * @param matrix - The transformation matrix\n     */\n    applyMatrix4(matrix) {\n        this.applyMatrix4ToRef(matrix, this);\n    }\n    /**\n     * Multiplies this vector (with an implicit 1 in the 4th dimension) and m, and divides by perspective and set the given vector \"result\" with this result\n     * @param matrix - The transformation matrix\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    applyMatrix4ToRef(matrix, result) {\n        const { x, y, z } = this;\n        const { m } = matrix;\n        const w = 1 / (m[3] * x + m[7] * y + m[11] * z + m[15]);\n        result.x = (m[0] * x + m[4] * y + m[8] * z + m[12]) * w;\n        result.y = (m[1] * x + m[5] * y + m[9] * z + m[13]) * w;\n        result.z = (m[2] * x + m[6] * y + m[10] * z + m[14]) * w;\n        return result;\n    }\n    /**\n     * Rotates the current Vector3 based on the given quaternion\n     * @param q - defines the Quaternion\n     * @returns the current Vector3\n     */\n    rotate(q) {\n        return this.rotateToRef(q, this);\n    }\n    /**\n     * Rotates current Vector3 based on the given quaternion, but applies the rotation to target Vector3.\n     * @param q - defines the Quaternion\n     * @param result - defines the target Vector3\n     * @returns the current Vector3\n     */\n    rotateToRef(q, result) {\n        const { x, y, z } = this;\n        const { x: qx, y: qy, z: qz, w: qw } = q;\n        // calculate quat * vector\n        const ix = qw * x + qy * z - qz * y;\n        const iy = qw * y + qz * x - qx * z;\n        const iz = qw * z + qx * y - qy * x;\n        const iw = -qx * x - qy * y - qz * z;\n        // calculate result * inverse quat\n        result.x = ix * qw + iw * -qx + iy * -qz - iz * -qy;\n        result.y = iy * qw + iw * -qy + iz * -qx - ix * -qz;\n        result.z = iz * qw + iw * -qz + ix * -qy - iy * -qx;\n        return result;\n    }\n    /**\n     * Gets a new Vector3 set with the current Vector3 negated coordinates\n     * @returns a new Vector3\n     */\n    negate() {\n        return new Vector3(-this.x, -this.y, -this.z);\n    }\n    /**\n     * Multiplies the Vector3 coordinates by the float \"scale\"\n     * @param scale - defines the multiplier factor\n     * @returns the current updated Vector3\n     */\n    scaleInPlace(scale) {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n        return this;\n    }\n    /**\n     * Returns a new Vector3 set with the current Vector3 coordinates multiplied by the float \"scale\"\n     * @param scale - defines the multiplier factor\n     * @returns a new Vector3\n     */\n    scale(scale) {\n        return new Vector3(this.x * scale, this.y * scale, this.z * scale);\n    }\n    /**\n     * Multiplies the current Vector3 coordinates by the float \"scale\" and stores the result in the given vector \"result\" coordinates\n     * @param scale - defines the multiplier factor\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    scaleToRef(scale, result) {\n        return result.copyFromFloats(this.x * scale, this.y * scale, this.z * scale);\n    }\n    /**\n     * Scale the current Vector3 values by a factor and add the result to a given Vector3\n     * @param scale - defines the scale factor\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the unmodified current Vector3\n     */\n    scaleAndAddToRef(scale, result) {\n        return result.addInPlaceFromFloats(this.x * scale, this.y * scale, this.z * scale);\n    }\n    /**\n     * Returns true if the current Vector3 and the given vector coordinates are strictly equal\n     * @param otherVector - defines the second operand\n     * @returns true if both vectors are equals\n     */\n    equals(otherVector) {\n        return (otherVector &&\n            this.x === otherVector.x &&\n            this.y === otherVector.y &&\n            this.z === otherVector.z);\n    }\n    /**\n     * Returns true if the current Vector3 and the given vector coordinates are distant less than epsilon\n     * @param otherVector - defines the second operand\n     * @param epsilon - defines the minimal distance to define values as equals\n     * @returns true if both vectors are distant less than epsilon\n     */\n    equalsWithEpsilon(otherVector, epsilon = types_1.Epsilon) {\n        return (otherVector &&\n            Scalar_1.Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n            Scalar_1.Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) &&\n            Scalar_1.Scalar.WithinEpsilon(this.z, otherVector.z, epsilon));\n    }\n    /**\n     * Returns true if the current Vector3 coordinates equals the given floats\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns true if both vectors are equals\n     */\n    equalsToFloats(x, y, z) {\n        return this.x === x && this.y === y && this.z === z;\n    }\n    /**\n     * Multiplies the current Vector3 coordinates by the given ones\n     * @param otherVector - defines the second operand\n     * @returns the current updated Vector3\n     */\n    multiplyInPlace(otherVector) {\n        this.x *= otherVector.x;\n        this.y *= otherVector.y;\n        this.z *= otherVector.z;\n        return this;\n    }\n    /**\n     * Returns a new Vector3, result of the multiplication of the current Vector3 by the given vector\n     * @param otherVector - defines the second operand\n     * @returns the new Vector3\n     */\n    multiply(otherVector) {\n        return this.multiplyByFloats(otherVector.x, otherVector.y, otherVector.z);\n    }\n    /**\n     * Multiplies the current Vector3 by the given one and stores the result in the given vector \"result\"\n     * @param otherVector - defines the second operand\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    multiplyToRef(otherVector, result) {\n        return result.copyFromFloats(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z);\n    }\n    /**\n     * Returns a new Vector3 set with the result of the mulliplication of the current Vector3 coordinates by the given floats\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns the new Vector3\n     */\n    multiplyByFloats(x, y, z) {\n        return new Vector3(this.x * x, this.y * y, this.z * z);\n    }\n    /**\n     * Returns a new Vector3 set with the result of the division of the current Vector3 coordinates by the given ones\n     * @param otherVector - defines the second operand\n     * @returns the new Vector3\n     */\n    divide(otherVector) {\n        return new Vector3(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z);\n    }\n    /**\n     * Divides the current Vector3 coordinates by the given ones and stores the result in the given vector \"result\"\n     * @param otherVector - defines the second operand\n     * @param result - defines the Vector3 object where to store the result\n     * @returns the current Vector3\n     */\n    divideToRef(otherVector, result) {\n        return result.copyFromFloats(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z);\n    }\n    /**\n     * Divides the current Vector3 coordinates by the given ones.\n     * @param otherVector - defines the second operand\n     * @returns the current updated Vector3\n     */\n    divideInPlace(otherVector) {\n        return this.divideToRef(otherVector, this);\n    }\n    /**\n     * Updates the current Vector3 with the minimal coordinate values between its and the given vector ones\n     * @param other - defines the second operand\n     * @returns the current updated Vector3\n     */\n    minimizeInPlace(other) {\n        return this.minimizeInPlaceFromFloats(other.x, other.y, other.z);\n    }\n    /**\n     * Updates the current Vector3 with the maximal coordinate values between its and the given vector ones.\n     * @param other - defines the second operand\n     * @returns the current updated Vector3\n     */\n    maximizeInPlace(other) {\n        return this.maximizeInPlaceFromFloats(other.x, other.y, other.z);\n    }\n    /**\n     * Updates the current Vector3 with the minimal coordinate values between its and the given coordinates\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    minimizeInPlaceFromFloats(x, y, z) {\n        if (x < this.x) {\n            this.x = x;\n        }\n        if (y < this.y) {\n            this.y = y;\n        }\n        if (z < this.z) {\n            this.z = z;\n        }\n        return this;\n    }\n    /**\n     * Updates the current Vector3 with the maximal coordinate values between its and the given coordinates.\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    maximizeInPlaceFromFloats(x, y, z) {\n        if (x > this.x) {\n            this.x = x;\n        }\n        if (y > this.y) {\n            this.y = y;\n        }\n        if (z > this.z) {\n            this.z = z;\n        }\n        return this;\n    }\n    /**\n     * Gets a new Vector3 from current Vector3 floored values\n     * @returns a new Vector3\n     */\n    floor() {\n        return new Vector3(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z));\n    }\n    /**\n     * Gets a new Vector3 from current Vector3 floored values\n     * @returns a new Vector3\n     */\n    fract() {\n        return new Vector3(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z));\n    }\n    // Properties\n    /**\n     * Gets the length of the Vector3\n     * @returns the length of the Vecto3\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);\n    }\n    /**\n     * Gets the squared length of the Vector3\n     * @returns squared length of the Vector3\n     */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z;\n    }\n    /**\n     * Normalize the current Vector3.\n     * Please note that this is an in place operation.\n     * @returns the current updated Vector3\n     */\n    normalize() {\n        return this.normalizeFromLength(this.length());\n    }\n    /**\n     * Normalize the current Vector3 with the given input length.\n     * Please note that this is an in place operation.\n     * @param len - the length of the vector\n     * @returns the current updated Vector3\n     */\n    normalizeFromLength(len) {\n        if (len === 0 || len === 1.0) {\n            return this;\n        }\n        return this.scaleInPlace(1.0 / len);\n    }\n    /**\n     * Normalize the current Vector3 to a new vector\n     * @returns the new Vector3\n     */\n    normalizeToNew() {\n        const normalized = new Vector3(0, 0, 0);\n        this.normalizeToRef(normalized);\n        return normalized;\n    }\n    /**\n     * Normalize the current Vector3 to the reference\n     * @param reference - define the Vector3 to update\n     * @returns the updated Vector3\n     */\n    normalizeToRef(reference) {\n        const len = this.length();\n        if (len === 0 || len === 1.0) {\n            return reference.copyFromFloats(this.x, this.y, this.z);\n        }\n        return this.scaleToRef(1.0 / len, reference);\n    }\n    /**\n     * Creates a new Vector3 copied from the current Vector3\n     * @returns the new Vector3\n     */\n    clone() {\n        return new Vector3(this.x, this.y, this.z);\n    }\n    /**\n     * Copies the given vector coordinates to the current Vector3 ones\n     * @param source - defines the source Vector3\n     * @returns the current updated Vector3\n     */\n    copyFrom(source) {\n        return this.copyFromFloats(source.x, source.y, source.z);\n    }\n    /**\n     * Copies the given floats to the current Vector3 coordinates\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    copyFromFloats(x, y, z) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        return this;\n    }\n    /**\n     * Copies the given floats to the current Vector3 coordinates\n     * @param x - defines the x coordinate of the operand\n     * @param y - defines the y coordinate of the operand\n     * @param z - defines the z coordinate of the operand\n     * @returns the current updated Vector3\n     */\n    set(x, y, z) {\n        return this.copyFromFloats(x, y, z);\n    }\n    /**\n     * Copies the given float to the current Vector3 coordinates\n     * @param v - defines the x, y and z coordinates of the operand\n     * @returns the current updated Vector3\n     */\n    setAll(v) {\n        this.x = this.y = this.z = v;\n        return this;\n    }\n}\nexports.Vector3 = Vector3;\n//# sourceMappingURL=Vector3.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Vector3.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/Vector4.js":
/*!****************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/Vector4.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Vector4 = void 0;\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\");\nconst Scalar_1 = __webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\");\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\n/**\n * Vector4 class created for EulerAngle class conversion to Quaternion\n * @public\n */\nclass Vector4 {\n    /**\n     * Creates a Vector4 object from the given floats.\n     * @param x - x value of the vector\n     * @param y - y value of the vector\n     * @param z - z value of the vector\n     * @param w - w value of the vector\n     */\n    constructor(\n    /** x value of the vector */\n    x, \n    /** y value of the vector */\n    y, \n    /** z value of the vector */\n    z, \n    /** w value of the vector */\n    w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n    }\n    // Statics\n    /**\n     * Returns a new Vector4 as the result of the addition of the two given vectors.\n     * @param vector1 - the first vector\n     * @param vector2 - the second vector\n     * @returns the resulting vector\n     */\n    static Add(vector1, vector2) {\n        return new Vector4(vector1.x, vector1.y, vector1.z, vector1.w).addInPlace(vector2);\n    }\n    /**\n     * Returns a new Vector4 set from the starting index of the given array.\n     * @param array - the array to pull values from\n     * @param offset - the offset into the array to start at\n     * @returns the new vector\n     */\n    static FromArray(array, offset = 0) {\n        return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);\n    }\n    /**\n     * Updates the given vector \"result\" from the starting index of the given array.\n     * @param array - the array to pull values from\n     * @param offset - the offset into the array to start at\n     * @param result - the vector to store the result in\n     */\n    static FromArrayToRef(array, offset, result) {\n        result.x = array[offset];\n        result.y = array[offset + 1];\n        result.z = array[offset + 2];\n        result.w = array[offset + 3];\n    }\n    /**\n     * Updates the given vector \"result\" from the starting index of the given FloatArray.\n     * @param array - the array to pull values from\n     * @param offset - the offset into the array to start at\n     * @param result - the vector to store the result in\n     */\n    static FromFloatArrayToRef(array, offset, result) {\n        Vector4.FromArrayToRef(array, offset, result);\n    }\n    /**\n     * Updates the given vector \"result\" coordinates from the given floats.\n     * @param x - float to set from\n     * @param y - float to set from\n     * @param z - float to set from\n     * @param w - float to set from\n     * @param result - the vector to the floats in\n     */\n    static FromFloatsToRef(x, y, z, w, result) {\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = w;\n    }\n    /**\n     * Returns a new Vector4 set to (0.0, 0.0, 0.0, 0.0)\n     * @returns the new vector\n     */\n    static Zero() {\n        return new Vector4(0.0, 0.0, 0.0, 0.0);\n    }\n    /**\n     * Returns a new Vector4 set to (1.0, 1.0, 1.0, 1.0)\n     * @returns the new vector\n     */\n    static One() {\n        return new Vector4(1.0, 1.0, 1.0, 1.0);\n    }\n    /**\n     * Returns a new normalized Vector4 from the given one.\n     * @param vector - the vector to normalize\n     * @returns the vector\n     */\n    static Normalize(vector) {\n        const result = Vector4.Zero();\n        Vector4.NormalizeToRef(vector, result);\n        return result;\n    }\n    /**\n     * Updates the given vector \"result\" from the normalization of the given one.\n     * @param vector - the vector to normalize\n     * @param result - the vector to store the result in\n     */\n    static NormalizeToRef(vector, result) {\n        result.copyFrom(vector);\n        result.normalize();\n    }\n    /**\n     * Returns a vector with the minimum values from the left and right vectors\n     * @param left - left vector to minimize\n     * @param right - right vector to minimize\n     * @returns a new vector with the minimum of the left and right vector values\n     */\n    static Minimize(left, right) {\n        const min = new Vector4(left.x, left.y, left.z, left.w);\n        min.minimizeInPlace(right);\n        return min;\n    }\n    /**\n     * Returns a vector with the maximum values from the left and right vectors\n     * @param left - left vector to maximize\n     * @param right - right vector to maximize\n     * @returns a new vector with the maximum of the left and right vector values\n     */\n    static Maximize(left, right) {\n        const max = new Vector4(left.x, left.y, left.z, left.w);\n        max.maximizeInPlace(right);\n        return max;\n    }\n    /**\n     * Returns the distance (float) between the vectors \"value1\" and \"value2\".\n     * @param value1 - value to calulate the distance between\n     * @param value2 - value to calulate the distance between\n     * @returns the distance between the two vectors\n     */\n    static Distance(value1, value2) {\n        return Math.sqrt(Vector4.DistanceSquared(value1, value2));\n    }\n    /**\n     * Returns the squared distance (float) between the vectors \"value1\" and \"value2\".\n     * @param value1 - value to calulate the distance between\n     * @param value2 - value to calulate the distance between\n     * @returns the distance between the two vectors squared\n     */\n    static DistanceSquared(value1, value2) {\n        const x = value1.x - value2.x;\n        const y = value1.y - value2.y;\n        const z = value1.z - value2.z;\n        const w = value1.w - value2.w;\n        return x * x + y * y + z * z + w * w;\n    }\n    /**\n     * Returns a new Vector4 located at the center between the vectors \"value1\" and \"value2\".\n     * @param value1 - value to calulate the center between\n     * @param value2 - value to calulate the center between\n     * @returns the center between the two vectors\n     */\n    static Center(value1, value2) {\n        const center = Vector4.Add(value1, value2);\n        center.scaleInPlace(0.5);\n        return center;\n    }\n    /**\n     * Returns a new Vector4 set with the result of the normal transformation by the given matrix of the given vector.\n     * This methods computes transformed normalized direction vectors only.\n     * @param vector - the vector to transform\n     * @param transformation - the transformation matrix to apply\n     * @returns the new vector\n     */\n    static TransformNormal(vector, transformation) {\n        const result = Vector4.Zero();\n        Vector4.TransformNormalToRef(vector, transformation, result);\n        return result;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given vector.\n     * This methods computes transformed normalized direction vectors only.\n     * @param vector - the vector to transform\n     * @param transformation - the transformation matrix to apply\n     * @param result - the vector to store the result in\n     */\n    static TransformNormalToRef(vector, transformation, result) {\n        const m = transformation.m;\n        const x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];\n        const y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];\n        const z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];\n        result.x = x;\n        result.y = y;\n        result.z = z;\n        result.w = vector.w;\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the normal transformation by the given matrix of the given floats (x, y, z, w).\n     * This methods computes transformed normalized direction vectors only.\n     * @param x - value to transform\n     * @param y - value to transform\n     * @param z - value to transform\n     * @param w - value to transform\n     * @param transformation - the transformation matrix to apply\n     * @param result - the vector to store the results in\n     */\n    static TransformNormalFromFloatsToRef(x, y, z, w, transformation, result) {\n        const m = transformation.m;\n        result.x = x * m[0] + y * m[4] + z * m[8];\n        result.y = x * m[1] + y * m[5] + z * m[9];\n        result.z = x * m[2] + y * m[6] + z * m[10];\n        result.w = w;\n    }\n    /**\n     * Returns the string with the Vector4 coordinates.\n     * @returns a string containing all the vector values\n     */\n    toString() {\n        return ('{X: ' + this.x + ' Y:' + this.y + ' Z:' + this.z + ' W:' + this.w + '}');\n    }\n    /**\n     * Returns the string \"Vector4\".\n     * @returns \"Vector4\"\n     */\n    getClassName() {\n        return 'Vector4';\n    }\n    /**\n     * Returns the Vector4 hash code.\n     * @returns a unique hash code\n     */\n    getHashCode() {\n        let hash = this.x || 0;\n        hash = (hash * 397) ^ (this.y || 0);\n        hash = (hash * 397) ^ (this.z || 0);\n        hash = (hash * 397) ^ (this.w || 0);\n        return hash;\n    }\n    // Operators\n    /**\n     * Returns a new array populated with 4 elements : the Vector4 coordinates.\n     * @returns the resulting array\n     */\n    asArray() {\n        const result = new Array();\n        this.toArray(result, 0);\n        return result;\n    }\n    /**\n     * Populates the given array from the given index with the Vector4 coordinates.\n     * @param array - array to populate\n     * @param index - index of the array to start at (default: 0)\n     * @returns the Vector4.\n     */\n    toArray(array, index = 0) {\n        array[index] = this.x;\n        array[index + 1] = this.y;\n        array[index + 2] = this.z;\n        array[index + 3] = this.w;\n        return this;\n    }\n    /**\n     * Adds the given vector to the current Vector4.\n     * @param otherVector - the vector to add\n     * @returns the updated Vector4.\n     */\n    addInPlace(otherVector) {\n        this.x += otherVector.x;\n        this.y += otherVector.y;\n        this.z += otherVector.z;\n        this.w += otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 as the result of the addition of the current Vector4 and the given one.\n     * @param otherVector - the vector to add\n     * @returns the resulting vector\n     */\n    add(otherVector) {\n        return new Vector4(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);\n    }\n    /**\n     * Updates the given vector \"result\" with the result of the addition of the current Vector4 and the given one.\n     * @param otherVector - the vector to add\n     * @param result - the vector to store the result\n     * @returns the current Vector4.\n     */\n    addToRef(otherVector, result) {\n        result.x = this.x + otherVector.x;\n        result.y = this.y + otherVector.y;\n        result.z = this.z + otherVector.z;\n        result.w = this.w + otherVector.w;\n        return this;\n    }\n    /**\n     * Subtract in place the given vector from the current Vector4.\n     * @param otherVector - the vector to subtract\n     * @returns the updated Vector4.\n     */\n    subtractInPlace(otherVector) {\n        this.x -= otherVector.x;\n        this.y -= otherVector.y;\n        this.z -= otherVector.z;\n        this.w -= otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 with the result of the subtraction of the given vector from the current Vector4.\n     * @param otherVector - the vector to add\n     * @returns the new vector with the result\n     */\n    subtract(otherVector) {\n        return new Vector4(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);\n    }\n    /**\n     * Sets the given vector \"result\" with the result of the subtraction of the given vector from the current Vector4.\n     * @param otherVector - the vector to subtract\n     * @param result - the vector to store the result\n     * @returns the current Vector4.\n     */\n    subtractToRef(otherVector, result) {\n        result.x = this.x - otherVector.x;\n        result.y = this.y - otherVector.y;\n        result.z = this.z - otherVector.z;\n        result.w = this.w - otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     */\n    /**\n     * Returns a new Vector4 set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     * @param x - value to subtract\n     * @param y - value to subtract\n     * @param z - value to subtract\n     * @param w - value to subtract\n     * @returns new vector containing the result\n     */\n    subtractFromFloats(x, y, z, w) {\n        return new Vector4(this.x - x, this.y - y, this.z - z, this.w - w);\n    }\n    /**\n     * Sets the given vector \"result\" set with the result of the subtraction of the given floats from the current Vector4 coordinates.\n     * @param x - value to subtract\n     * @param y - value to subtract\n     * @param z - value to subtract\n     * @param w - value to subtract\n     * @param result - the vector to store the result in\n     * @returns the current Vector4.\n     */\n    subtractFromFloatsToRef(x, y, z, w, result) {\n        result.x = this.x - x;\n        result.y = this.y - y;\n        result.z = this.z - z;\n        result.w = this.w - w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 set with the current Vector4 negated coordinates.\n     * @returns a new vector with the negated values\n     */\n    negate() {\n        return new Vector4(-this.x, -this.y, -this.z, -this.w);\n    }\n    /**\n     * Multiplies the current Vector4 coordinates by scale (float).\n     * @param scale - the number to scale with\n     * @returns the updated Vector4.\n     */\n    scaleInPlace(scale) {\n        this.x *= scale;\n        this.y *= scale;\n        this.z *= scale;\n        this.w *= scale;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 set with the current Vector4 coordinates multiplied by scale (float).\n     * @param scale - the number to scale with\n     * @returns a new vector with the result\n     */\n    scale(scale) {\n        return new Vector4(this.x * scale, this.y * scale, this.z * scale, this.w * scale);\n    }\n    /**\n     * Sets the given vector \"result\" with the current Vector4 coordinates multiplied by scale (float).\n     * @param scale - the number to scale with\n     * @param result - a vector to store the result in\n     * @returns the current Vector4.\n     */\n    scaleToRef(scale, result) {\n        result.x = this.x * scale;\n        result.y = this.y * scale;\n        result.z = this.z * scale;\n        result.w = this.w * scale;\n        return this;\n    }\n    /**\n     * Scale the current Vector4 values by a factor and add the result to a given Vector4\n     * @param scale - defines the scale factor\n     * @param result - defines the Vector4 object where to store the result\n     * @returns the unmodified current Vector4\n     */\n    scaleAndAddToRef(scale, result) {\n        result.x += this.x * scale;\n        result.y += this.y * scale;\n        result.z += this.z * scale;\n        result.w += this.w * scale;\n        return this;\n    }\n    /**\n     * Boolean : True if the current Vector4 coordinates are stricly equal to the given ones.\n     * @param otherVector - the vector to compare against\n     * @returns true if they are equal\n     */\n    equals(otherVector) {\n        return (otherVector &&\n            this.x === otherVector.x &&\n            this.y === otherVector.y &&\n            this.z === otherVector.z &&\n            this.w === otherVector.w);\n    }\n    /**\n     * Boolean : True if the current Vector4 coordinates are each beneath the distance \"epsilon\" from the given vector ones.\n     * @param otherVector - vector to compare against\n     * @param epsilon - (Default: very small number)\n     * @returns true if they are equal\n     */\n    equalsWithEpsilon(otherVector, epsilon = types_1.Epsilon) {\n        return (otherVector &&\n            Scalar_1.Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) &&\n            Scalar_1.Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) &&\n            Scalar_1.Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) &&\n            Scalar_1.Scalar.WithinEpsilon(this.w, otherVector.w, epsilon));\n    }\n    /**\n     * Boolean : True if the given floats are strictly equal to the current Vector4 coordinates.\n     * @param x - x value to compare against\n     * @param y - y value to compare against\n     * @param z - z value to compare against\n     * @param w - w value to compare against\n     * @returns true if equal\n     */\n    equalsToFloats(x, y, z, w) {\n        return this.x === x && this.y === y && this.z === z && this.w === w;\n    }\n    /**\n     * Multiplies in place the current Vector4 by the given one.\n     * @param otherVector - vector to multiple with\n     * @returns the updated Vector4.\n     */\n    multiplyInPlace(otherVector) {\n        this.x *= otherVector.x;\n        this.y *= otherVector.y;\n        this.z *= otherVector.z;\n        this.w *= otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 set with the multiplication result of the current Vector4 and the given one.\n     * @param otherVector - vector to multiple with\n     * @returns resulting new vector\n     */\n    multiply(otherVector) {\n        return new Vector4(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);\n    }\n    /**\n     * Updates the given vector \"result\" with the multiplication result of the current Vector4 and the given one.\n     * @param otherVector - vector to multiple with\n     * @param result - vector to store the result\n     * @returns the current Vector4.\n     */\n    multiplyToRef(otherVector, result) {\n        result.x = this.x * otherVector.x;\n        result.y = this.y * otherVector.y;\n        result.z = this.z * otherVector.z;\n        result.w = this.w * otherVector.w;\n        return this;\n    }\n    /**\n     * Returns a new Vector4 set with the multiplication result of the given floats and the current Vector4 coordinates.\n     * @param x - x value multiply with\n     * @param y - y value multiply with\n     * @param z - z value multiply with\n     * @param w - w value multiply with\n     * @returns resulting new vector\n     */\n    multiplyByFloats(x, y, z, w) {\n        return new Vector4(this.x * x, this.y * y, this.z * z, this.w * w);\n    }\n    /**\n     * Returns a new Vector4 set with the division result of the current Vector4 by the given one.\n     * @param otherVector - vector to devide with\n     * @returns resulting new vector\n     */\n    divide(otherVector) {\n        return new Vector4(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);\n    }\n    /**\n     * Updates the given vector \"result\" with the division result of the current Vector4 by the given one.\n     * @param otherVector - vector to devide with\n     * @param result - vector to store the result\n     * @returns the current Vector4.\n     */\n    divideToRef(otherVector, result) {\n        result.x = this.x / otherVector.x;\n        result.y = this.y / otherVector.y;\n        result.z = this.z / otherVector.z;\n        result.w = this.w / otherVector.w;\n        return this;\n    }\n    /**\n     * Divides the current Vector3 coordinates by the given ones.\n     * @param otherVector - vector to devide with\n     * @returns the updated Vector3.\n     */\n    divideInPlace(otherVector) {\n        return this.divideToRef(otherVector, this);\n    }\n    /**\n     * Updates the Vector4 coordinates with the minimum values between its own and the given vector ones\n     * @param other - defines the second operand\n     * @returns the current updated Vector4\n     */\n    minimizeInPlace(other) {\n        if (other.x < this.x) {\n            this.x = other.x;\n        }\n        if (other.y < this.y) {\n            this.y = other.y;\n        }\n        if (other.z < this.z) {\n            this.z = other.z;\n        }\n        if (other.w < this.w) {\n            this.w = other.w;\n        }\n        return this;\n    }\n    /**\n     * Updates the Vector4 coordinates with the maximum values between its own and the given vector ones\n     * @param other - defines the second operand\n     * @returns the current updated Vector4\n     */\n    maximizeInPlace(other) {\n        if (other.x > this.x) {\n            this.x = other.x;\n        }\n        if (other.y > this.y) {\n            this.y = other.y;\n        }\n        if (other.z > this.z) {\n            this.z = other.z;\n        }\n        if (other.w > this.w) {\n            this.w = other.w;\n        }\n        return this;\n    }\n    /**\n     * Gets a new Vector4 from current Vector4 floored values\n     * @returns a new Vector4\n     */\n    floor() {\n        return new Vector4(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));\n    }\n    /**\n     * Gets a new Vector4 from current Vector3 floored values\n     * @returns a new Vector4\n     */\n    fract() {\n        return new Vector4(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));\n    }\n    // Properties\n    /**\n     * Returns the Vector4 length (float).\n     * @returns the length\n     */\n    length() {\n        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\n    }\n    /**\n     * Returns the Vector4 squared length (float).\n     * @returns the length squared\n     */\n    lengthSquared() {\n        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;\n    }\n    // Methods\n    /**\n     * Normalizes in place the Vector4.\n     * @returns the updated Vector4.\n     */\n    normalize() {\n        const len = this.length();\n        if (len === 0) {\n            return this;\n        }\n        return this.scaleInPlace(1.0 / len);\n    }\n    /**\n     * Returns a new Vector3 from the Vector4 (x, y, z) coordinates.\n     * @returns this converted to a new vector3\n     */\n    toVector3() {\n        return new Vector3_1.Vector3(this.x, this.y, this.z);\n    }\n    /**\n     * Returns a new Vector4 copied from the current one.\n     * @returns the new cloned vector\n     */\n    clone() {\n        return new Vector4(this.x, this.y, this.z, this.w);\n    }\n    /**\n     * Updates the current Vector4 with the given one coordinates.\n     * @param source - the source vector to copy from\n     * @returns the updated Vector4.\n     */\n    copyFrom(source) {\n        this.x = source.x;\n        this.y = source.y;\n        this.z = source.z;\n        this.w = source.w;\n        return this;\n    }\n    /**\n     * Updates the current Vector4 coordinates with the given floats.\n     * @param x - float to copy from\n     * @param y - float to copy from\n     * @param z - float to copy from\n     * @param w - float to copy from\n     * @returns the updated Vector4.\n     */\n    copyFromFloats(x, y, z, w) {\n        this.x = x;\n        this.y = y;\n        this.z = z;\n        this.w = w;\n        return this;\n    }\n    /**\n     * Updates the current Vector4 coordinates with the given floats.\n     * @param x - float to set from\n     * @param y - float to set from\n     * @param z - float to set from\n     * @param w - float to set from\n     * @returns the updated Vector4.\n     */\n    set(x, y, z, w) {\n        return this.copyFromFloats(x, y, z, w);\n    }\n    /**\n     * Copies the given float to the current Vector3 coordinates\n     * @param v - defines the x, y, z and w coordinates of the operand\n     * @returns the current updated Vector3\n     */\n    setAll(v) {\n        this.x = this.y = this.z = this.w = v;\n        return this;\n    }\n}\nexports.Vector4 = Vector4;\n//# sourceMappingURL=Vector4.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/Vector4.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/@dcl/ecs-math/dist/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./preallocatedVariables */ \"./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Angle */ \"./node_modules/@dcl/ecs-math/dist/Angle.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Arc2 */ \"./node_modules/@dcl/ecs-math/dist/Arc2.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Axis */ \"./node_modules/@dcl/ecs-math/dist/Axis.js\"), exports);\n__exportStar(__webpack_require__(/*! ./BezierCurve */ \"./node_modules/@dcl/ecs-math/dist/BezierCurve.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Color3 */ \"./node_modules/@dcl/ecs-math/dist/Color3.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Color4 */ \"./node_modules/@dcl/ecs-math/dist/Color4.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Curve3d */ \"./node_modules/@dcl/ecs-math/dist/Curve3d.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Furstum */ \"./node_modules/@dcl/ecs-math/dist/Furstum.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Matrix */ \"./node_modules/@dcl/ecs-math/dist/Matrix.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Path2d */ \"./node_modules/@dcl/ecs-math/dist/Path2d.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Path3d */ \"./node_modules/@dcl/ecs-math/dist/Path3d.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Plane */ \"./node_modules/@dcl/ecs-math/dist/Plane.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Quaternion */ \"./node_modules/@dcl/ecs-math/dist/Quaternion.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Scalar */ \"./node_modules/@dcl/ecs-math/dist/Scalar.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Size */ \"./node_modules/@dcl/ecs-math/dist/Size.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Vector2 */ \"./node_modules/@dcl/ecs-math/dist/Vector2.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\"), exports);\n__exportStar(__webpack_require__(/*! ./Vector4 */ \"./node_modules/@dcl/ecs-math/dist/Vector4.js\"), exports);\n__exportStar(__webpack_require__(/*! ./index */ \"./node_modules/@dcl/ecs-math/dist/index.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/index.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js":
/*!******************************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.MathTmp = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"./node_modules/@dcl/ecs-math/dist/utils.js\");\nconst Vector3_1 = __webpack_require__(/*! ./Vector3 */ \"./node_modules/@dcl/ecs-math/dist/Vector3.js\");\nconst Quaternion_1 = __webpack_require__(/*! ./Quaternion */ \"./node_modules/@dcl/ecs-math/dist/Quaternion.js\");\nconst Matrix_1 = __webpack_require__(/*! ./Matrix */ \"./node_modules/@dcl/ecs-math/dist/Matrix.js\");\n// Temporary pre-allocated objects for engine internal use\n// usage in any internal function :\n// var tmp = Tmp.Vector3[0];   <= gets access to the first pre-created Vector3\n// There's a Tmp array per object type : int, float, Vector2, Vector3, Vector4, Quaternion, Matrix\n/**\n * @public\n * Same as Tmp but not exported to keep it only for math functions to avoid conflicts\n */\nexports.MathTmp = {\n    Vector3: (0, utils_1.buildArray)(6, Vector3_1.Vector3.Zero),\n    Matrix: (0, utils_1.buildArray)(2, Matrix_1.Matrix.Identity),\n    Quaternion: (0, utils_1.buildArray)(3, Quaternion_1.Quaternion.Zero),\n    staticUp: Vector3_1.Vector3.Up(),\n    tmpMatrix: Matrix_1.Matrix.Zero()\n};\n//# sourceMappingURL=preallocatedVariables.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/preallocatedVariables.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/types.js":
/*!**************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/types.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.RAD2DEG = exports.DEG2RAD = exports.Epsilon = exports.ToLinearSpace = exports.ToGammaSpace = exports.Space = exports.Orientation = void 0;\n/**\n * Defines potential orientation for back face culling\n * @public\n */\nvar Orientation;\n(function (Orientation) {\n    /**\n     * Clockwise\n     */\n    Orientation[Orientation[\"CW\"] = 0] = \"CW\";\n    /** Counter clockwise */\n    Orientation[Orientation[\"CCW\"] = 1] = \"CCW\";\n})(Orientation = exports.Orientation || (exports.Orientation = {}));\n/**\n * Defines supported spaces\n * @public\n */\nvar Space;\n(function (Space) {\n    /** Local (object) space */\n    Space[Space[\"LOCAL\"] = 0] = \"LOCAL\";\n    /** World space */\n    Space[Space[\"WORLD\"] = 1] = \"WORLD\";\n    /** Bone space */\n    Space[Space[\"BONE\"] = 2] = \"BONE\";\n})(Space = exports.Space || (exports.Space = {}));\n/**\n * Constant used to convert a value to gamma space\n * @public\n */\nexports.ToGammaSpace = 1 / 2.2;\n/**\n * Constant used to convert a value to linear space\n * @public\n */\nexports.ToLinearSpace = 2.2;\n/**\n * Constant used to define the minimal number value in Babylon.js\n * @public\n */\nexports.Epsilon = 0.000001;\n/**\n * Constant used to convert from Euler degrees to radians\n * @public\n */\nexports.DEG2RAD = Math.PI / 180;\n/**\n * Constant used to convert from radians to Euler degrees\n * @public\n */\nexports.RAD2DEG = 360 / (Math.PI * 2);\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/types.js?");

/***/ }),

/***/ "./node_modules/@dcl/ecs-math/dist/utils.js":
/*!**************************************************!*\
  !*** ./node_modules/@dcl/ecs-math/dist/utils.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.buildArray = void 0;\n/**\n * @internal\n * Returns an array of the given size filled with element built from the given constructor and the paramters\n * @param size - the number of element to construct and put in the array\n * @param itemBuilder - a callback responsible for creating new instance of item. Called once per array entry.\n * @returns a new array filled with new objects\n * @internal\n */\nfunction buildArray(size, itemBuilder) {\n    const a = [];\n    for (let i = 0; i < size; ++i) {\n        a.push(itemBuilder());\n    }\n    return a;\n}\nexports.buildArray = buildArray;\n//# sourceMappingURL=utils.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/ecs-math/dist/utils.js?");

/***/ }),

/***/ "./node_modules/@dcl/legacy-ecs/dist/decentraland/Math.js":
/*!****************************************************************!*\
  !*** ./node_modules/@dcl/legacy-ecs/dist/decentraland/Math.js ***!
  \****************************************************************/
/*! exports provided: Angle, Arc2, Axis, BezierCurve, Color3, Color4, Curve3, DEG2RAD, Epsilon, Frustum, Matrix, Orientation, Path2, Path3D, Plane, Quaternion, RAD2DEG, Scalar, Size, Space, ToGammaSpace, ToLinearSpace, Vector2, Vector3, Vector4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/ecs-math */ \"./node_modules/@dcl/ecs-math/dist/index.js\");\n/* harmony import */ var _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Angle\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Angle\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Arc2\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Arc2\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Axis\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Axis\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"BezierCurve\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"BezierCurve\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Color3\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Color3\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Color4\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Color4\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Curve3\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Curve3\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"DEG2RAD\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"DEG2RAD\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Epsilon\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Epsilon\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Frustum\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Frustum\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Matrix\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Matrix\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Orientation\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Orientation\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Path2\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Path2\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Path3D\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Path3D\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Plane\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Plane\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Quaternion\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"RAD2DEG\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"RAD2DEG\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Scalar\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Scalar\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Size\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Size\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Space\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Space\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ToGammaSpace\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"ToGammaSpace\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"ToLinearSpace\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"ToLinearSpace\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector2\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]; });\n\n/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, \"Vector4\", function() { return _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector4\"]; });\n\n\n\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiTWF0aC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9kZWNlbnRyYWxhbmQvTWF0aC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQ0wsS0FBSyxFQUNMLElBQUksRUFDSixJQUFJLEVBQ0osV0FBVyxFQUNYLE1BQU0sRUFDTixNQUFNLEVBQ04sTUFBTSxFQUNOLE9BQU8sRUFNUCxPQUFPLEVBR1AsT0FBTyxFQUVQLE1BQU0sRUFFTixXQUFXLEVBQ1gsS0FBSyxFQUNMLE1BQU0sRUFDTixLQUFLLEVBQ0wsVUFBVSxFQUNWLE9BQU8sRUFFUCxNQUFNLEVBQ04sSUFBSSxFQUNKLEtBQUssRUFDTCxZQUFZLEVBQ1osYUFBYSxFQUNiLE9BQU8sRUFDUCxPQUFPLEVBQ1AsT0FBTyxFQUNSLE1BQU0sZUFBZSxDQUFBO0FBRXRCLE9BQU8sRUFDTCxLQUFLLEVBQ0wsSUFBSSxFQUNKLElBQUksRUFDSixXQUFXLEVBQ1gsTUFBTSxFQUNOLE1BQU0sRUFDTixNQUFNLEVBQ04sT0FBTyxFQU1QLE9BQU8sRUFHUCxPQUFPLEVBRVAsTUFBTSxFQUVOLFdBQVcsRUFDWCxLQUFLLEVBQ0wsTUFBTSxFQUNOLEtBQUssRUFDTCxVQUFVLEVBQ1YsT0FBTyxFQUVQLE1BQU0sRUFDTixJQUFJLEVBQ0osS0FBSyxFQUNMLFlBQVksRUFDWixhQUFhLEVBQ2IsT0FBTyxFQUNQLE9BQU8sRUFDUCxPQUFPLEVBQ1IsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIEFuZ2xlLFxuICBBcmMyLFxuICBBeGlzLFxuICBCZXppZXJDdXJ2ZSxcbiAgQ29sb3IzLFxuICBDb2xvcjQsXG4gIEN1cnZlMyxcbiAgREVHMlJBRCxcbiAgZG91YmxlLFxuICBFY3NNYXRoUmVhZE9ubHlRdWF0ZXJuaW9uLFxuICBFY3NNYXRoUmVhZE9ubHlWZWN0b3IyLFxuICBFY3NNYXRoUmVhZE9ubHlWZWN0b3IzLFxuICBFY3NNYXRoUmVhZE9ubHlWZWN0b3I0LFxuICBFcHNpbG9uLFxuICBmbG9hdCxcbiAgRmxvYXRBcnJheSxcbiAgRnJ1c3R1bSxcbiAgSVNpemUsXG4gIE1hdHJpeCxcbiAgTnVsbGFibGUsXG4gIE9yaWVudGF0aW9uLFxuICBQYXRoMixcbiAgUGF0aDNELFxuICBQbGFuZSxcbiAgUXVhdGVybmlvbixcbiAgUkFEMkRFRyxcbiAgUmVhZE9ubHlDb2xvcjQsXG4gIFNjYWxhcixcbiAgU2l6ZSxcbiAgU3BhY2UsXG4gIFRvR2FtbWFTcGFjZSxcbiAgVG9MaW5lYXJTcGFjZSxcbiAgVmVjdG9yMixcbiAgVmVjdG9yMyxcbiAgVmVjdG9yNFxufSBmcm9tICdAZGNsL2Vjcy1tYXRoJ1xuXG5leHBvcnQge1xuICBBbmdsZSxcbiAgQXJjMixcbiAgQXhpcyxcbiAgQmV6aWVyQ3VydmUsXG4gIENvbG9yMyxcbiAgQ29sb3I0LFxuICBDdXJ2ZTMsXG4gIERFRzJSQUQsXG4gIGRvdWJsZSxcbiAgRWNzTWF0aFJlYWRPbmx5UXVhdGVybmlvbixcbiAgRWNzTWF0aFJlYWRPbmx5VmVjdG9yMixcbiAgRWNzTWF0aFJlYWRPbmx5VmVjdG9yMyxcbiAgRWNzTWF0aFJlYWRPbmx5VmVjdG9yNCxcbiAgRXBzaWxvbixcbiAgZmxvYXQsXG4gIEZsb2F0QXJyYXksXG4gIEZydXN0dW0sXG4gIElTaXplLFxuICBNYXRyaXgsXG4gIE51bGxhYmxlLFxuICBPcmllbnRhdGlvbixcbiAgUGF0aDIsXG4gIFBhdGgzRCxcbiAgUGxhbmUsXG4gIFF1YXRlcm5pb24sXG4gIFJBRDJERUcsXG4gIFJlYWRPbmx5Q29sb3I0LFxuICBTY2FsYXIsXG4gIFNpemUsXG4gIFNwYWNlLFxuICBUb0dhbW1hU3BhY2UsXG4gIFRvTGluZWFyU3BhY2UsXG4gIFZlY3RvcjIsXG4gIFZlY3RvcjMsXG4gIFZlY3RvcjRcbn1cbiJdfQ==\n\n//# sourceURL=webpack:///./node_modules/@dcl/legacy-ecs/dist/decentraland/Math.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/ack-helper.js":
/*!**************************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/ack-helper.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createAckHelper = void 0;\nconst minimal_1 = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\nconst helpers_1 = __webpack_require__(/*! ./protocol/helpers */ \"./node_modules/@dcl/rpc/dist/protocol/helpers.js\");\nconst protocol_1 = __webpack_require__(/*! ./protocol */ \"./node_modules/@dcl/rpc/dist/protocol/index.js\");\nfunction createAckHelper(transport) {\n    const oneTimeCallbacks = new Map();\n    const bb = new minimal_1.Writer();\n    function closeAll() {\n        const err = new Error(\"Transport closed while waiting the ACK\");\n        oneTimeCallbacks.forEach(([, reject]) => reject(err));\n        oneTimeCallbacks.clear();\n    }\n    transport.on(\"close\", closeAll);\n    transport.on(\"error\", err => {\n        oneTimeCallbacks.forEach(([, reject]) => reject(err));\n        oneTimeCallbacks.clear();\n    });\n    return {\n        receiveAck(data, messageNumber) {\n            const key = `${messageNumber},${data.sequenceId}`;\n            const fut = oneTimeCallbacks.get(key);\n            if (fut) {\n                oneTimeCallbacks.delete(key);\n                fut[0](data);\n            }\n            else {\n                throw new Error('Received a message for an inexistent handler ' + key);\n            }\n        },\n        async sendWithAck(data) {\n            const [_, messageNumber] = (0, helpers_1.parseMessageIdentifier)(data.messageIdentifier);\n            const key = `${messageNumber},${data.sequenceId}`;\n            const ret = new Promise(function ackPromise(ret, rej) {\n                oneTimeCallbacks.set(key, [ret, rej]);\n            });\n            bb.reset();\n            protocol_1.StreamMessage.encode(data, bb);\n            transport.sendMessage(bb.finish());\n            return ret;\n        },\n    };\n}\nexports.createAckHelper = createAckHelper;\n//# sourceMappingURL=ack-helper.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/ack-helper.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/client.js":
/*!**********************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/client.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createRpcClient = exports.streamFromDispatcher = exports.createPort = void 0;\nconst mitt_1 = __importDefault(__webpack_require__(/*! mitt */ \"./node_modules/mitt/dist/mitt.mjs\"));\nconst minimal_1 = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\nconst protocol_1 = __webpack_require__(/*! ./protocol */ \"./node_modules/@dcl/rpc/dist/protocol/index.js\");\nconst message_number_handler_1 = __webpack_require__(/*! ./message-number-handler */ \"./node_modules/@dcl/rpc/dist/message-number-handler.js\");\nconst push_channel_1 = __webpack_require__(/*! ./push-channel */ \"./node_modules/@dcl/rpc/dist/push-channel.js\");\nconst helpers_1 = __webpack_require__(/*! ./protocol/helpers */ \"./node_modules/@dcl/rpc/dist/protocol/helpers.js\");\nconst EMPTY_U8 = new Uint8Array(0);\n// @internal\nfunction createPort(portId, portName, dispatcher) {\n    const events = (0, mitt_1.default)();\n    let state = \"open\";\n    events.on(\"close\", () => {\n        state = \"closed\";\n    });\n    return {\n        ...events,\n        portName,\n        portId,\n        get state() {\n            return state;\n        },\n        close() {\n            const bb = new minimal_1.Writer();\n            protocol_1.DestroyPort.encode({\n                messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_DESTROY_PORT, 0),\n                portId,\n            }, bb);\n            dispatcher.transport.sendMessage(bb.finish());\n            events.emit(\"close\", {});\n        },\n        async loadModule(moduleName) {\n            const ret = await dispatcher.request((bb, messageNumber) => {\n                protocol_1.RequestModule.encode({\n                    messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE, messageNumber),\n                    moduleName,\n                    portId,\n                }, bb);\n            });\n            const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);\n            if (parsedMessage) {\n                const [messageType, message] = parsedMessage;\n                if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE) {\n                    const ret = {};\n                    for (let procedure of message.procedures) {\n                        ret[procedure.procedureName] = createProcedure(portId, procedure.procedureId, dispatcher);\n                    }\n                    return ret;\n                }\n                else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {\n                    throwIfRemoteError(message);\n                }\n            }\n            throw new Error(\"Unknown response received from server.\");\n        },\n    };\n}\nexports.createPort = createPort;\nfunction throwIfRemoteError(parsedMessage) {\n    throw new Error(\"RemoteError: \" + parsedMessage.errorMessage);\n}\n/**\n * If a StreamMessage is received, then it means we have the POSSIBILITY to\n * consume a remote generator. The client must answer every ACK with the next\n * inteded action, could be: next(), close(). Both actions are serialized in the\n * StreamMessage. The server MUST NOT generate any new element of the generator\n * if the client doesn't ask for it.\n *\n * The whole protocol is designed to be SLOW AND SECURE, that means, ACKs (slow)\n * will block the generation and consumption of iterators (secure).\n *\n * That exist to save the memory of the servers and to generate the much needed\n * backpressure.\n *\n * If throughput is what you are looking for, you may better use bigger messages\n * containing serialized lists. Effectively reducing the number of messages\n * and increasing their size.\n *\n * @internal\n */\nfunction streamFromDispatcher(dispatcher, streamMessage, messageNumber) {\n    let lastReceivedSequenceId = 0;\n    let isRemoteClosed = false;\n    const channel = new push_channel_1.AsyncQueue(sendServerSignals);\n    dispatcher.transport.on(\"close\", () => {\n        channel.close(new Error(\"RPC Transport closed\"));\n    });\n    dispatcher.transport.on(\"error\", () => {\n        channel.close(new Error(\"RPC Transport failed\"));\n    });\n    // This function is called at two moments\n    // 1. When the channel is closed or fails -> an ACK closing the stream is sent to the server\n    // 2. When the channel.next() is called   -> an ACK requesting the next elem is sent to the server\n    function sendServerSignals(_channel, action) {\n        if (action == \"close\") {\n            dispatcher.removeListener(messageNumber);\n        }\n        if (!isRemoteClosed) {\n            if (action == \"close\") {\n                dispatcher.transport.sendMessage((0, helpers_1.closeStreamMessage)(messageNumber, lastReceivedSequenceId, streamMessage.portId));\n            }\n            else if (action == \"next\") {\n                dispatcher.transport.sendMessage((0, helpers_1.streamAckMessage)(messageNumber, lastReceivedSequenceId, streamMessage.portId));\n            }\n        }\n    }\n    // receive a message from the server and send it to the iterable channel\n    function processMessage(message) {\n        lastReceivedSequenceId = message.sequenceId;\n        if (message.closed) {\n            // when the server CLOSES the stream, then we raise the flag isRemoteClosed\n            // to prevent sending an extra closeStreamMessage to the server after closing\n            // our channel.\n            // IMPORTANT: If the server closes the connection, then we DONT send the ACK\n            //            back to the server because it is redundant information.\n            isRemoteClosed = true;\n            channel.close();\n        }\n        else {\n            channel.enqueue(message.payload);\n        }\n    }\n    dispatcher.addListener(messageNumber, (reader) => {\n        const ret = (0, helpers_1.parseProtocolMessage)(reader);\n        if (ret) {\n            const [messageType, message] = ret;\n            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {\n                processMessage(message);\n            }\n            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {\n                isRemoteClosed = true;\n                channel.close(new Error(\"RemoteError: \" + (message.errorMessage || \"Unknown remote error\")));\n            }\n            else {\n                channel.close(new Error(\"RemoteError: Protocol error\"));\n            }\n        }\n        else {\n            channel.close(new Error(\"RemoteError: Protocol error\"));\n        }\n    });\n    return channel;\n}\nexports.streamFromDispatcher = streamFromDispatcher;\n// @internal\nfunction createProcedure(portId, procedureId, dispatcher) {\n    const callProcedurePacket = {\n        portId,\n        messageIdentifier: 0,\n        payload: EMPTY_U8,\n        procedureId,\n    };\n    return async function (data) {\n        if (data) {\n            callProcedurePacket.payload = data;\n        }\n        else {\n            callProcedurePacket.payload = EMPTY_U8;\n        }\n        const ret = (0, helpers_1.parseProtocolMessage)(await dispatcher.request((bb, messageNumber) => {\n            callProcedurePacket.messageIdentifier = (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST, messageNumber);\n            protocol_1.Request.encode(callProcedurePacket, bb);\n        }));\n        if (ret) {\n            const [messageType, message, messageNumber] = ret;\n            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_RESPONSE) {\n                const u8 = message.payload;\n                if (u8.length) {\n                    return u8;\n                }\n                else {\n                    return undefined;\n                }\n            }\n            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {\n                // If a StreamMessage is received, then it means we have the POSSIBILITY\n                // to consume a remote generator. Look into the streamFromDispatcher functions\n                // for more information.\n                return streamFromDispatcher(dispatcher, message, messageNumber);\n            }\n            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {\n                throwIfRemoteError(message);\n            }\n        }\n    };\n}\n/**\n * @public\n */\nasync function createRpcClient(transport) {\n    const clientPortByName = new Map();\n    const dispatcher = (0, message_number_handler_1.messageNumberHandler)(transport);\n    async function internalCreatePort(portName) {\n        const ret = await dispatcher.request((bb, messageNumber) => {\n            protocol_1.CreatePort.encode({\n                messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT, messageNumber),\n                portName,\n            }, bb);\n        });\n        const parsedMessage = (0, helpers_1.parseProtocolMessage)(ret);\n        if (parsedMessage) {\n            const [messageType, message] = parsedMessage;\n            if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE) {\n                const portId = message.portId;\n                return createPort(portId, portName, dispatcher);\n            }\n            else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE) {\n                throwIfRemoteError(message);\n            }\n        }\n        throw new Error(\"Unknown response received from server.\");\n    }\n    // wait for transport to be connected\n    await new Promise((resolve, reject) => {\n        transport.on(\"connect\", resolve);\n        transport.on(\"error\", reject);\n    });\n    return {\n        // the only objective of this function is to deduplicate asynchronous calls\n        // and produce an idempotent module load\n        async createPort(portName) {\n            if (clientPortByName.has(portName)) {\n                return clientPortByName.get(portName);\n            }\n            const portFuture = internalCreatePort(portName);\n            clientPortByName.set(portName, portFuture);\n            const port = await portFuture;\n            transport.on(\"close\", () => {\n                port.close();\n            });\n            port.on(\"close\", () => {\n                if (clientPortByName.get(portName) === portFuture) {\n                    clientPortByName.delete(portName);\n                }\n            });\n            return port;\n        },\n    };\n}\nexports.createRpcClient = createRpcClient;\n//# sourceMappingURL=client.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/client.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/codegen.js":
/*!***********************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/codegen.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.registerService = exports.loadService = exports.serverProcedureStream = exports.serverProcedureUnary = exports.clientProcedureStream = exports.clientProcedureUnary = void 0;\nconst EMPTY_U8ARRAY = new Uint8Array();\nfunction clientProcedureUnary(port, method) {\n    const fn = async (arg) => {\n        const remoteModule = (await port);\n        if (!(method.name in remoteModule))\n            throw new Error(\"Method \" + method.name + \" not implemented in server port\");\n        const result = await remoteModule[method.name](method.requestType.encode(arg).finish());\n        return method.responseType.decode(result !== null && result !== void 0 ? result : EMPTY_U8ARRAY);\n    };\n    return fn;\n}\nexports.clientProcedureUnary = clientProcedureUnary;\nfunction clientProcedureStream(port, method) {\n    const fn = function (arg) {\n        let _generator = undefined;\n        async function lazyGenerator() {\n            const remoteModule = (await port);\n            if (!(method.name in remoteModule))\n                throw new Error(\"Method \" + method.name + \" not implemented in server port\");\n            return (await remoteModule[method.name](method.requestType.encode(arg).finish()))[Symbol.asyncIterator]();\n        }\n        function getGenerator() {\n            if (!_generator) {\n                _generator = lazyGenerator();\n            }\n            return _generator;\n        }\n        const ret = {\n            [Symbol.asyncIterator]: () => ret,\n            async next() {\n                var _a;\n                const iter = await (await getGenerator()).next();\n                return { value: method.responseType.decode((_a = iter.value) !== null && _a !== void 0 ? _a : EMPTY_U8ARRAY), done: iter.done };\n            },\n            async return(value) {\n                const iter = await (await getGenerator()).return(value);\n                return { value: iter.value ? method.responseType.decode(iter.value) : iter.value, done: iter.done };\n            },\n            async throw(value) {\n                const iter = await (await getGenerator()).throw(value);\n                return { value: iter.value ? method.responseType.decode(iter.value) : iter.value, done: iter.done };\n            }\n        };\n        return ret;\n    };\n    return fn;\n}\nexports.clientProcedureStream = clientProcedureStream;\nfunction serverProcedureUnary(fn, method) {\n    return async function (argBinary, context) {\n        const arg = method.requestType.decode(argBinary);\n        const result = await fn(arg, context);\n        if (!result)\n            throw new Error(\"Empty or null responses are not allowed. Procedure: \" + method.name);\n        return method.responseType.encode(result).finish();\n    };\n}\nexports.serverProcedureUnary = serverProcedureUnary;\nfunction serverProcedureStream(fn, method) {\n    return function (argBinary, context) {\n        let _generator = undefined;\n        const arg = method.requestType.decode(argBinary);\n        async function lazyGenerator() {\n            const result = (await fn(arg, context));\n            if (!result)\n                throw new Error(\"Empty or null responses are not allowed. Procedure: \" + method.name);\n            return result[Symbol.asyncIterator]();\n        }\n        function getGenerator() {\n            if (!_generator) {\n                _generator = lazyGenerator();\n            }\n            return _generator;\n        }\n        const ret = {\n            [Symbol.asyncIterator]: () => ret,\n            async next() {\n                const iter = await (await getGenerator()).next();\n                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };\n            },\n            async return(value) {\n                const iter = await (await getGenerator()).return(value);\n                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };\n            },\n            async throw(value) {\n                const iter = await (await getGenerator()).throw(value);\n                return { value: iter.value ? method.responseType.encode(iter.value).finish() : iter.value, done: iter.done };\n            }\n        };\n        return ret;\n    };\n}\nexports.serverProcedureStream = serverProcedureStream;\nfunction loadService(port, service) {\n    const portFuture = port.loadModule(service.name);\n    const ret = {};\n    for (const [key, def] of Object.entries(service.methods)) {\n        if (def.responseStream) {\n            ret[key] = clientProcedureStream(portFuture, def);\n        }\n        else {\n            ret[key] = clientProcedureUnary(portFuture, def);\n        }\n    }\n    return ret;\n}\nexports.loadService = loadService;\nfunction registerService(port, service, moduleInitializator) {\n    port.registerModule(service.name, async (port, context) => {\n        const mod = await moduleInitializator(port, context);\n        const ret = {};\n        for (const [key, def] of Object.entries(service.methods)) {\n            if (def.responseStream) {\n                ret[def.name] = serverProcedureStream(mod[key].bind(mod), def);\n            }\n            else {\n                ret[def.name] = serverProcedureUnary(mod[key].bind(mod), def);\n            }\n        }\n        return ret;\n    });\n}\nexports.registerService = registerService;\n//# sourceMappingURL=codegen.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/codegen.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/@dcl/rpc/dist/types.js\"), exports);\n__exportStar(__webpack_require__(/*! ./server */ \"./node_modules/@dcl/rpc/dist/server.js\"), exports);\n__exportStar(__webpack_require__(/*! ./client */ \"./node_modules/@dcl/rpc/dist/client.js\"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/index.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/message-number-handler.js":
/*!**************************************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/message-number-handler.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.messageNumberHandler = void 0;\nconst minimal_1 = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\nconst helpers_1 = __webpack_require__(/*! ./protocol/helpers */ \"./node_modules/@dcl/rpc/dist/protocol/helpers.js\");\nconst protocol_1 = __webpack_require__(/*! ./protocol */ \"./node_modules/@dcl/rpc/dist/protocol/index.js\");\nlet globalMessageNumber = 0;\nfunction messageNumberHandler(transport) {\n    const oneTimeCallbacks = new Map();\n    const listeners = new Map();\n    transport.on(\"message\", (message) => {\n        const reader = minimal_1.Reader.create(message);\n        const header = protocol_1.RpcMessageHeader.decode(reader);\n        const [_, messageNumber] = (0, helpers_1.parseMessageIdentifier)(header.messageIdentifier);\n        if (messageNumber > 0) {\n            const fut = oneTimeCallbacks.get(messageNumber);\n            if (fut) {\n                reader.pos = 0;\n                fut(reader);\n                oneTimeCallbacks.delete(messageNumber);\n            }\n            const handler = listeners.get(messageNumber);\n            if (handler) {\n                reader.pos = 0;\n                handler(reader);\n            }\n        }\n    });\n    return {\n        transport,\n        addListener(messageId, handler) {\n            if (listeners.has(messageId))\n                throw new Error(\"There is already a handler for messageId \" + messageId);\n            listeners.set(messageId, handler);\n        },\n        removeListener(messageId) {\n            if (!listeners.has(messageId))\n                throw new Error(\"A handler is missing for messageId \" + messageId);\n            listeners.delete(messageId);\n        },\n        async request(cb) {\n            const messageNumber = ++globalMessageNumber;\n            if (globalMessageNumber > 0x01000000)\n                globalMessageNumber = 0;\n            return new Promise((resolve) => {\n                oneTimeCallbacks.set(messageNumber, resolve);\n                const bb = new minimal_1.Writer();\n                cb(bb, messageNumber);\n                transport.sendMessage(bb.finish());\n            });\n        },\n    };\n}\nexports.messageNumberHandler = messageNumberHandler;\n//# sourceMappingURL=message-number-handler.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/message-number-handler.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/protocol/helpers.js":
/*!********************************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/protocol/helpers.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parseProtocolMessage = exports.calculateMessageIdentifier = exports.parseMessageIdentifier = exports.streamAckMessage = exports.streamMessage = exports.closeStreamMessage = void 0;\nconst minimal_1 = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\nconst index_1 = __webpack_require__(/*! ./index */ \"./node_modules/@dcl/rpc/dist/protocol/index.js\");\nconst bb = new minimal_1.Writer();\nconst EMPTY_U8A = Uint8Array.of();\nfunction closeStreamMessage(messageNumber, sequenceId, portId) {\n    bb.reset();\n    index_1.StreamMessage.encode({\n        messageIdentifier: calculateMessageIdentifier(index_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE, messageNumber),\n        sequenceId,\n        portId,\n        ack: false,\n        closed: true,\n        payload: EMPTY_U8A,\n    }, bb);\n    return bb.finish();\n}\nexports.closeStreamMessage = closeStreamMessage;\nfunction streamMessage(messageNumber, sequenceId, portId, payload) {\n    bb.reset();\n    index_1.StreamMessage.encode({\n        messageIdentifier: calculateMessageIdentifier(index_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE, messageNumber),\n        sequenceId,\n        portId,\n        ack: false,\n        closed: false,\n        payload,\n    }, bb);\n    return bb.finish();\n}\nexports.streamMessage = streamMessage;\nfunction streamAckMessage(messageNumber, sequenceId, portId) {\n    bb.reset();\n    index_1.StreamMessage.encode({\n        messageIdentifier: calculateMessageIdentifier(index_1.RpcMessageTypes.RpcMessageTypes_STREAM_ACK, messageNumber),\n        sequenceId,\n        portId,\n        ack: true,\n        closed: false,\n        payload: EMPTY_U8A,\n    }, bb);\n    return bb.finish();\n}\nexports.streamAckMessage = streamAckMessage;\n// @internal\nfunction parseMessageIdentifier(value) {\n    return [(value >> 27) & 0xf, value & 0x07ffffff];\n}\nexports.parseMessageIdentifier = parseMessageIdentifier;\n// @internal\nfunction calculateMessageIdentifier(messageType, messageNumber) {\n    return ((messageType & 0xf) << 27) | (messageNumber & 0x07ffffff);\n}\nexports.calculateMessageIdentifier = calculateMessageIdentifier;\nfunction parseProtocolMessage(reader) {\n    const originalPos = reader.pos;\n    const [messageType, messageNumber] = parseMessageIdentifier(index_1.RpcMessageHeader.decode(reader).messageIdentifier);\n    reader.pos = originalPos;\n    switch (messageType) {\n        case index_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE:\n            return [messageType, index_1.CreatePortResponse.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_RESPONSE:\n            return [messageType, index_1.Response.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE:\n            return [messageType, index_1.RequestModuleResponse.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE:\n            return [messageType, index_1.StreamMessage.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_SERVER_READY:\n            return null;\n        case index_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE:\n            return [messageType, index_1.RemoteError.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_REQUEST:\n            return [messageType, index_1.Request.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT:\n            return [messageType, index_1.CreatePort.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_STREAM_ACK:\n            return [messageType, index_1.StreamMessage.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE:\n            return [messageType, index_1.RequestModule.decode(reader), messageNumber];\n        case index_1.RpcMessageTypes.RpcMessageTypes_DESTROY_PORT:\n            return [messageType, index_1.DestroyPort.decode(reader), messageNumber];\n    }\n    return null;\n}\nexports.parseProtocolMessage = parseProtocolMessage;\n//# sourceMappingURL=helpers.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/protocol/helpers.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/protocol/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/protocol/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.StreamMessage = exports.Response = exports.RemoteError = exports.Request = exports.ModuleProcedure = exports.DestroyPort = exports.RequestModuleResponse = exports.RequestModule = exports.CreatePortResponse = exports.CreatePort = exports.RpcMessageHeader = exports.rpcMessageTypesToJSON = exports.rpcMessageTypesFromJSON = exports.RpcMessageTypes = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(__webpack_require__(/*! long */ \"./node_modules/long/src/long.js\"));\nconst _m0 = __importStar(__webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\"));\nexports.protobufPackage = \"\";\n/** THIS FILE IS AUTOGENERATED */\nvar RpcMessageTypes;\n(function (RpcMessageTypes) {\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_EMPTY\"] = 0] = \"RpcMessageTypes_EMPTY\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_REQUEST\"] = 1] = \"RpcMessageTypes_REQUEST\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_RESPONSE\"] = 2] = \"RpcMessageTypes_RESPONSE\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_STREAM_MESSAGE\"] = 3] = \"RpcMessageTypes_STREAM_MESSAGE\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_STREAM_ACK\"] = 4] = \"RpcMessageTypes_STREAM_ACK\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_CREATE_PORT\"] = 5] = \"RpcMessageTypes_CREATE_PORT\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_CREATE_PORT_RESPONSE\"] = 6] = \"RpcMessageTypes_CREATE_PORT_RESPONSE\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_REQUEST_MODULE\"] = 7] = \"RpcMessageTypes_REQUEST_MODULE\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_REQUEST_MODULE_RESPONSE\"] = 8] = \"RpcMessageTypes_REQUEST_MODULE_RESPONSE\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_REMOTE_ERROR_RESPONSE\"] = 9] = \"RpcMessageTypes_REMOTE_ERROR_RESPONSE\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_DESTROY_PORT\"] = 10] = \"RpcMessageTypes_DESTROY_PORT\";\n    RpcMessageTypes[RpcMessageTypes[\"RpcMessageTypes_SERVER_READY\"] = 11] = \"RpcMessageTypes_SERVER_READY\";\n    RpcMessageTypes[RpcMessageTypes[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(RpcMessageTypes = exports.RpcMessageTypes || (exports.RpcMessageTypes = {}));\nfunction rpcMessageTypesFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"RpcMessageTypes_EMPTY\":\n            return RpcMessageTypes.RpcMessageTypes_EMPTY;\n        case 1:\n        case \"RpcMessageTypes_REQUEST\":\n            return RpcMessageTypes.RpcMessageTypes_REQUEST;\n        case 2:\n        case \"RpcMessageTypes_RESPONSE\":\n            return RpcMessageTypes.RpcMessageTypes_RESPONSE;\n        case 3:\n        case \"RpcMessageTypes_STREAM_MESSAGE\":\n            return RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE;\n        case 4:\n        case \"RpcMessageTypes_STREAM_ACK\":\n            return RpcMessageTypes.RpcMessageTypes_STREAM_ACK;\n        case 5:\n        case \"RpcMessageTypes_CREATE_PORT\":\n            return RpcMessageTypes.RpcMessageTypes_CREATE_PORT;\n        case 6:\n        case \"RpcMessageTypes_CREATE_PORT_RESPONSE\":\n            return RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE;\n        case 7:\n        case \"RpcMessageTypes_REQUEST_MODULE\":\n            return RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE;\n        case 8:\n        case \"RpcMessageTypes_REQUEST_MODULE_RESPONSE\":\n            return RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE;\n        case 9:\n        case \"RpcMessageTypes_REMOTE_ERROR_RESPONSE\":\n            return RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE;\n        case 10:\n        case \"RpcMessageTypes_DESTROY_PORT\":\n            return RpcMessageTypes.RpcMessageTypes_DESTROY_PORT;\n        case 11:\n        case \"RpcMessageTypes_SERVER_READY\":\n            return RpcMessageTypes.RpcMessageTypes_SERVER_READY;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return RpcMessageTypes.UNRECOGNIZED;\n    }\n}\nexports.rpcMessageTypesFromJSON = rpcMessageTypesFromJSON;\nfunction rpcMessageTypesToJSON(object) {\n    switch (object) {\n        case RpcMessageTypes.RpcMessageTypes_EMPTY:\n            return \"RpcMessageTypes_EMPTY\";\n        case RpcMessageTypes.RpcMessageTypes_REQUEST:\n            return \"RpcMessageTypes_REQUEST\";\n        case RpcMessageTypes.RpcMessageTypes_RESPONSE:\n            return \"RpcMessageTypes_RESPONSE\";\n        case RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE:\n            return \"RpcMessageTypes_STREAM_MESSAGE\";\n        case RpcMessageTypes.RpcMessageTypes_STREAM_ACK:\n            return \"RpcMessageTypes_STREAM_ACK\";\n        case RpcMessageTypes.RpcMessageTypes_CREATE_PORT:\n            return \"RpcMessageTypes_CREATE_PORT\";\n        case RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE:\n            return \"RpcMessageTypes_CREATE_PORT_RESPONSE\";\n        case RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE:\n            return \"RpcMessageTypes_REQUEST_MODULE\";\n        case RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE:\n            return \"RpcMessageTypes_REQUEST_MODULE_RESPONSE\";\n        case RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE:\n            return \"RpcMessageTypes_REMOTE_ERROR_RESPONSE\";\n        case RpcMessageTypes.RpcMessageTypes_DESTROY_PORT:\n            return \"RpcMessageTypes_DESTROY_PORT\";\n        case RpcMessageTypes.RpcMessageTypes_SERVER_READY:\n            return \"RpcMessageTypes_SERVER_READY\";\n        default:\n            return \"UNKNOWN\";\n    }\n}\nexports.rpcMessageTypesToJSON = rpcMessageTypesToJSON;\nfunction createBaseRpcMessageHeader() {\n    return { messageIdentifier: 0 };\n}\nexports.RpcMessageHeader = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRpcMessageHeader();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRpcMessageHeader();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseCreatePort() {\n    return { messageIdentifier: 0, portName: \"\" };\n}\nexports.CreatePort = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.portName !== \"\") {\n            writer.uint32(34).string(message.portName);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreatePort();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 4:\n                    message.portName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            portName: isSet(object.portName) ? String(object.portName) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.portName !== undefined && (obj.portName = message.portName);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseCreatePort();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.portName = (_b = object.portName) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseCreatePortResponse() {\n    return { messageIdentifier: 0, portId: 0 };\n}\nexports.CreatePortResponse = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.portId !== 0) {\n            writer.uint32(21).fixed32(message.portId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreatePortResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 2:\n                    message.portId = reader.fixed32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            portId: isSet(object.portId) ? Number(object.portId) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.portId !== undefined && (obj.portId = Math.round(message.portId));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseCreatePortResponse();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBaseRequestModule() {\n    return { messageIdentifier: 0, portId: 0, moduleName: \"\" };\n}\nexports.RequestModule = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.portId !== 0) {\n            writer.uint32(21).fixed32(message.portId);\n        }\n        if (message.moduleName !== \"\") {\n            writer.uint32(34).string(message.moduleName);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRequestModule();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 2:\n                    message.portId = reader.fixed32();\n                    break;\n                case 4:\n                    message.moduleName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            portId: isSet(object.portId) ? Number(object.portId) : 0,\n            moduleName: isSet(object.moduleName) ? String(object.moduleName) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.portId !== undefined && (obj.portId = Math.round(message.portId));\n        message.moduleName !== undefined && (obj.moduleName = message.moduleName);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseRequestModule();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;\n        message.moduleName = (_c = object.moduleName) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseRequestModuleResponse() {\n    return { messageIdentifier: 0, portId: 0, procedures: [] };\n}\nexports.RequestModuleResponse = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.portId !== 0) {\n            writer.uint32(21).fixed32(message.portId);\n        }\n        for (const v of message.procedures) {\n            exports.ModuleProcedure.encode(v, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRequestModuleResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 2:\n                    message.portId = reader.fixed32();\n                    break;\n                case 5:\n                    message.procedures.push(exports.ModuleProcedure.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            portId: isSet(object.portId) ? Number(object.portId) : 0,\n            procedures: Array.isArray(object === null || object === void 0 ? void 0 : object.procedures)\n                ? object.procedures.map((e) => exports.ModuleProcedure.fromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.portId !== undefined && (obj.portId = Math.round(message.portId));\n        if (message.procedures) {\n            obj.procedures = message.procedures.map((e) => (e ? exports.ModuleProcedure.toJSON(e) : undefined));\n        }\n        else {\n            obj.procedures = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseRequestModuleResponse();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;\n        message.procedures = ((_c = object.procedures) === null || _c === void 0 ? void 0 : _c.map((e) => exports.ModuleProcedure.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseDestroyPort() {\n    return { messageIdentifier: 0, portId: 0 };\n}\nexports.DestroyPort = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.portId !== 0) {\n            writer.uint32(21).fixed32(message.portId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDestroyPort();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 2:\n                    message.portId = reader.fixed32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            portId: isSet(object.portId) ? Number(object.portId) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.portId !== undefined && (obj.portId = Math.round(message.portId));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDestroyPort();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBaseModuleProcedure() {\n    return { procedureId: 0, procedureName: \"\" };\n}\nexports.ModuleProcedure = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.procedureId !== 0) {\n            writer.uint32(13).fixed32(message.procedureId);\n        }\n        if (message.procedureName !== \"\") {\n            writer.uint32(18).string(message.procedureName);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseModuleProcedure();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.procedureId = reader.fixed32();\n                    break;\n                case 2:\n                    message.procedureName = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            procedureId: isSet(object.procedureId) ? Number(object.procedureId) : 0,\n            procedureName: isSet(object.procedureName) ? String(object.procedureName) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.procedureId !== undefined && (obj.procedureId = Math.round(message.procedureId));\n        message.procedureName !== undefined && (obj.procedureName = message.procedureName);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseModuleProcedure();\n        message.procedureId = (_a = object.procedureId) !== null && _a !== void 0 ? _a : 0;\n        message.procedureName = (_b = object.procedureName) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseRequest() {\n    return { messageIdentifier: 0, portId: 0, procedureId: 0, payload: new Uint8Array() };\n}\nexports.Request = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.portId !== 0) {\n            writer.uint32(21).fixed32(message.portId);\n        }\n        if (message.procedureId !== 0) {\n            writer.uint32(37).fixed32(message.procedureId);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(50).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 2:\n                    message.portId = reader.fixed32();\n                    break;\n                case 4:\n                    message.procedureId = reader.fixed32();\n                    break;\n                case 6:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            portId: isSet(object.portId) ? Number(object.portId) : 0,\n            procedureId: isSet(object.procedureId) ? Number(object.procedureId) : 0,\n            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.portId !== undefined && (obj.portId = Math.round(message.portId));\n        message.procedureId !== undefined && (obj.procedureId = Math.round(message.procedureId));\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseRequest();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;\n        message.procedureId = (_c = object.procedureId) !== null && _c !== void 0 ? _c : 0;\n        message.payload = (_d = object.payload) !== null && _d !== void 0 ? _d : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseRemoteError() {\n    return { messageIdentifier: 0, errorCode: 0, errorMessage: \"\" };\n}\nexports.RemoteError = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.errorCode !== 0) {\n            writer.uint32(21).fixed32(message.errorCode);\n        }\n        if (message.errorMessage !== \"\") {\n            writer.uint32(26).string(message.errorMessage);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRemoteError();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 2:\n                    message.errorCode = reader.fixed32();\n                    break;\n                case 3:\n                    message.errorMessage = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            errorCode: isSet(object.errorCode) ? Number(object.errorCode) : 0,\n            errorMessage: isSet(object.errorMessage) ? String(object.errorMessage) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.errorCode !== undefined && (obj.errorCode = Math.round(message.errorCode));\n        message.errorMessage !== undefined && (obj.errorMessage = message.errorMessage);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseRemoteError();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.errorCode = (_b = object.errorCode) !== null && _b !== void 0 ? _b : 0;\n        message.errorMessage = (_c = object.errorMessage) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseResponse() {\n    return { messageIdentifier: 0, payload: new Uint8Array() };\n}\nexports.Response = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(50).bytes(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 6:\n                    message.payload = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseResponse();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseStreamMessage() {\n    return { messageIdentifier: 0, portId: 0, sequenceId: 0, payload: new Uint8Array(), closed: false, ack: false };\n}\nexports.StreamMessage = {\n    encode(message, writer = _m0.Writer.create()) {\n        if (message.messageIdentifier !== 0) {\n            writer.uint32(13).fixed32(message.messageIdentifier);\n        }\n        if (message.portId !== 0) {\n            writer.uint32(21).fixed32(message.portId);\n        }\n        if (message.sequenceId !== 0) {\n            writer.uint32(37).fixed32(message.sequenceId);\n        }\n        if (message.payload.length !== 0) {\n            writer.uint32(50).bytes(message.payload);\n        }\n        if (message.closed === true) {\n            writer.uint32(56).bool(message.closed);\n        }\n        if (message.ack === true) {\n            writer.uint32(64).bool(message.ack);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof _m0.Reader ? input : new _m0.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseStreamMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.messageIdentifier = reader.fixed32();\n                    break;\n                case 2:\n                    message.portId = reader.fixed32();\n                    break;\n                case 4:\n                    message.sequenceId = reader.fixed32();\n                    break;\n                case 6:\n                    message.payload = reader.bytes();\n                    break;\n                case 7:\n                    message.closed = reader.bool();\n                    break;\n                case 8:\n                    message.ack = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            messageIdentifier: isSet(object.messageIdentifier) ? Number(object.messageIdentifier) : 0,\n            portId: isSet(object.portId) ? Number(object.portId) : 0,\n            sequenceId: isSet(object.sequenceId) ? Number(object.sequenceId) : 0,\n            payload: isSet(object.payload) ? bytesFromBase64(object.payload) : new Uint8Array(),\n            closed: isSet(object.closed) ? Boolean(object.closed) : false,\n            ack: isSet(object.ack) ? Boolean(object.ack) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.messageIdentifier !== undefined && (obj.messageIdentifier = Math.round(message.messageIdentifier));\n        message.portId !== undefined && (obj.portId = Math.round(message.portId));\n        message.sequenceId !== undefined && (obj.sequenceId = Math.round(message.sequenceId));\n        message.payload !== undefined &&\n            (obj.payload = base64FromBytes(message.payload !== undefined ? message.payload : new Uint8Array()));\n        message.closed !== undefined && (obj.closed = message.closed);\n        message.ack !== undefined && (obj.ack = message.ack);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseStreamMessage();\n        message.messageIdentifier = (_a = object.messageIdentifier) !== null && _a !== void 0 ? _a : 0;\n        message.portId = (_b = object.portId) !== null && _b !== void 0 ? _b : 0;\n        message.sequenceId = (_c = object.sequenceId) !== null && _c !== void 0 ? _c : 0;\n        message.payload = (_d = object.payload) !== null && _d !== void 0 ? _d : new Uint8Array();\n        message.closed = (_e = object.closed) !== null && _e !== void 0 ? _e : false;\n        message.ack = (_f = object.ack) !== null && _f !== void 0 ? _f : false;\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\")\n        return globalThis;\n    if (typeof self !== \"undefined\")\n        return self;\n    if (typeof window !== \"undefined\")\n        return window;\n    if (typeof global !== \"undefined\")\n        return global;\n    throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || ((b64) => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n    const bin = atob(b64);\n    const arr = new Uint8Array(bin.length);\n    for (let i = 0; i < bin.length; ++i) {\n        arr[i] = bin.charCodeAt(i);\n    }\n    return arr;\n}\nconst btoa = globalThis.btoa || ((bin) => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n    const bin = [];\n    arr.forEach((byte) => {\n        bin.push(String.fromCharCode(byte));\n    });\n    return btoa(bin.join(\"\"));\n}\nif (_m0.util.Long !== long_1.default) {\n    _m0.util.Long = long_1.default;\n    _m0.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n//# sourceMappingURL=index.js.map\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/protocol/index.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/push-channel.js":
/*!****************************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/push-channel.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.AsyncQueue = exports.pushableChannel = exports.linkedList = void 0;\nfunction linkedList() {\n    let head = undefined;\n    let tail = undefined;\n    function enqueue(value) {\n        const node = {\n            value,\n        };\n        node.prev = tail;\n        if (tail) {\n            tail.next = node;\n        }\n        if (!head) {\n            head = node;\n        }\n        tail = node;\n    }\n    function remove(node) {\n        if (!node.next) {\n            tail = node.prev;\n        }\n        else {\n            const nextNode = node.next;\n            nextNode.prev = node.prev;\n        }\n        if (!node.prev) {\n            head = node.next;\n        }\n        else {\n            const prevNode = node.prev;\n            prevNode.next = node.next;\n        }\n    }\n    // removes the head node and updates the head\n    function dequeue() {\n        const ret = head;\n        if (ret) {\n            remove(ret);\n            return ret.value;\n        }\n        return undefined;\n    }\n    // signals if the list is empty\n    function isEmpty() {\n        return !head;\n    }\n    return { enqueue, dequeue, isEmpty };\n}\nexports.linkedList = linkedList;\nfunction pushableChannel(onIteratorClose) {\n    let returnLock = null;\n    const queue = linkedList();\n    let closed = false;\n    let error = null;\n    function closeAllPending() {\n        if (!queue.isEmpty()) {\n            const err = error || new Error(\"Channel was closed before deliverying the message\");\n            while (!queue.isEmpty()) {\n                const { resolve } = queue.dequeue();\n                if (resolve)\n                    resolve(err);\n            }\n        }\n    }\n    function releaseLockIfNeeded() {\n        // signal that we have a value\n        if (returnLock) {\n            const originalReturnLock = returnLock;\n            returnLock = null;\n            originalReturnLock();\n        }\n    }\n    function push(value, resolve) {\n        if (closed) {\n            resolve(new Error(\"Channel is closed\"));\n            return;\n        }\n        if (error) {\n            resolve(error);\n            return;\n        }\n        // push the value to the queue\n        queue.enqueue({ value, resolve });\n        releaseLockIfNeeded();\n    }\n    function failAndClose(errorToThrow) {\n        error = errorToThrow;\n        close();\n        closeAllPending();\n    }\n    function yieldNextResult() {\n        if (error && queue.isEmpty()) {\n            throw error;\n        }\n        if (closed && queue.isEmpty()) {\n            return { done: true, value: undefined };\n        }\n        if (!queue.isEmpty()) {\n            const node = queue.dequeue();\n            if (node.resolve)\n                node.resolve(error || undefined);\n            return {\n                done: false,\n                value: node.value,\n            };\n        }\n    }\n    function close() {\n        if (!closed) {\n            closed = true;\n            releaseLockIfNeeded();\n            onIteratorClose();\n        }\n    }\n    const iterable = {\n        async next() {\n            while (true) {\n                try {\n                    const result = yieldNextResult();\n                    if (result) {\n                        return result;\n                    }\n                    else {\n                        await new Promise((res) => (returnLock = res));\n                    }\n                }\n                catch (err) {\n                    failAndClose(err);\n                    throw err;\n                }\n            }\n        },\n        async return(value) {\n            close();\n            closeAllPending();\n            return { done: true, value };\n        },\n        async throw(e) {\n            if (error) {\n                throw error;\n            }\n            failAndClose(e);\n            return { done: true, value: undefined };\n        },\n        [Symbol.asyncIterator]() {\n            return iterable;\n        },\n    };\n    function isClosed() {\n        return closed;\n    }\n    return { iterable, push, close, failAndClose, isClosed, [Symbol.asyncIterator]: () => iterable };\n}\nexports.pushableChannel = pushableChannel;\nclass AsyncQueue {\n    constructor(requestingNext) {\n        this.requestingNext = requestingNext;\n        // enqueues > dequeues\n        this.values = linkedList();\n        // dequeues > enqueues\n        this.settlers = linkedList();\n        this.closed = false;\n        this.error = undefined;\n    }\n    [Symbol.asyncIterator]() {\n        return this;\n    }\n    enqueue(value) {\n        if (this.closed) {\n            throw new Error(\"Channel is closed\");\n        }\n        if (!this.settlers.isEmpty()) {\n            if (!this.values.isEmpty()) {\n                throw new Error(\"Illegal internal state\");\n            }\n            const settler = this.settlers.dequeue();\n            if (value instanceof Error) {\n                settler.reject(value);\n            }\n            else {\n                settler.resolve({ value });\n            }\n        }\n        else {\n            this.values.enqueue({ value });\n        }\n    }\n    /**\n     * @returns a Promise for an IteratorResult\n     */\n    async next() {\n        if (!this.values.isEmpty()) {\n            const value = this.values.dequeue();\n            return value;\n        }\n        if (this.error) {\n            throw this.error;\n        }\n        if (this.closed) {\n            if (!this.settlers.isEmpty()) {\n                throw new Error(\"Illegal internal state\");\n            }\n            return { done: true, value: undefined };\n        }\n        // Wait for new values to be enqueued\n        return new Promise((resolve, reject) => {\n            this.requestingNext(this, \"next\");\n            this.settlers.enqueue({ resolve, reject });\n        });\n    }\n    async return(value) {\n        this.close(value);\n        return { done: true, value };\n    }\n    async throw(error) {\n        this.close(error);\n        return { done: true, value: undefined };\n    }\n    close(error) {\n        if (error)\n            while (!this.settlers.isEmpty()) {\n                this.settlers.dequeue().reject(error);\n            }\n        else\n            while (!this.settlers.isEmpty()) {\n                this.settlers.dequeue().resolve({ done: true, value: undefined });\n            }\n        if (error)\n            this.error = error;\n        if (!this.closed) {\n            this.closed = true;\n            this.requestingNext(this, \"close\");\n        }\n    }\n}\nexports.AsyncQueue = AsyncQueue;\n//# sourceMappingURL=push-channel.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/push-channel.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/server.js":
/*!**********************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/server.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createRpcServer = exports.handleRequest = exports.sendStream = exports.handleDestroyPort = exports.handleRequestModule = exports.handleCreatePort = exports.createServerPort = void 0;\nconst mitt_1 = __importDefault(__webpack_require__(/*! mitt */ \"./node_modules/mitt/dist/mitt.mjs\"));\nconst minimal_1 = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\nconst ack_helper_1 = __webpack_require__(/*! ./ack-helper */ \"./node_modules/@dcl/rpc/dist/ack-helper.js\");\nconst helpers_1 = __webpack_require__(/*! ./protocol/helpers */ \"./node_modules/@dcl/rpc/dist/protocol/helpers.js\");\nconst protocol_1 = __webpack_require__(/*! ./protocol */ \"./node_modules/@dcl/rpc/dist/protocol/index.js\");\nlet lastPortId = 0;\nconst EMPTY_U8A = Uint8Array.from([]);\n// only use this writer in synchronous operations. It exists to prevent allocations\nconst unsafeSyncWriter = new minimal_1.Writer();\nfunction getServerReadyMessage() {\n    unsafeSyncWriter.reset();\n    protocol_1.RpcMessageHeader.encode({\n        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_SERVER_READY, 0),\n    }, unsafeSyncWriter);\n    return unsafeSyncWriter.finish();\n}\nconst transportStartMessageSerialized = getServerReadyMessage();\nfunction moduleProcedures(module) {\n    return Array.from(Object.entries(module)).filter(([name, value]) => typeof value == \"function\");\n}\n/**\n * @internal\n */\nfunction createServerPort(portId, portName, context) {\n    const events = (0, mitt_1.default)();\n    const loadedModules = new Map();\n    const procedures = new Map();\n    const registeredModules = new Map();\n    const port = {\n        get portId() {\n            return portId;\n        },\n        get portName() {\n            return portName;\n        },\n        ...events,\n        registerModule,\n        loadModule,\n        close,\n        callProcedure,\n    };\n    async function close() {\n        loadedModules.clear();\n        procedures.clear();\n        registeredModules.clear();\n        events.emit(\"close\", {});\n    }\n    async function registerModule(moduleName, generator) {\n        if (registeredModules.has(moduleName)) {\n            throw new Error(`module ${moduleName} is already registered for port ${portName} (${portId}))`);\n        }\n        registeredModules.set(moduleName, generator);\n    }\n    async function loadModuleFromGenerator(moduleFuture) {\n        const module = await moduleFuture;\n        const ret = {\n            procedures: [],\n        };\n        for (const [procedureName, callable] of moduleProcedures(module)) {\n            const procedureId = procedures.size + 1;\n            procedures.set(procedureId, callable);\n            ret.procedures.push({\n                procedureName,\n                callable,\n                procedureId,\n            });\n        }\n        return ret;\n    }\n    function loadModule(moduleName) {\n        if (loadedModules.has(moduleName)) {\n            return loadedModules.get(moduleName);\n        }\n        const moduleGenerator = registeredModules.get(moduleName);\n        if (!moduleGenerator) {\n            throw new Error(`Module ${moduleName} is not available for port ${portName} (${portId}))`);\n        }\n        const moduleFuture = loadModuleFromGenerator(moduleGenerator(port, context));\n        loadedModules.set(moduleName, moduleFuture);\n        return moduleFuture;\n    }\n    function callProcedure(procedureId, payload, context) {\n        const procedure = procedures.get(procedureId);\n        if (!procedure) {\n            throw new Error(`procedureId ${procedureId} is missing in ${portName} (${portId}))`);\n        }\n        return procedure(payload, context);\n    }\n    return port;\n}\nexports.createServerPort = createServerPort;\nfunction getPortFromState(portId, transport, state) {\n    var _a;\n    return (_a = state.portsByTransport.get(transport)) === null || _a === void 0 ? void 0 : _a.get(portId);\n}\n// @internal\nasync function handleCreatePort(transport, createPortMessage, messageNumber, options, handler, state, context) {\n    lastPortId++;\n    const port = createServerPort(lastPortId, createPortMessage.portName, context);\n    const byTransport = state.portsByTransport.get(transport) || new Map();\n    byTransport.set(port.portId, port);\n    state.ports.set(port.portId, port);\n    state.portsByTransport.set(transport, byTransport);\n    await handler(port, transport, context);\n    unsafeSyncWriter.reset();\n    protocol_1.CreatePortResponse.encode({\n        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT_RESPONSE, messageNumber),\n        portId: port.portId,\n    }, unsafeSyncWriter);\n    transport.sendMessage(unsafeSyncWriter.finish());\n    return port;\n}\nexports.handleCreatePort = handleCreatePort;\n// @internal\nasync function handleRequestModule(transport, requestModule, messageNumber, state) {\n    const port = getPortFromState(requestModule.portId, transport, state);\n    if (!port) {\n        throw new Error(`Cannot find port ${requestModule.portId}`);\n    }\n    const loadedModule = await port.loadModule(requestModule.moduleName);\n    unsafeSyncWriter.reset();\n    protocol_1.RequestModuleResponse.encode({\n        procedures: loadedModule.procedures,\n        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE_RESPONSE, messageNumber),\n        portId: port.portId,\n    }, unsafeSyncWriter);\n    transport.sendMessage(unsafeSyncWriter.finish());\n}\nexports.handleRequestModule = handleRequestModule;\n// @internal\nasync function handleDestroyPort(transport, request, _messageNumber, state) {\n    const port = getPortFromState(request.portId, transport, state);\n    if (port) {\n        port.emit(\"close\", {});\n    }\n}\nexports.handleDestroyPort = handleDestroyPort;\n// @internal\nasync function sendStream(ackDispatcher, transport, stream, portId, messageNumber) {\n    let sequenceNumber = 0;\n    const reusedStreamMessage = protocol_1.StreamMessage.fromJSON({\n        closed: false,\n        ack: false,\n        sequenceId: sequenceNumber,\n        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE, messageNumber),\n        payload: EMPTY_U8A,\n        portId: portId,\n    });\n    // First, tell the client that we are opening a stream. Once the client sends\n    // an ACK, we will know if they are ready to consume the first element.\n    // If the response is instead close=true, then this function returns and\n    // no stream.next() is called\n    // The following lines are called \"stream offer\" in the tests.\n    const ret = await ackDispatcher.sendWithAck(reusedStreamMessage);\n    if (ret.closed)\n        return;\n    if (!ret.ack)\n        throw new Error('Error in logic, ACK must be true');\n    // If this point is reached, then the client WANTS to consume an element of the\n    // generator\n    for await (const elem of stream) {\n        sequenceNumber++;\n        reusedStreamMessage.sequenceId = sequenceNumber;\n        reusedStreamMessage.payload = elem;\n        // sendWithAck may fail if the transport is closed, effectively ending this\n        // iterator and the underlying generator. (by exiting this for-await-of)\n        // Aditionally, the ack message is used to know WHETHER the client wants to\n        // generate another element or cancel the iterator by setting closed=true\n        const ret = await ackDispatcher.sendWithAck(reusedStreamMessage);\n        // we first check for ACK because it is the hot-code-path\n        if (ret.ack) {\n            continue;\n        }\n        else if (ret.closed) {\n            // if it was closed remotely, then we end the stream right away\n            return;\n        }\n    }\n    transport.sendMessage((0, helpers_1.closeStreamMessage)(messageNumber, sequenceNumber, portId));\n}\nexports.sendStream = sendStream;\n// @internal\nasync function handleRequest(ackDispatcher, request, messageNumber, state, transport, context) {\n    const port = getPortFromState(request.portId, transport, state);\n    if (!port) {\n        unsafeSyncWriter.reset();\n        protocol_1.RemoteError.encode({\n            messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE, messageNumber),\n            errorCode: 0,\n            errorMessage: \"invalid portId\",\n        }, unsafeSyncWriter);\n        transport.sendMessage(unsafeSyncWriter.finish());\n        return;\n    }\n    const result = await port.callProcedure(request.procedureId, request.payload, context);\n    const response = protocol_1.Response.fromJSON({\n        messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_RESPONSE, messageNumber),\n        payload: EMPTY_U8A,\n    });\n    if (result instanceof Uint8Array) {\n        response.payload = result;\n        unsafeSyncWriter.reset();\n        protocol_1.Response.encode(response, unsafeSyncWriter);\n        transport.sendMessage(unsafeSyncWriter.finish());\n    }\n    else if (result && Symbol.asyncIterator in result) {\n        await sendStream(ackDispatcher, transport, result, port.portId, messageNumber);\n    }\n    else {\n        unsafeSyncWriter.reset();\n        protocol_1.Response.encode(response, unsafeSyncWriter);\n        transport.sendMessage(unsafeSyncWriter.finish());\n    }\n}\nexports.handleRequest = handleRequest;\n/**\n * @public\n */\nfunction createRpcServer(options) {\n    const events = (0, mitt_1.default)();\n    const state = {\n        ports: new Map(),\n        portsByTransport: new Map(),\n        transports: new Set(),\n    };\n    function removeTransport(transport) {\n        const transportPorts = state.portsByTransport.get(transport);\n        state.portsByTransport.delete(transport);\n        if (transportPorts && transportPorts.size) {\n            transportPorts.forEach(($) => $.close());\n        }\n        if (state.transports.delete(transport)) {\n            events.emit(\"transportClosed\", { transport });\n        }\n    }\n    events.on(\"portClosed\", (evt) => {\n        const { port } = evt;\n        state.ports.delete(port.portId);\n    });\n    function handleTransportError(transport, error) {\n        events.emit(\"transportError\", { transport, error });\n        transport.close();\n        removeTransport(transport);\n    }\n    let handler;\n    async function handleMessage(messageType, parsedMessage, messageNumber, transport, ackHelper, context) {\n        if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST) {\n            await handleRequest(ackHelper, parsedMessage, messageNumber, state, transport, context);\n        }\n        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_REQUEST_MODULE) {\n            await handleRequestModule(transport, parsedMessage, messageNumber, state);\n        }\n        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_CREATE_PORT) {\n            const port = await handleCreatePort(transport, parsedMessage, messageNumber, options, handler, state, context);\n            port.on(\"close\", () => events.emit(\"portClosed\", { port }));\n        }\n        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_DESTROY_PORT) {\n            await handleDestroyPort(transport, parsedMessage, messageNumber, state);\n        }\n        else if (messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_ACK ||\n            messageType == protocol_1.RpcMessageTypes.RpcMessageTypes_STREAM_MESSAGE) {\n            ackHelper.receiveAck(parsedMessage, messageNumber);\n        }\n        else {\n            transport.emit(\"error\", new Error(`Unknown message from client ${JSON.stringify([messageType, parsedMessage, messageNumber])}`));\n        }\n    }\n    return {\n        ...events,\n        setHandler(_handler) {\n            handler = _handler;\n        },\n        attachTransport(newTransport, context) {\n            if (!handler) {\n                throw new Error(\"A handler was not set for this RpcServer\");\n            }\n            state.transports.add(newTransport);\n            const ackHelper = (0, ack_helper_1.createAckHelper)(newTransport);\n            newTransport.on(\"message\", async (message) => {\n                var _a;\n                try {\n                    const reader = minimal_1.Reader.create(message);\n                    const parsedMessage = (0, helpers_1.parseProtocolMessage)(reader);\n                    if (parsedMessage) {\n                        const [messageType, message, messageNumber] = parsedMessage;\n                        try {\n                            await handleMessage(messageType, message, messageNumber, newTransport, ackHelper, context);\n                        }\n                        catch (err) {\n                            (_a = options.logger) === null || _a === void 0 ? void 0 : _a.error(\"Error handling remote request\", {\n                                message: err.message,\n                                name: err.name,\n                                stack: err.stack,\n                            });\n                            unsafeSyncWriter.reset();\n                            protocol_1.RemoteError.encode({\n                                messageIdentifier: (0, helpers_1.calculateMessageIdentifier)(protocol_1.RpcMessageTypes.RpcMessageTypes_REMOTE_ERROR_RESPONSE, messageNumber),\n                                errorMessage: err.message || \"Error processing the request\",\n                                errorCode: 0,\n                            }, unsafeSyncWriter);\n                            newTransport.sendMessage(unsafeSyncWriter.finish());\n                        }\n                    }\n                    else {\n                        newTransport.emit(\"error\", new Error(`Transport received unknown message: ${message}`));\n                    }\n                }\n                catch (err) {\n                    newTransport.emit(\"error\", err);\n                }\n            });\n            newTransport.on(\"close\", () => {\n                removeTransport(newTransport);\n            });\n            newTransport.on(\"error\", (error) => {\n                var _a;\n                (_a = options.logger) === null || _a === void 0 ? void 0 : _a.error(\"Error in transport\", {\n                    message: error.message,\n                    name: error.name,\n                    stack: error.stack,\n                });\n                handleTransportError(newTransport, error);\n            });\n            // send the signal to the transport\n            newTransport.sendMessage(transportStartMessageSerialized);\n        },\n    };\n}\nexports.createRpcServer = createRpcServer;\n//# sourceMappingURL=server.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/server.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/transports/WebWorker.js":
/*!************************************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/transports/WebWorker.js ***!
  \************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WebWorkerTransport = void 0;\nconst mitt_1 = __importDefault(__webpack_require__(/*! mitt */ \"./node_modules/mitt/dist/mitt.mjs\"));\nfunction WebWorkerTransport(worker) {\n    const events = (0, mitt_1.default)();\n    worker.addEventListener(\"message\", () => events.emit(\"connect\", {}), { once: true });\n    worker.addEventListener(\"error\", (err) => {\n        if (err.error) {\n            events.emit(\"error\", err.error);\n        }\n        else if (err.message) {\n            events.emit(\"error\", Object.assign(new Error(err.message), {\n                colno: err.colno,\n                error: err.error,\n                filename: err.filename,\n                lineno: err.lineno,\n                message: err.message,\n            }));\n        }\n    });\n    worker.addEventListener(\"message\", (message) => {\n        if (message.data instanceof ArrayBuffer || message.data instanceof Uint8Array) {\n            events.emit(\"message\", message.data);\n        }\n        else {\n            throw new Error(`WebWorkerTransport: Received unknown type of message, expecting Uint8Array`);\n        }\n    });\n    const api = {\n        ...events,\n        sendMessage(message) {\n            if (message instanceof ArrayBuffer || message instanceof Uint8Array) {\n                worker.postMessage(message);\n            }\n            else {\n                throw new Error(`WebWorkerTransport: Received unknown type of message, expecting Uint8Array`);\n            }\n        },\n        close() {\n            if (\"terminate\" in worker) {\n                // tslint:disable-next-line:semicolon\n                ;\n                worker.terminate();\n            }\n            else if (\"close\" in worker) {\n                // tslint:disable-next-line:semicolon\n                ;\n                worker.close();\n            }\n            events.emit('close', {});\n        },\n    };\n    return api;\n}\nexports.WebWorkerTransport = WebWorkerTransport;\n//# sourceMappingURL=WebWorker.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/transports/WebWorker.js?");

/***/ }),

/***/ "./node_modules/@dcl/rpc/dist/types.js":
/*!*********************************************!*\
  !*** ./node_modules/@dcl/rpc/dist/types.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=types.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/rpc/dist/types.js?");

/***/ }),

/***/ "./node_modules/@dcl/urn-resolver/dist/contracts.js":
/*!**********************************************************!*\
  !*** ./node_modules/@dcl/urn-resolver/dist/contracts.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = ({\n    \"ropsten\": {\n        \"PrivateNodeWallet\": \"0x62ba62ff92917edf8ac0386fa10e3b27950bce8d\",\n        \"MANAToken\": \"0x2a8fd99c19271f4f04b1b7b9c4f7cf264b626edb\",\n        \"LANDRegistry\": \"0x255baf4096cb1723c00c4b4390a4b3028ecaa8ba\",\n        \"LANDProxy\": \"0x7a73483784ab79257bb11b96fd62a2c3ae4fb75b\",\n        \"TerraformReserve\": \"0x4bc79175f1f6fded07f04aa1b4b0465ecff6f1b3\",\n        \"ReturnVesting\": \"0x58c7e6e382c1c19c132b0361c12cbc33e2b13076\",\n        \"LegacyMarketplace\": \"0x80faa2b517b84a5aec1078d3600eab4c0b3aff56\",\n        \"Marketplace\": \"0x3d2f10c76b115db93a418ed286ca0c5abfdbf5d0\",\n        \"MarketplaceProxy\": \"0x5424912699dabaa5f2998750c1c66e73d67ad219\",\n        \"ServiceLocator\": \"0xb240b30c12d2a9ea6ba3abbf663d9ae265fbebeb\",\n        \"MortgageHelper\": \"0x0e4c24f71c8679b8af8e5a22aac3816e2b23f1cc\",\n        \"MortgageManager\": \"0x31ebb4ffd5e34acfc87ea21a0c56157188f3f0e1\",\n        \"RCNEngine\": \"0xbeE217bfe06C6FAaa2d5f2e06eBB84C5fb70d9bF\",\n        \"RCNToken\": \"0x2f45b6fb2f28a73f110400386da31044b2e953d4\",\n        \"KyberOracle\": \"0x4931d0621360187199de494a1469165079b31bfc\",\n        \"DecentralandInvite\": \"0x7557dfa02f3bd7d274851e3f627de2ed2ff390e8\",\n        \"EstateRegistry\": \"0x60e315992d5e62457215dd1e6a49d1ceb7983dfc\",\n        \"EstateProxy\": \"0x124bf28a423b2ca80b3846c3aa0eb944fe7ebb95\",\n        \"ERC721Bid\": \"0x250fa138c0a994799c7a49df3097dc71e37b3d6f\",\n        \"BidMANABurner\": \"0x01f43c3133b83086d4776027fbd152fa8a685fb4\",\n        \"AvatarNameRegistry\": \"0xd127F8d9C736d91Acdee34645e0b4C9db7178160\",\n        \"AvatarNameRegistryProxy\": \"0x2d794a7c956624fb93Eb3ff6E48D5b5d6dBA127b\",\n        \"ExclusiveMasksCollection\": \"0x30ae57840b0e9b8ea55334083d53d80b2cfe80e0\",\n        \"DCLRegistrar\": \"0xeb6f5d94d79f0750781cc962908b161b95192f53\",\n        \"DCLController\": \"0xd4e92f6ea18412dbae8b2d2b69e498a2d1064fa2\",\n        \"Catalyst\": \"0xadd085f2318e9678bbb18b3e0711328f902b374b\",\n        \"BuyAdapter\": \"0xd1e4e2880ff56cd0d5c68da9bed58bfbf0150948\",\n        \"AdapterFeeCollector\": \"0x5DC888024cB599CfDdb9E6483ED6bAe1fA9e9D18\",\n        \"AdapterConverter\": \"0x2782eb28Dcb1eF4E7632273cd4e347e130Ce4646\",\n        \"POIAllowlist\": \"0x5DC4a5C214f2161F0D5595a6dDd9352409aE3Ab4\",\n        \"NAMEDenylist\": \"0x20c6f1e86eba703a14414a0cbc1b55c89dba7a0f\",\n        \"CollectionsV2Factory\": \"0x16d8bac5b67a6b782a9081377bec413bc5bb56a6\",\n        \"VestingImpl\": \"0xc243b243a2033348730420ea55239767802a19d0\",\n        \"VestingFactory\": \"0xcbfa36f59246ae43cb827a77f6ca955b93dd6042\",\n        \"BatchVesting\": \"0xedbea1174b892f88a836f61de395f5f155d4d2a9\"\n    },\n    \"mainnet\": {\n        \"MANAToken\": \"0x0f5d2fb29fb7d3cfee444a200298f468908cc942\",\n        \"LANDRegistry\": \"0x554bb6488ba955377359bed16b84ed0822679cdc\",\n        \"LANDProxy\": \"0xf87e31492faf9a91b02ee0deaad50d51d56d5d4d\",\n        \"TerraformReserve\": \"0xcca95e580bbbd04851ebfb85f77fd46c9b91f11c\",\n        \"ReturnVesting\": \"0x79c1fdaba012b9a094c495a86ce5c6199cf86368\",\n        \"LegacyMarketplace\": \"0xb3bca6f5052c7e24726b44da7403b56a8a1b98f8\",\n        \"Marketplace\": \"0x19a8ed4860007a66805782ed7e0bed4e44fc6717\",\n        \"MarketplaceProxy\": \"0x8e5660b4ab70168b5a6feea0e0315cb49c8cd539\",\n        \"ServiceLocator\": \"0x151b11892dd6ab1f91055dcd01d23d03a2c47570\",\n        \"MortgageHelper\": \"0x90263ea5c57dc6603ca7202920735a6e31235bb9\",\n        \"MortgageManager\": \"0x9abf1295086afa0e49c60e95c437aa400c5333b8\",\n        \"RCNEngine\": \"0xba5a17f8ad40dc2c955d95c0547f3e6318bd72e7\",\n        \"RCNToken\": \"0xf970b8e36e23f7fc3fd752eea86f8be8d83375a6\",\n        \"KyberOracle\": \"0x2aaf69a2df2828b55fa4a5e30ee8c3c7cd9e5d5b\",\n        \"DecentralandInvite\": \"0xf886313f213c198458eba7ae9329525e64eb763a\",\n        \"EstateRegistry\": \"0x1784ef41af86e97f8d28afe95b573a24aeda966e\",\n        \"EstateProxy\": \"0x959e104e1a4db6317fa58f8295f586e1a978c297\",\n        \"LANDAuction\": \"0x54b7a124b44054da3692dbc56b116a35c6a3e561\",\n        \"MANABurner\": \"0xadfeb1de7876fcabeaf87df5a6c566b70f970018\",\n        \"MultiSigWallet\": \"0x4eac6325e1dbf1ac90434d39766e164dca71139e\",\n        \"Nobody\": \"0xDf861993Edbe95BAFbfA7760838f8ebbd5Afda9F\",\n        \"ERC721Bid\": \"0xe479dfd9664c693b2e2992300930b00bfde08233\",\n        \"BidMANABurner\": \"0x0fcf114c63a5387878e0da051c81cb6febd93b6c\",\n        \"MultisigContractOwner\": \"0xefc549434a03756f6e37a43757a2927605d8839b\",\n        \"AvatarNameRegistry\": \"0x894b883905bfEe2CC448880F1b59f4A762E67566\",\n        \"AvatarNameRegistryProxy\": \"0xcd816354450015A5644857FEd507afEeaE7263af\",\n        \"ExclusiveMasksCollection\": \"0xc04528c14c8ffd84c7c1fb6719b4a89853035cdd\",\n        \"Halloween2019Collection\": \"0xc1f4b0eea2bd6690930e6c66efd3e197d620b9c2\",\n        \"Halloween2019CollectionFactory\": \"0x07ccfd0fbada4ac3c22ecd38037ca5e5c0ad8cfa\",\n        \"Xmas2019Collection\": \"0xc3af02c0fd486c8e9da5788b915d6fff3f049866\",\n        \"DCLRegistrar\": \"0x2a187453064356c898cae034eaed119e1663acb8\",\n        \"DCLController\": \"0x6843291bd86857d97f0d269e698939fb10d60772\",\n        \"Catalyst\": \"0xcc054fab08127c19f621ab83ade5962cd10584ec\",\n        \"CatalystProxy\": \"0x4a2f10076101650f40342885b99b6b101d83c486\",\n        \"MCHCollection\": \"0xf64dc33a192e056bb5f0e5049356a0498b502d50\",\n        \"CommunityContestCollection\": \"0x32b7495895264ac9d0b12d32afd435453458b1c6\",\n        \"DCLLaunchCollection\": \"0xd35147be6401dcb20811f2104c33de8e97ed6818\",\n        \"DCGCollection\": \"0x3163d2cfee3183f9874e2869942cc62649eeb004\",\n        \"StaySafeCollection\": \"0x201c3af8c471e5842428b74d1e7c0249adda2a92\",\n        \"StaySafeDonation\": \"0x56505a0313ba2b4bc0be23dbb7eb71b7885fca9e\",\n        \"ClaimWearableForFree\": \"0x8dd61d1a67bce13a87e20a76c6f164c388a726d6\",\n        \"Moonshot2020Collection\": \"0x6a99abebb48819d2abe92c5e4dc4f48dc09a3ee8\",\n        \"DAOAgent\": \"0x9A6ebE7E2a7722F8200d0ffB63a1F6406A0d7dce\",\n        \"DAOEstateForwarder\": \"0x34ed9e73930290cec0cfe601809255ec1313ea18\",\n        \"LANDMiniMeToken\": \"0x20dfe381ca71ade2582094cf569a8cb020af5ab1\",\n        \"EstateMiniMeToken\": \"0x8568f23f343694650370fe5e254b55bfb704a6c7\",\n        \"BuyAdapter\": \"0xf4fbd84193f9aaf9779dedbb415a806933eb1c95\",\n        \"AdapterFeeCollector\": \"0x0d58aaae9f0c4d020486f534363f3fca7a6aecb6\",\n        \"AdapterConverter\": \"0x2859581da59bd4e16a866dd06b461b76d8e489a4\",\n        \"DappcraftMoonminerCollection\": \"0x1e1d4e6262787c8a8783a37fee698bd42aa42bec\",\n        \"DGSummer2020Collection\": \"0xbf53c33235cbfc22cef5a61a83484b86342679c5\",\n        \"PMOuttathisworldCollection\": \"0x75a3752579dc2d63ca229eebbe3537fbabf85a12\",\n        \"DgtbleHeadspaceCollection\": \"0x574f64ac2e7215cba9752b85fc73030f35166bc0\",\n        \"WonderzoneMeteorchaserCollection\": \"0x34ed0aa248f60f54dd32fbc9883d6137a491f4f3\",\n        \"BurningStore\": \"0x0822d44c2e2f96d4cccad80610134861802b2cca\",\n        \"BaseList\": \"0x21b6EFf834d7cc8c12A5Ec924939aa521F0FE83F\",\n        \"POIAllowListProxy\": \"0x0ef15a1c7a49429a36cb46d4da8c53119242b54e\",\n        \"NameDenyListProxy\": \"0x0c4c90a4f29872a2e9ef4c4be3d419792bca9a36\",\n        \"BinanceUsCollection\": \"0xa8ee490e4c4da48cc1653502c1a77479d4d818de\",\n        \"PMDreamverseEminence\": \"0x09305998a531fade369ebe30adf868c96a34e813\",\n        \"CybermikeCyberSoldier\": \"0x24d538a6265b006d4b53c45ba91af5ef60dca6cb\",\n        \"DCMeta\": \"0xe7a64f6a239ed7f5bf18caa1ce2920d0c1278129\",\n        \"WZWonderbot\": \"0x5df4602e7f38a91ea7724fc167f0c67f61604b1e\",\n        \"DGFall2020\": \"0x7038e9d2c6f5f84469a84cf9bc5f4909bb6ac5e0\",\n        \"MFSammichgamer\": \"0x30d3387ff3de2a21bef7032f82d00ff7739e403c\",\n        \"SugarclubYumi\": \"0xb5d14052d1e2bce2a2d7459d0379256e632b855d\",\n        \"EtheremonWearables\": \"0x54266bcf2ffa841af934f003d144957d5934f3ab\",\n        \"MLPekingopera\": \"0x60d8271c501501c4b8cd9ed5343ac59d1b79d993\",\n        \"ChinaFlying\": \"0x90958d4531258ca11d18396d4174a007edbc2b42\",\n        \"TechTribalMarc0matic\": \"0x480a0f4e360e8964e68858dd231c2922f1df45ef\",\n        \"DigitalAlchemy\": \"0x5cf39e64392c615fd8086838883958752a11b486\",\n        \"CZMercenaryMTZ\": \"0xc3ca6c364b854fd0a653a43f8344f8c22ddfdd26\",\n        \"WonderzoneSteampunk\": \"0xb96697fa4a3361ba35b774a42c58daccaad1b8e1\",\n        \"DCNiftyblocksmith\": \"0x102daabd1e9d294d4436ec4c521dce7b1f15499e\",\n        \"Halloween2020Collection\": \"0xfeb52cbf71b9adac957c6f948a6cf9980ac8c907\",\n        \"Xmas2020Collection\": \"0xecf073f91101ce5628669c487aee8f5822a101b1\",\n        \"MemeDontBuyThis\": \"0x1a57f6afc902d25792c53b8f19b7e17ef84222d5\",\n        \"ReleaseTheKraken\": \"0xffc5043d9a00865d089d5eefa5b3d1625aec6763\",\n        \"3LAUBasics\": \"0xe1ecb4e5130f493551c7d6df96ad19e5b431a0a9\",\n        \"XmashUp2020\": \"0xdd9c7bc159dacb19c9f6b9d7e23948c87aa2397f\",\n        \"MLLiondance\": \"0x0b1c6c75d511fae05e7dc696f4cf14129a9c43c9\",\n        \"AtariLaunch\": \"0x4c290f486bae507719c562b6b524bdb71a2570c9\",\n        \"ERC20Predicate\": \"0x40ec5B33f54e0E8A33A975908C5BA1c14e5BbbDf\",\n        \"RootChainManagerProxy\": \"0xA0c68C638235ee32657e8f720a23ceC1bFc77C77\",\n        \"RootChainProxy\": \"0x86E4Dc95c7FBdBf52e33D563BbDB00823894C287\",\n        \"RTFKTXAtari\": \"0x6b47e7066c7db71aa04a1d5872496fe05c4c331f\",\n        \"RACBasics\": \"0x68e139552c4077ce5c9ab929c7e18ca721ffff00\",\n        \"WinklevossCapital\": \"0xc82a864a94db3550bc71fcb4ce07228bcec21f1a\",\n        \"DGAtariDillonFrancis\": \"0x51e0b1afe5da0c038fc93a3fc8e11cf7a238b40b\",\n        \"DAOVotingPower\": \"0xcf9b305b4cd210079f5648f17ede69e666c0c8d4\",\n        \"TheGraphMultisig\": \"0x89FDdaB2F93417182CdCdb0B8B3322B93AB3A192\",\n        \"VestingImpl\": \"0x42f32e19365d8045661a006408cc6d1064039fbf\",\n        \"VestingFactory\": \"0xe357273545c152f07afe2c38257b7b653fd3f6d0\",\n        \"BatchVesting\": \"0xc57185366bcda81cde363380e2099758712038d0\"\n    },\n    \"kovan\": {\n        \"MANAToken\": \"0x230fc362413d9e862326c2c7084610a5a2fdf78a\",\n        \"LANDRegistry\": \"0x2059291430b9aa2F79547f657816eFb816b36614\",\n        \"LANDProxy\": \"0x537263c440943f6a6808bCb8CcB3fe03EE838aD1\",\n        \"Marketplace\": \"0x6f44f195999f06aeb5872db96cdc517f1e839f13\"\n    },\n    \"rinkeby\": {\n        \"MANAToken\": \"0x28bce5263f5d7f4eb7e8c6d5d78275ca455bac63\",\n        \"LANDProxy\": \"0x28bef22df3e2040a4be64a9ca0e8b5ae2b91462d\",\n        \"LANDRegistry\": \"0xbeea8bfb0e582be1c3fb464824e61c218ba0c1b1\",\n        \"EstateRegistry\": \"0x3f0b58ad7a8b27d0e5573cd1ca7d456e2f6d4884\",\n        \"Multisig\": \"0x0de35b8b47b129877e0efca24e294b61d7e7eee3\",\n        \"MANAMiniMeToken\": \"0xfb2712a1246f712b889692c7ce55fec25c06bc33\",\n        \"LANDMiniMeToken\": \"0x576c4577aAd561EA79acbd49215a0cC1473BfCCA\",\n        \"EstateMiniMeToken\": \"0x2b98C125733035cDE09d311F988845808EE270E6\",\n        \"DAOVotingPower\": \"0xe65835cd7c9311866ae5d260a1eb7b963899ca14\",\n        \"VestingImpl\": \"0x8493bb6ae17e12c062b0eb1fe780cc0b2df16bb2\",\n        \"VestingFactory\": \"0x64c9f713a743458ab22ec49d88dd00621f528786\"\n    },\n    \"goerli\": {\n        \"MANAToken\": \"0xe7fDae84ACaba2A5Ba817B6E6D8A2d415DBFEdbe\",\n        \"ERC20Predicate\": \"0xdD6596F2029e6233DEFfaCa316e6A95217d4Dc34\",\n        \"RootChainManagerProxy\": \"0xbbd7cbfa79faee899eaf900f13c9065bf03b1a74\",\n        \"RootChainProxy\": \"0x2890ba17efe978480615e330ecb65333b880928e\",\n        \"LANDRegistry\": \"0x0cfF059845c6Abee7De396d00091016ad72FD324\",\n        \"LANDProxy\": \"0x25b6B4bac4aDB582a0ABd475439dA6730777Fbf7\",\n        \"EstateRegistry\": \"0x5309aE874FC4eB21adCd63f8b6C3f766Cc3B1849\",\n        \"EstateProxy\": \"0xC9A46712E6913c24d15b46fF12221a79c4e251DC\",\n        \"RentalsProxyAdmin\": \"0x6ad9fb3f07a6013e6db2327e27ad0a38e858d88d\",\n        \"RentalsProxy\": \"0xbb2a03bf5f525734cb0536be4be61ba788d7ee01\",\n        \"RentalsImplementation\": \"0xe70db6319e9cee3f604909bdade58d1f5c1cf702\",\n        \"MarketplaceProxy\": \"0x5d01fbD3E22892be40F69bdAE7Ad921C8cdA2085\",\n        \"MarketplaceImplementation\": \"0x09B389B3523870798f46555fef26B4476A973E6E\",\n        \"MarketplaceLegacyNFT\": \"0x0fFc7E6D72eE2F287B877533454210621b1B7822\",\n        \"DCLRegistrar\": \"0x6b8da2752827cf926215b43bb8E46Fd7b9dDac35\",\n        \"DCLController\": \"0x6fF05B6271BBEd8F16a46e6073d27aD94224E0Ac\",\n        \"ERC721Bid\": \"0xd7dC1C183B8fFaED6b7f30fFC616Ff81B66812e5\",\n        \"ExclusiveMasksCollection\": \"0x1f0880E0b4514DC58e68B9BE91693bFA8C067ac1\",\n        \"NAMEDenylist\": \"0x71c84760df0537f7db286274817462dc2e6c1366\",\n        \"Catalyst\": \"0x380e46851c47b73b6aa9bea50cf3b50e2cf637cf\",\n        \"POIAllowlist\": \"0xb8c7a7afd42675ab61f0a3732f8d0491825a933b\"\n    },\n    \"matic\": {\n        \"MetaTxForwarder\": \"0x0baBda04f62C549A09EF3313Fe187f29c099FF3C\",\n        \"MANAToken\": \"0xA1c57f48F0Deb89f569dFbE6E2B7f46D33606fD4\",\n        \"ChildChainManagerProxy\": \"0xA6FA4fB5f76172d178d61B04b0ecd319C5d1C0aa\",\n        \"SABMultisig\": \"0x0E659A116e161d8e502F9036bAbDA51334F2667E\",\n        \"CommitteeMultisig\": \"0xB08E3e7cc815213304d884C88cA476ebC50EaAB2\",\n        \"CollectionImplementation\": \"0x006080C6061C4aF79b39Da0842a3a22A7b3f185e\",\n        \"Rarities\": \"0x17113b44fdd661A156cc01b5031E3aCF72c32EB3\",\n        \"RaritiesWithOracle\": \"0xA9158E22F89Bb3F69c5600338895Cb5FB81e5090\",\n        \"OldCommittee\": \"0x71d9350Ef44E1e451F00e447C0DfF2d1FB75510a\",\n        \"Committee\": \"0xaeec95a8aa671a6d3fec56594827d7804964fa70\",\n        \"CollectionManager \": \"0x9D32AaC179153A991e832550d9F96441Ea27763A\",\n        \"Forwarder\": \"0xBF6755A83C0dCDBB2933A96EA778E00b717d7004\",\n        \"CollectionFactory\": \"0xB549B2442b2BD0a53795BC5cDcBFE0cAF7ACA9f8\",\n        \"CollectionFactoryV3\": \"0x3195e88aE10704b359764CB38e429D24f1c2f781\",\n        \"CollectionStore\": \"0x214ffC0f0103735728dc66b61A22e4F163e275ae\",\n        \"Marketplace\": \"0x02080031b45A3c67d338Dd4A2CC309D28756A160\",\n        \"TPRAdmin\": \"0xF44063d872C88eEBab2EFC0318194e75a5218C1E\",\n        \"TPRProxy\": \"0x1C436C1EFb4608dFfDC8bace99d2B03c314f3348\",\n        \"TPR\": \"0x1f8063CC04398Be214a7d8dD25B6b6e2b870d99e\",\n        \"ChainlinkOracle\": \"0x1a91dd8d4eeddc2fac31f36818604b7093dc95e0\",\n        \"RoyaltiesManager\": \"0x90958D4531258ca11D18396d4174a007edBc2b42\",\n        \"MarketplaceV2\": \"0x480a0f4e360E8964e68858Dd231c2922f1df45Ef\",\n        \"ERC721Bid\": \"0xb96697FA4A3361Ba35B774a42c58dACcaAd1B8E1\",\n        \"FoundationEOACreator1\": \"0x6ADf75e49bAC21abab9AdB9266d2cC6d90AbD31a\",\n        \"UpgradeableBeacon\": \"0xDDb3781Fff645325C8896AA1F067bAa381607ecc\"\n    },\n    \"mumbai\": {\n        \"dAppsAdmin\": \"0xb919da06d5f81777B13Fc5CBd48635E19500Fbf5\",\n        \"MetaTxForwarder\": \"0xBF6755A83C0dCDBB2933A96EA778E00b717d7004\",\n        \"MANAToken\": \"0x882Da5967c435eA5cC6b09150d55E8304B838f45\",\n        \"ChildChainManagerProxy\": \"0xb5505a6d998549090530911180f38aC5130101c6\",\n        \"CollectionImplementation\": \"0x89c4Ad77066d9EE8aD281D5Fd995690D91436644\",\n        \"Rarities\": \"0x8eabF06f6cf667915bfF30138be70543bCE2901A\",\n        \"RaritiesWithOracle\": \"0xb9957735bbe6D42585058Af11AA72da8eAD9043a\",\n        \"OldCommittee\": \"0x4bb5ACe5ceB3Dd51ea35fa01a8f9B5507c234270\",\n        \"Committee\": \"0xe18B1361d41afC44658216F3Dc27e48c2336e3c2\",\n        \"CollectionManager \": \"0xe539E0AED3C1971560517D58277f8dd9aC296281\",\n        \"Forwarder\": \"0x71e56Ad57eca3fAAe5077b7F9ea731a25785fF92\",\n        \"CollectionFactory\": \"0x2A72Ec4241Ac4fBc915ae98aC5a5b01AdE721f4B\",\n        \"CollectionFactoryV3\": \"0xDDb3781Fff645325C8896AA1F067bAa381607ecc\",\n        \"CollectionStore\": \"0x6ddF1b1924DAD850AdBc1C02026535464Be06B0c\",\n        \"Marketplace\": \"0x2a09a000224f5dbe0E17214cA95CDe506DA7CB74\",\n        \"TPRAdmin\": \"0xa1Ee2a8bDAEF0AB178D1088Cb3Ae0537c8eB4B8e\",\n        \"TPRProxy\": \"0xEDf516F2D42A47F9cE0B145Fe0dbB76975379889\",\n        \"TPR\": \"0x3CFe76fbf8E2868075c10161667ab3Fea19cA8D2\",\n        \"ChainlinkOracle\": \"0x05b0a8195aa4c21944d68f71a263f836670e3605\",\n        \"DummyDataFeed\": \"0x5521ade5494225e0936c74f97e474107d73c406e\",\n        \"ThirdPartyTiers\": \"0xdC899B9c1Fa80292606C3cfbA88bbBf0935c2e48\",\n        \"RoyaltiesManager\": \"0x68838E6068a3a925a78546E475dE73C75e4F2651\",\n        \"MarketplaceV2\": \"0x5A467398dfa9d5C663a656423A2D055f538198A4\",\n        \"ERC721Bid\": \"0x78Dd92c8941dBC7BE54E2a9390D58aD28AD97afD\",\n        \"UpgradeableBeacon\": \"0x0c8ad1f6aadf89d2eb19f01a100a6143108fe2b0\"\n    }\n});\n//# sourceMappingURL=contracts.js.map\n\n//# sourceURL=webpack:///./node_modules/@dcl/urn-resolver/dist/contracts.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/aspromise/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@protobufjs/aspromise/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = asPromise;\r\n\r\n/**\r\n * Callback as used by {@link util.asPromise}.\r\n * @typedef asPromiseCallback\r\n * @type {function}\r\n * @param {Error|null} error Error, if any\r\n * @param {...*} params Additional arguments\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Returns a promise from a node-style callback function.\r\n * @memberof util\r\n * @param {asPromiseCallback} fn Function to call\r\n * @param {*} ctx Function context\r\n * @param {...*} params Function arguments\r\n * @returns {Promise<*>} Promisified function\r\n */\r\nfunction asPromise(fn, ctx/*, varargs */) {\r\n    var params  = new Array(arguments.length - 1),\r\n        offset  = 0,\r\n        index   = 2,\r\n        pending = true;\r\n    while (index < arguments.length)\r\n        params[offset++] = arguments[index++];\r\n    return new Promise(function executor(resolve, reject) {\r\n        params[offset] = function callback(err/*, varargs */) {\r\n            if (pending) {\r\n                pending = false;\r\n                if (err)\r\n                    reject(err);\r\n                else {\r\n                    var params = new Array(arguments.length - 1),\r\n                        offset = 0;\r\n                    while (offset < params.length)\r\n                        params[offset++] = arguments[offset];\r\n                    resolve.apply(null, params);\r\n                }\r\n            }\r\n        };\r\n        try {\r\n            fn.apply(ctx || null, params);\r\n        } catch (err) {\r\n            if (pending) {\r\n                pending = false;\r\n                reject(err);\r\n            }\r\n        }\r\n    });\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/aspromise/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/base64/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@protobufjs/base64/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal base64 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar base64 = exports;\r\n\r\n/**\r\n * Calculates the byte length of a base64 encoded string.\r\n * @param {string} string Base64 encoded string\r\n * @returns {number} Byte length\r\n */\r\nbase64.length = function length(string) {\r\n    var p = string.length;\r\n    if (!p)\r\n        return 0;\r\n    var n = 0;\r\n    while (--p % 4 > 1 && string.charAt(p) === \"=\")\r\n        ++n;\r\n    return Math.ceil(string.length * 3) / 4 - n;\r\n};\r\n\r\n// Base64 encoding table\r\nvar b64 = new Array(64);\r\n\r\n// Base64 decoding table\r\nvar s64 = new Array(123);\r\n\r\n// 65..90, 97..122, 48..57, 43, 47\r\nfor (var i = 0; i < 64;)\r\n    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;\r\n\r\n/**\r\n * Encodes a buffer to a base64 encoded string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} Base64 encoded string\r\n */\r\nbase64.encode = function encode(buffer, start, end) {\r\n    var parts = null,\r\n        chunk = [];\r\n    var i = 0, // output index\r\n        j = 0, // goto index\r\n        t;     // temporary\r\n    while (start < end) {\r\n        var b = buffer[start++];\r\n        switch (j) {\r\n            case 0:\r\n                chunk[i++] = b64[b >> 2];\r\n                t = (b & 3) << 4;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                chunk[i++] = b64[t | b >> 4];\r\n                t = (b & 15) << 2;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                chunk[i++] = b64[t | b >> 6];\r\n                chunk[i++] = b64[b & 63];\r\n                j = 0;\r\n                break;\r\n        }\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (j) {\r\n        chunk[i++] = b64[t];\r\n        chunk[i++] = 61;\r\n        if (j === 1)\r\n            chunk[i++] = 61;\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\nvar invalidEncoding = \"invalid encoding\";\r\n\r\n/**\r\n * Decodes a base64 encoded string to a buffer.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Number of bytes written\r\n * @throws {Error} If encoding is invalid\r\n */\r\nbase64.decode = function decode(string, buffer, offset) {\r\n    var start = offset;\r\n    var j = 0, // goto index\r\n        t;     // temporary\r\n    for (var i = 0; i < string.length;) {\r\n        var c = string.charCodeAt(i++);\r\n        if (c === 61 && j > 1)\r\n            break;\r\n        if ((c = s64[c]) === undefined)\r\n            throw Error(invalidEncoding);\r\n        switch (j) {\r\n            case 0:\r\n                t = c;\r\n                j = 1;\r\n                break;\r\n            case 1:\r\n                buffer[offset++] = t << 2 | (c & 48) >> 4;\r\n                t = c;\r\n                j = 2;\r\n                break;\r\n            case 2:\r\n                buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;\r\n                t = c;\r\n                j = 3;\r\n                break;\r\n            case 3:\r\n                buffer[offset++] = (t & 3) << 6 | c;\r\n                j = 0;\r\n                break;\r\n        }\r\n    }\r\n    if (j === 1)\r\n        throw Error(invalidEncoding);\r\n    return offset - start;\r\n};\r\n\r\n/**\r\n * Tests if the specified string appears to be base64 encoded.\r\n * @param {string} string String to test\r\n * @returns {boolean} `true` if probably base64 encoded, otherwise false\r\n */\r\nbase64.test = function test(string) {\r\n    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/base64/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/eventemitter/index.js":
/*!********************************************************!*\
  !*** ./node_modules/@protobufjs/eventemitter/index.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = EventEmitter;\r\n\r\n/**\r\n * Constructs a new event emitter instance.\r\n * @classdesc A minimal event emitter.\r\n * @memberof util\r\n * @constructor\r\n */\r\nfunction EventEmitter() {\r\n\r\n    /**\r\n     * Registered listeners.\r\n     * @type {Object.<string,*>}\r\n     * @private\r\n     */\r\n    this._listeners = {};\r\n}\r\n\r\n/**\r\n * Registers an event listener.\r\n * @param {string} evt Event name\r\n * @param {function} fn Listener\r\n * @param {*} [ctx] Listener context\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.on = function on(evt, fn, ctx) {\r\n    (this._listeners[evt] || (this._listeners[evt] = [])).push({\r\n        fn  : fn,\r\n        ctx : ctx || this\r\n    });\r\n    return this;\r\n};\r\n\r\n/**\r\n * Removes an event listener or any matching listeners if arguments are omitted.\r\n * @param {string} [evt] Event name. Removes all listeners if omitted.\r\n * @param {function} [fn] Listener to remove. Removes all listeners of `evt` if omitted.\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.off = function off(evt, fn) {\r\n    if (evt === undefined)\r\n        this._listeners = {};\r\n    else {\r\n        if (fn === undefined)\r\n            this._listeners[evt] = [];\r\n        else {\r\n            var listeners = this._listeners[evt];\r\n            for (var i = 0; i < listeners.length;)\r\n                if (listeners[i].fn === fn)\r\n                    listeners.splice(i, 1);\r\n                else\r\n                    ++i;\r\n        }\r\n    }\r\n    return this;\r\n};\r\n\r\n/**\r\n * Emits an event by calling its listeners with the specified arguments.\r\n * @param {string} evt Event name\r\n * @param {...*} args Arguments\r\n * @returns {util.EventEmitter} `this`\r\n */\r\nEventEmitter.prototype.emit = function emit(evt) {\r\n    var listeners = this._listeners[evt];\r\n    if (listeners) {\r\n        var args = [],\r\n            i = 1;\r\n        for (; i < arguments.length;)\r\n            args.push(arguments[i++]);\r\n        for (i = 0; i < listeners.length;)\r\n            listeners[i].fn.apply(listeners[i++].ctx, args);\r\n    }\r\n    return this;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/eventemitter/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/float/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@protobufjs/float/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\nmodule.exports = factory(factory);\r\n\r\n/**\r\n * Reads / writes floats / doubles from / to buffers.\r\n * @name util.float\r\n * @namespace\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using little endian byte order.\r\n * @name util.float.writeFloatLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 32 bit float to a buffer using big endian byte order.\r\n * @name util.float.writeFloatBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using little endian byte order.\r\n * @name util.float.readFloatLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 32 bit float from a buffer using big endian byte order.\r\n * @name util.float.readFloatBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using little endian byte order.\r\n * @name util.float.writeDoubleLE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Writes a 64 bit double to a buffer using big endian byte order.\r\n * @name util.float.writeDoubleBE\r\n * @function\r\n * @param {number} val Value to write\r\n * @param {Uint8Array} buf Target buffer\r\n * @param {number} pos Target buffer offset\r\n * @returns {undefined}\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using little endian byte order.\r\n * @name util.float.readDoubleLE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n/**\r\n * Reads a 64 bit double from a buffer using big endian byte order.\r\n * @name util.float.readDoubleBE\r\n * @function\r\n * @param {Uint8Array} buf Source buffer\r\n * @param {number} pos Source buffer offset\r\n * @returns {number} Value read\r\n */\r\n\r\n// Factory function for the purpose of node-based testing in modified global environments\r\nfunction factory(exports) {\r\n\r\n    // float: typed array\r\n    if (typeof Float32Array !== \"undefined\") (function() {\r\n\r\n        var f32 = new Float32Array([ -0 ]),\r\n            f8b = new Uint8Array(f32.buffer),\r\n            le  = f8b[3] === 128;\r\n\r\n        function writeFloat_f32_cpy(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n        }\r\n\r\n        function writeFloat_f32_rev(val, buf, pos) {\r\n            f32[0] = val;\r\n            buf[pos    ] = f8b[3];\r\n            buf[pos + 1] = f8b[2];\r\n            buf[pos + 2] = f8b[1];\r\n            buf[pos + 3] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;\r\n\r\n        function readFloat_f32_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        function readFloat_f32_rev(buf, pos) {\r\n            f8b[3] = buf[pos    ];\r\n            f8b[2] = buf[pos + 1];\r\n            f8b[1] = buf[pos + 2];\r\n            f8b[0] = buf[pos + 3];\r\n            return f32[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;\r\n        /* istanbul ignore next */\r\n        exports.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;\r\n\r\n    // float: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeFloat_ieee754(writeUint, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0)\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos);\r\n            else if (isNaN(val))\r\n                writeUint(2143289344, buf, pos);\r\n            else if (val > 3.4028234663852886e+38) // +-Infinity\r\n                writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);\r\n            else if (val < 1.1754943508222875e-38) // denormal\r\n                writeUint((sign << 31 | Math.round(val / 1.401298464324817e-45)) >>> 0, buf, pos);\r\n            else {\r\n                var exponent = Math.floor(Math.log(val) / Math.LN2),\r\n                    mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;\r\n                writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);\r\n            }\r\n        }\r\n\r\n        exports.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);\r\n        exports.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);\r\n\r\n        function readFloat_ieee754(readUint, buf, pos) {\r\n            var uint = readUint(buf, pos),\r\n                sign = (uint >> 31) * 2 + 1,\r\n                exponent = uint >>> 23 & 255,\r\n                mantissa = uint & 8388607;\r\n            return exponent === 255\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 1.401298464324817e-45 * mantissa\r\n                : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);\r\n        }\r\n\r\n        exports.readFloatLE = readFloat_ieee754.bind(null, readUintLE);\r\n        exports.readFloatBE = readFloat_ieee754.bind(null, readUintBE);\r\n\r\n    })();\r\n\r\n    // double: typed array\r\n    if (typeof Float64Array !== \"undefined\") (function() {\r\n\r\n        var f64 = new Float64Array([-0]),\r\n            f8b = new Uint8Array(f64.buffer),\r\n            le  = f8b[7] === 128;\r\n\r\n        function writeDouble_f64_cpy(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[0];\r\n            buf[pos + 1] = f8b[1];\r\n            buf[pos + 2] = f8b[2];\r\n            buf[pos + 3] = f8b[3];\r\n            buf[pos + 4] = f8b[4];\r\n            buf[pos + 5] = f8b[5];\r\n            buf[pos + 6] = f8b[6];\r\n            buf[pos + 7] = f8b[7];\r\n        }\r\n\r\n        function writeDouble_f64_rev(val, buf, pos) {\r\n            f64[0] = val;\r\n            buf[pos    ] = f8b[7];\r\n            buf[pos + 1] = f8b[6];\r\n            buf[pos + 2] = f8b[5];\r\n            buf[pos + 3] = f8b[4];\r\n            buf[pos + 4] = f8b[3];\r\n            buf[pos + 5] = f8b[2];\r\n            buf[pos + 6] = f8b[1];\r\n            buf[pos + 7] = f8b[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;\r\n\r\n        function readDouble_f64_cpy(buf, pos) {\r\n            f8b[0] = buf[pos    ];\r\n            f8b[1] = buf[pos + 1];\r\n            f8b[2] = buf[pos + 2];\r\n            f8b[3] = buf[pos + 3];\r\n            f8b[4] = buf[pos + 4];\r\n            f8b[5] = buf[pos + 5];\r\n            f8b[6] = buf[pos + 6];\r\n            f8b[7] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        function readDouble_f64_rev(buf, pos) {\r\n            f8b[7] = buf[pos    ];\r\n            f8b[6] = buf[pos + 1];\r\n            f8b[5] = buf[pos + 2];\r\n            f8b[4] = buf[pos + 3];\r\n            f8b[3] = buf[pos + 4];\r\n            f8b[2] = buf[pos + 5];\r\n            f8b[1] = buf[pos + 6];\r\n            f8b[0] = buf[pos + 7];\r\n            return f64[0];\r\n        }\r\n\r\n        /* istanbul ignore next */\r\n        exports.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;\r\n        /* istanbul ignore next */\r\n        exports.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;\r\n\r\n    // double: ieee754\r\n    })(); else (function() {\r\n\r\n        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {\r\n            var sign = val < 0 ? 1 : 0;\r\n            if (sign)\r\n                val = -val;\r\n            if (val === 0) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(1 / val > 0 ? /* positive */ 0 : /* negative 0 */ 2147483648, buf, pos + off1);\r\n            } else if (isNaN(val)) {\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint(2146959360, buf, pos + off1);\r\n            } else if (val > 1.7976931348623157e+308) { // +-Infinity\r\n                writeUint(0, buf, pos + off0);\r\n                writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);\r\n            } else {\r\n                var mantissa;\r\n                if (val < 2.2250738585072014e-308) { // denormal\r\n                    mantissa = val / 5e-324;\r\n                    writeUint(mantissa >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);\r\n                } else {\r\n                    var exponent = Math.floor(Math.log(val) / Math.LN2);\r\n                    if (exponent === 1024)\r\n                        exponent = 1023;\r\n                    mantissa = val * Math.pow(2, -exponent);\r\n                    writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);\r\n                    writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);\r\n                }\r\n            }\r\n        }\r\n\r\n        exports.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);\r\n        exports.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);\r\n\r\n        function readDouble_ieee754(readUint, off0, off1, buf, pos) {\r\n            var lo = readUint(buf, pos + off0),\r\n                hi = readUint(buf, pos + off1);\r\n            var sign = (hi >> 31) * 2 + 1,\r\n                exponent = hi >>> 20 & 2047,\r\n                mantissa = 4294967296 * (hi & 1048575) + lo;\r\n            return exponent === 2047\r\n                ? mantissa\r\n                ? NaN\r\n                : sign * Infinity\r\n                : exponent === 0 // denormal\r\n                ? sign * 5e-324 * mantissa\r\n                : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);\r\n        }\r\n\r\n        exports.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);\r\n        exports.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);\r\n\r\n    })();\r\n\r\n    return exports;\r\n}\r\n\r\n// uint helpers\r\n\r\nfunction writeUintLE(val, buf, pos) {\r\n    buf[pos    ] =  val        & 255;\r\n    buf[pos + 1] =  val >>> 8  & 255;\r\n    buf[pos + 2] =  val >>> 16 & 255;\r\n    buf[pos + 3] =  val >>> 24;\r\n}\r\n\r\nfunction writeUintBE(val, buf, pos) {\r\n    buf[pos    ] =  val >>> 24;\r\n    buf[pos + 1] =  val >>> 16 & 255;\r\n    buf[pos + 2] =  val >>> 8  & 255;\r\n    buf[pos + 3] =  val        & 255;\r\n}\r\n\r\nfunction readUintLE(buf, pos) {\r\n    return (buf[pos    ]\r\n          | buf[pos + 1] << 8\r\n          | buf[pos + 2] << 16\r\n          | buf[pos + 3] << 24) >>> 0;\r\n}\r\n\r\nfunction readUintBE(buf, pos) {\r\n    return (buf[pos    ] << 24\r\n          | buf[pos + 1] << 16\r\n          | buf[pos + 2] << 8\r\n          | buf[pos + 3]) >>> 0;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/float/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/inquire/index.js":
/*!***************************************************!*\
  !*** ./node_modules/@protobufjs/inquire/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = inquire;\r\n\r\n/**\r\n * Requires a module only if available.\r\n * @memberof util\r\n * @param {string} moduleName Module to require\r\n * @returns {?Object} Required module if available and not empty, otherwise `null`\r\n */\r\nfunction inquire(moduleName) {\r\n    try {\r\n        var mod = eval(\"quire\".replace(/^/,\"re\"))(moduleName); // eslint-disable-line no-eval\r\n        if (mod && (mod.length || Object.keys(mod).length))\r\n            return mod;\r\n    } catch (e) {} // eslint-disable-line no-empty\r\n    return null;\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/inquire/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/pool/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/pool/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\nmodule.exports = pool;\r\n\r\n/**\r\n * An allocator as used by {@link util.pool}.\r\n * @typedef PoolAllocator\r\n * @type {function}\r\n * @param {number} size Buffer size\r\n * @returns {Uint8Array} Buffer\r\n */\r\n\r\n/**\r\n * A slicer as used by {@link util.pool}.\r\n * @typedef PoolSlicer\r\n * @type {function}\r\n * @param {number} start Start offset\r\n * @param {number} end End offset\r\n * @returns {Uint8Array} Buffer slice\r\n * @this {Uint8Array}\r\n */\r\n\r\n/**\r\n * A general purpose buffer pool.\r\n * @memberof util\r\n * @function\r\n * @param {PoolAllocator} alloc Allocator\r\n * @param {PoolSlicer} slice Slicer\r\n * @param {number} [size=8192] Slab size\r\n * @returns {PoolAllocator} Pooled allocator\r\n */\r\nfunction pool(alloc, slice, size) {\r\n    var SIZE   = size || 8192;\r\n    var MAX    = SIZE >>> 1;\r\n    var slab   = null;\r\n    var offset = SIZE;\r\n    return function pool_alloc(size) {\r\n        if (size < 1 || size > MAX)\r\n            return alloc(size);\r\n        if (offset + size > SIZE) {\r\n            slab = alloc(SIZE);\r\n            offset = 0;\r\n        }\r\n        var buf = slice.call(slab, offset, offset += size);\r\n        if (offset & 7) // align to 32 bit\r\n            offset = (offset | 7) + 1;\r\n        return buf;\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/pool/index.js?");

/***/ }),

/***/ "./node_modules/@protobufjs/utf8/index.js":
/*!************************************************!*\
  !*** ./node_modules/@protobufjs/utf8/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\r\n\r\n/**\r\n * A minimal UTF8 implementation for number arrays.\r\n * @memberof util\r\n * @namespace\r\n */\r\nvar utf8 = exports;\r\n\r\n/**\r\n * Calculates the UTF8 byte length of a string.\r\n * @param {string} string String\r\n * @returns {number} Byte length\r\n */\r\nutf8.length = function utf8_length(string) {\r\n    var len = 0,\r\n        c = 0;\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c = string.charCodeAt(i);\r\n        if (c < 128)\r\n            len += 1;\r\n        else if (c < 2048)\r\n            len += 2;\r\n        else if ((c & 0xFC00) === 0xD800 && (string.charCodeAt(i + 1) & 0xFC00) === 0xDC00) {\r\n            ++i;\r\n            len += 4;\r\n        } else\r\n            len += 3;\r\n    }\r\n    return len;\r\n};\r\n\r\n/**\r\n * Reads UTF8 bytes as a string.\r\n * @param {Uint8Array} buffer Source buffer\r\n * @param {number} start Source start\r\n * @param {number} end Source end\r\n * @returns {string} String read\r\n */\r\nutf8.read = function utf8_read(buffer, start, end) {\r\n    var len = end - start;\r\n    if (len < 1)\r\n        return \"\";\r\n    var parts = null,\r\n        chunk = [],\r\n        i = 0, // char offset\r\n        t;     // temporary\r\n    while (start < end) {\r\n        t = buffer[start++];\r\n        if (t < 128)\r\n            chunk[i++] = t;\r\n        else if (t > 191 && t < 224)\r\n            chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;\r\n        else if (t > 239 && t < 365) {\r\n            t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 0x10000;\r\n            chunk[i++] = 0xD800 + (t >> 10);\r\n            chunk[i++] = 0xDC00 + (t & 1023);\r\n        } else\r\n            chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;\r\n        if (i > 8191) {\r\n            (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));\r\n            i = 0;\r\n        }\r\n    }\r\n    if (parts) {\r\n        if (i)\r\n            parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));\r\n        return parts.join(\"\");\r\n    }\r\n    return String.fromCharCode.apply(String, chunk.slice(0, i));\r\n};\r\n\r\n/**\r\n * Writes a string as UTF8 bytes.\r\n * @param {string} string Source string\r\n * @param {Uint8Array} buffer Destination buffer\r\n * @param {number} offset Destination offset\r\n * @returns {number} Bytes written\r\n */\r\nutf8.write = function utf8_write(string, buffer, offset) {\r\n    var start = offset,\r\n        c1, // character 1\r\n        c2; // character 2\r\n    for (var i = 0; i < string.length; ++i) {\r\n        c1 = string.charCodeAt(i);\r\n        if (c1 < 128) {\r\n            buffer[offset++] = c1;\r\n        } else if (c1 < 2048) {\r\n            buffer[offset++] = c1 >> 6       | 192;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else if ((c1 & 0xFC00) === 0xD800 && ((c2 = string.charCodeAt(i + 1)) & 0xFC00) === 0xDC00) {\r\n            c1 = 0x10000 + ((c1 & 0x03FF) << 10) + (c2 & 0x03FF);\r\n            ++i;\r\n            buffer[offset++] = c1 >> 18      | 240;\r\n            buffer[offset++] = c1 >> 12 & 63 | 128;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        } else {\r\n            buffer[offset++] = c1 >> 12      | 224;\r\n            buffer[offset++] = c1 >> 6  & 63 | 128;\r\n            buffer[offset++] = c1       & 63 | 128;\r\n        }\r\n    }\r\n    return offset - start;\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/@protobufjs/utf8/index.js?");

/***/ }),

/***/ "./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js":
/*!**************************************************************************!*\
  !*** ./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js ***!
  \**************************************************************************/
/*! exports provided: WebWorkerTransport */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WebWorkerTransport\", function() { return WebWorkerTransport; });\nfunction WebWorkerTransport(worker) {\n    const api = {\n        onConnect(handler) {\n            worker.addEventListener('message', () => handler(), { once: true });\n        },\n        onError(handler) {\n            worker.addEventListener('error', (err) => {\n                if (err.error) {\n                    handler(err.error);\n                }\n                else if (err.message) {\n                    handler(Object.assign(new Error(err.message), {\n                        colno: err.colno,\n                        error: err.error,\n                        filename: err.filename,\n                        lineno: err.lineno,\n                        message: err.message\n                    }));\n                }\n            });\n        },\n        onMessage(handler) {\n            worker.addEventListener('message', (message) => {\n                handler(message.data);\n            });\n        },\n        sendMessage(message) {\n            worker.postMessage(message);\n        },\n        close() {\n            if ('terminate' in worker) {\n                ;\n                worker.terminate();\n            }\n            else if ('close' in worker) {\n                ;\n                worker.close();\n            }\n        }\n    };\n    return api;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiV2ViV29ya2VyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NvbW1vbi90cmFuc3BvcnRzL1dlYldvcmtlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFTQSxNQUFNLFVBQVUsa0JBQWtCLENBQUMsTUFBZTtJQUNoRCxNQUFNLEdBQUcsR0FBdUI7UUFDOUIsU0FBUyxDQUFDLE9BQU87WUFDZixNQUFNLENBQUMsZ0JBQWdCLENBQUMsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLE9BQU8sRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxDQUFDLENBQUE7UUFDckUsQ0FBQztRQUNELE9BQU8sQ0FBQyxPQUFPO1lBQ2IsTUFBTSxDQUFDLGdCQUFnQixDQUFDLE9BQU8sRUFBRSxDQUFDLEdBQWUsRUFBRSxFQUFFO2dCQUNuRCxJQUFJLEdBQUcsQ0FBQyxLQUFLLEVBQUU7b0JBQ2IsT0FBTyxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQTtpQkFDbkI7cUJBQU0sSUFBSSxHQUFHLENBQUMsT0FBTyxFQUFFO29CQUN0QixPQUFPLENBQ0wsTUFBTSxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEVBQUU7d0JBQ3BDLEtBQUssRUFBRSxHQUFHLENBQUMsS0FBSzt3QkFDaEIsS0FBSyxFQUFFLEdBQUcsQ0FBQyxLQUFLO3dCQUNoQixRQUFRLEVBQUUsR0FBRyxDQUFDLFFBQVE7d0JBQ3RCLE1BQU0sRUFBRSxHQUFHLENBQUMsTUFBTTt3QkFDbEIsT0FBTyxFQUFFLEdBQUcsQ0FBQyxPQUFPO3FCQUNyQixDQUFDLENBQ0gsQ0FBQTtpQkFDRjtZQUNILENBQUMsQ0FBQyxDQUFBO1FBQ0osQ0FBQztRQUNELFNBQVMsQ0FBQyxPQUFPO1lBQ2YsTUFBTSxDQUFDLGdCQUFnQixDQUFDLFNBQVMsRUFBRSxDQUFDLE9BQXFCLEVBQUUsRUFBRTtnQkFDM0QsT0FBTyxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQTtZQUN2QixDQUFDLENBQUMsQ0FBQTtRQUNKLENBQUM7UUFDRCxXQUFXLENBQUMsT0FBTztZQUNqQixNQUFNLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxDQUFBO1FBQzdCLENBQUM7UUFDRCxLQUFLO1lBQ0gsSUFBSSxXQUFXLElBQUksTUFBTSxFQUFFO2dCQUV6QixDQUFDO2dCQUFDLE1BQWMsQ0FBQyxTQUFTLEVBQUUsQ0FBQTthQUM3QjtpQkFBTSxJQUFJLE9BQU8sSUFBSSxNQUFNLEVBQUU7Z0JBRTVCLENBQUM7Z0JBQUMsTUFBYyxDQUFDLEtBQUssRUFBRSxDQUFBO2FBQ3pCO1FBQ0gsQ0FBQztLQUNGLENBQUE7SUFFRCxPQUFPLEdBQUcsQ0FBQTtBQUNaLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTY3JpcHRpbmdUcmFuc3BvcnQgfSBmcm9tICcuLi9qc29uLXJwYy90eXBlcydcblxuZXhwb3J0IGludGVyZmFjZSBJV29ya2VyIHtcbiAgdGVybWluYXRlPygpOiB2b2lkXG4gIGNsb3NlPygpOiB2b2lkXG4gIHBvc3RNZXNzYWdlKG1lc3NhZ2U6IGFueSk6IHZvaWRcbiAgYWRkRXZlbnRMaXN0ZW5lcih0eXBlOiAnbWVzc2FnZScgfCAnZXJyb3InLCBsaXN0ZW5lcjogRnVuY3Rpb24sIG9wdGlvbnM/OiBhbnkpOiB2b2lkXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBXZWJXb3JrZXJUcmFuc3BvcnQod29ya2VyOiBJV29ya2VyKTogU2NyaXB0aW5nVHJhbnNwb3J0IHtcbiAgY29uc3QgYXBpOiBTY3JpcHRpbmdUcmFuc3BvcnQgPSB7XG4gICAgb25Db25uZWN0KGhhbmRsZXIpIHtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKCkgPT4gaGFuZGxlcigpLCB7IG9uY2U6IHRydWUgfSlcbiAgICB9LFxuICAgIG9uRXJyb3IoaGFuZGxlcikge1xuICAgICAgd29ya2VyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGVycjogRXJyb3JFdmVudCkgPT4ge1xuICAgICAgICBpZiAoZXJyLmVycm9yKSB7XG4gICAgICAgICAgaGFuZGxlcihlcnIuZXJyb3IpXG4gICAgICAgIH0gZWxzZSBpZiAoZXJyLm1lc3NhZ2UpIHtcbiAgICAgICAgICBoYW5kbGVyKFxuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihuZXcgRXJyb3IoZXJyLm1lc3NhZ2UpLCB7XG4gICAgICAgICAgICAgIGNvbG5vOiBlcnIuY29sbm8sXG4gICAgICAgICAgICAgIGVycm9yOiBlcnIuZXJyb3IsXG4gICAgICAgICAgICAgIGZpbGVuYW1lOiBlcnIuZmlsZW5hbWUsXG4gICAgICAgICAgICAgIGxpbmVubzogZXJyLmxpbmVubyxcbiAgICAgICAgICAgICAgbWVzc2FnZTogZXJyLm1lc3NhZ2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0sXG4gICAgb25NZXNzYWdlKGhhbmRsZXIpIHtcbiAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKG1lc3NhZ2U6IE1lc3NhZ2VFdmVudCkgPT4ge1xuICAgICAgICBoYW5kbGVyKG1lc3NhZ2UuZGF0YSlcbiAgICAgIH0pXG4gICAgfSxcbiAgICBzZW5kTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICB3b3JrZXIucG9zdE1lc3NhZ2UobWVzc2FnZSlcbiAgICB9LFxuICAgIGNsb3NlKCkge1xuICAgICAgaWYgKCd0ZXJtaW5hdGUnIGluIHdvcmtlcikge1xuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6c2VtaWNvbG9uXG4gICAgICAgIDsod29ya2VyIGFzIGFueSkudGVybWluYXRlKClcbiAgICAgIH0gZWxzZSBpZiAoJ2Nsb3NlJyBpbiB3b3JrZXIpIHtcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOnNlbWljb2xvblxuICAgICAgICA7KHdvcmtlciBhcyBhbnkpLmNsb3NlKClcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gYXBpXG59XG4iXX0=\n\n//# sourceURL=webpack:///./node_modules/decentraland-rpc/lib/common/transports/WebWorker.js?");

/***/ }),

/***/ "./node_modules/eventemitter3/index.js":
/*!*********************************************!*\
  !*** ./node_modules/eventemitter3/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack:///./node_modules/eventemitter3/index.js?");

/***/ }),

/***/ "./node_modules/long/src/long.js":
/*!***************************************!*\
  !*** ./node_modules/long/src/long.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = Long;\r\n\r\n/**\r\n * wasm optimizations, to do native i64 multiplication and divide\r\n */\r\nvar wasm = null;\r\n\r\ntry {\r\n  wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([\r\n    0, 97, 115, 109, 1, 0, 0, 0, 1, 13, 2, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 1, 127, 3, 7, 6, 0, 1, 1, 1, 1, 1, 6, 6, 1, 127, 1, 65, 0, 11, 7, 50, 6, 3, 109, 117, 108, 0, 1, 5, 100, 105, 118, 95, 115, 0, 2, 5, 100, 105, 118, 95, 117, 0, 3, 5, 114, 101, 109, 95, 115, 0, 4, 5, 114, 101, 109, 95, 117, 0, 5, 8, 103, 101, 116, 95, 104, 105, 103, 104, 0, 0, 10, 191, 1, 6, 4, 0, 35, 0, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 126, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 127, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 128, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 129, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11, 36, 1, 1, 126, 32, 0, 173, 32, 1, 173, 66, 32, 134, 132, 32, 2, 173, 32, 3, 173, 66, 32, 134, 132, 130, 34, 4, 66, 32, 135, 167, 36, 0, 32, 4, 167, 11\r\n  ])), {}).exports;\r\n} catch (e) {\r\n  // no wasm support :(\r\n}\r\n\r\n/**\r\n * Constructs a 64 bit two's-complement integer, given its low and high 32 bit values as *signed* integers.\r\n *  See the from* functions below for more convenient ways of constructing Longs.\r\n * @exports Long\r\n * @class A Long class for representing a 64 bit two's-complement integer value.\r\n * @param {number} low The low (signed) 32 bits of the long\r\n * @param {number} high The high (signed) 32 bits of the long\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @constructor\r\n */\r\nfunction Long(low, high, unsigned) {\r\n\r\n    /**\r\n     * The low 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.low = low | 0;\r\n\r\n    /**\r\n     * The high 32 bits as a signed value.\r\n     * @type {number}\r\n     */\r\n    this.high = high | 0;\r\n\r\n    /**\r\n     * Whether unsigned or not.\r\n     * @type {boolean}\r\n     */\r\n    this.unsigned = !!unsigned;\r\n}\r\n\r\n// The internal representation of a long is the two given signed, 32-bit values.\r\n// We use 32-bit pieces because these are the size of integers on which\r\n// Javascript performs bit-operations.  For operations like addition and\r\n// multiplication, we split each number into 16 bit pieces, which can easily be\r\n// multiplied within Javascript's floating-point representation without overflow\r\n// or change in sign.\r\n//\r\n// In the algorithms below, we frequently reduce the negative case to the\r\n// positive case by negating the input(s) and then post-processing the result.\r\n// Note that we must ALWAYS check specially whether those values are MIN_VALUE\r\n// (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\r\n// a positive number, it overflows back into a negative).  Not handling this\r\n// case would often result in infinite recursion.\r\n//\r\n// Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the from*\r\n// methods on which they depend.\r\n\r\n/**\r\n * An indicator used to reliably determine if an object is a Long or not.\r\n * @type {boolean}\r\n * @const\r\n * @private\r\n */\r\nLong.prototype.__isLong__;\r\n\r\nObject.defineProperty(Long.prototype, \"__isLong__\", { value: true });\r\n\r\n/**\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n * @inner\r\n */\r\nfunction isLong(obj) {\r\n    return (obj && obj[\"__isLong__\"]) === true;\r\n}\r\n\r\n/**\r\n * Tests if the specified object is a Long.\r\n * @function\r\n * @param {*} obj Object\r\n * @returns {boolean}\r\n */\r\nLong.isLong = isLong;\r\n\r\n/**\r\n * A cache of the Long representations of small integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar INT_CACHE = {};\r\n\r\n/**\r\n * A cache of the Long representations of small unsigned integer values.\r\n * @type {!Object}\r\n * @inner\r\n */\r\nvar UINT_CACHE = {};\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromInt(value, unsigned) {\r\n    var obj, cachedObj, cache;\r\n    if (unsigned) {\r\n        value >>>= 0;\r\n        if (cache = (0 <= value && value < 256)) {\r\n            cachedObj = UINT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, (value | 0) < 0 ? -1 : 0, true);\r\n        if (cache)\r\n            UINT_CACHE[value] = obj;\r\n        return obj;\r\n    } else {\r\n        value |= 0;\r\n        if (cache = (-128 <= value && value < 128)) {\r\n            cachedObj = INT_CACHE[value];\r\n            if (cachedObj)\r\n                return cachedObj;\r\n        }\r\n        obj = fromBits(value, value < 0 ? -1 : 0, false);\r\n        if (cache)\r\n            INT_CACHE[value] = obj;\r\n        return obj;\r\n    }\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given 32 bit integer value.\r\n * @function\r\n * @param {number} value The 32 bit integer in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromInt = fromInt;\r\n\r\n/**\r\n * @param {number} value\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromNumber(value, unsigned) {\r\n    if (isNaN(value))\r\n        return unsigned ? UZERO : ZERO;\r\n    if (unsigned) {\r\n        if (value < 0)\r\n            return UZERO;\r\n        if (value >= TWO_PWR_64_DBL)\r\n            return MAX_UNSIGNED_VALUE;\r\n    } else {\r\n        if (value <= -TWO_PWR_63_DBL)\r\n            return MIN_VALUE;\r\n        if (value + 1 >= TWO_PWR_63_DBL)\r\n            return MAX_VALUE;\r\n    }\r\n    if (value < 0)\r\n        return fromNumber(-value, unsigned).neg();\r\n    return fromBits((value % TWO_PWR_32_DBL) | 0, (value / TWO_PWR_32_DBL) | 0, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the given value, provided that it is a finite number. Otherwise, zero is returned.\r\n * @function\r\n * @param {number} value The number in question\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromNumber = fromNumber;\r\n\r\n/**\r\n * @param {number} lowBits\r\n * @param {number} highBits\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromBits(lowBits, highBits, unsigned) {\r\n    return new Long(lowBits, highBits, unsigned);\r\n}\r\n\r\n/**\r\n * Returns a Long representing the 64 bit integer that comes by concatenating the given low and high bits. Each is\r\n *  assumed to use 32 bits.\r\n * @function\r\n * @param {number} lowBits The low 32 bits\r\n * @param {number} highBits The high 32 bits\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromBits = fromBits;\r\n\r\n/**\r\n * @function\r\n * @param {number} base\r\n * @param {number} exponent\r\n * @returns {number}\r\n * @inner\r\n */\r\nvar pow_dbl = Math.pow; // Used 4 times (4*8 to 15+4)\r\n\r\n/**\r\n * @param {string} str\r\n * @param {(boolean|number)=} unsigned\r\n * @param {number=} radix\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromString(str, unsigned, radix) {\r\n    if (str.length === 0)\r\n        throw Error('empty string');\r\n    if (str === \"NaN\" || str === \"Infinity\" || str === \"+Infinity\" || str === \"-Infinity\")\r\n        return ZERO;\r\n    if (typeof unsigned === 'number') {\r\n        // For goog.math.long compatibility\r\n        radix = unsigned,\r\n        unsigned = false;\r\n    } else {\r\n        unsigned = !! unsigned;\r\n    }\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n\r\n    var p;\r\n    if ((p = str.indexOf('-')) > 0)\r\n        throw Error('interior hyphen');\r\n    else if (p === 0) {\r\n        return fromString(str.substring(1), unsigned, radix).neg();\r\n    }\r\n\r\n    // Do several (8) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 8));\r\n\r\n    var result = ZERO;\r\n    for (var i = 0; i < str.length; i += 8) {\r\n        var size = Math.min(8, str.length - i),\r\n            value = parseInt(str.substring(i, i + size), radix);\r\n        if (size < 8) {\r\n            var power = fromNumber(pow_dbl(radix, size));\r\n            result = result.mul(power).add(fromNumber(value));\r\n        } else {\r\n            result = result.mul(radixToPower);\r\n            result = result.add(fromNumber(value));\r\n        }\r\n    }\r\n    result.unsigned = unsigned;\r\n    return result;\r\n}\r\n\r\n/**\r\n * Returns a Long representation of the given string, written using the specified radix.\r\n * @function\r\n * @param {string} str The textual representation of the Long\r\n * @param {(boolean|number)=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {number=} radix The radix in which the text is written (2-36), defaults to 10\r\n * @returns {!Long} The corresponding Long value\r\n */\r\nLong.fromString = fromString;\r\n\r\n/**\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val\r\n * @param {boolean=} unsigned\r\n * @returns {!Long}\r\n * @inner\r\n */\r\nfunction fromValue(val, unsigned) {\r\n    if (typeof val === 'number')\r\n        return fromNumber(val, unsigned);\r\n    if (typeof val === 'string')\r\n        return fromString(val, unsigned);\r\n    // Throws for non-objects, converts non-instanceof Long:\r\n    return fromBits(val.low, val.high, typeof unsigned === 'boolean' ? unsigned : val.unsigned);\r\n}\r\n\r\n/**\r\n * Converts the specified value to a Long using the appropriate from* function for its type.\r\n * @function\r\n * @param {!Long|number|string|!{low: number, high: number, unsigned: boolean}} val Value\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {!Long}\r\n */\r\nLong.fromValue = fromValue;\r\n\r\n// NOTE: the compiler should inline these constant values below and then remove these variables, so there should be\r\n// no runtime penalty for these.\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_16_DBL = 1 << 16;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24_DBL = 1 << 24;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;\r\n\r\n/**\r\n * @type {number}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;\r\n\r\n/**\r\n * @type {!Long}\r\n * @const\r\n * @inner\r\n */\r\nvar TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ZERO = fromInt(0);\r\n\r\n/**\r\n * Signed zero.\r\n * @type {!Long}\r\n */\r\nLong.ZERO = ZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UZERO = fromInt(0, true);\r\n\r\n/**\r\n * Unsigned zero.\r\n * @type {!Long}\r\n */\r\nLong.UZERO = UZERO;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar ONE = fromInt(1);\r\n\r\n/**\r\n * Signed one.\r\n * @type {!Long}\r\n */\r\nLong.ONE = ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar UONE = fromInt(1, true);\r\n\r\n/**\r\n * Unsigned one.\r\n * @type {!Long}\r\n */\r\nLong.UONE = UONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar NEG_ONE = fromInt(-1);\r\n\r\n/**\r\n * Signed negative one.\r\n * @type {!Long}\r\n */\r\nLong.NEG_ONE = NEG_ONE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_VALUE = fromBits(0xFFFFFFFF|0, 0x7FFFFFFF|0, false);\r\n\r\n/**\r\n * Maximum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_VALUE = MAX_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MAX_UNSIGNED_VALUE = fromBits(0xFFFFFFFF|0, 0xFFFFFFFF|0, true);\r\n\r\n/**\r\n * Maximum unsigned value.\r\n * @type {!Long}\r\n */\r\nLong.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;\r\n\r\n/**\r\n * @type {!Long}\r\n * @inner\r\n */\r\nvar MIN_VALUE = fromBits(0, 0x80000000|0, false);\r\n\r\n/**\r\n * Minimum signed value.\r\n * @type {!Long}\r\n */\r\nLong.MIN_VALUE = MIN_VALUE;\r\n\r\n/**\r\n * @alias Long.prototype\r\n * @inner\r\n */\r\nvar LongPrototype = Long.prototype;\r\n\r\n/**\r\n * Converts the Long to a 32 bit integer, assuming it is a 32 bit integer.\r\n * @returns {number}\r\n */\r\nLongPrototype.toInt = function toInt() {\r\n    return this.unsigned ? this.low >>> 0 : this.low;\r\n};\r\n\r\n/**\r\n * Converts the Long to a the nearest floating-point representation of this value (double, 53 bit mantissa).\r\n * @returns {number}\r\n */\r\nLongPrototype.toNumber = function toNumber() {\r\n    if (this.unsigned)\r\n        return ((this.high >>> 0) * TWO_PWR_32_DBL) + (this.low >>> 0);\r\n    return this.high * TWO_PWR_32_DBL + (this.low >>> 0);\r\n};\r\n\r\n/**\r\n * Converts the Long to a string written in the specified radix.\r\n * @param {number=} radix Radix (2-36), defaults to 10\r\n * @returns {string}\r\n * @override\r\n * @throws {RangeError} If `radix` is out of range\r\n */\r\nLongPrototype.toString = function toString(radix) {\r\n    radix = radix || 10;\r\n    if (radix < 2 || 36 < radix)\r\n        throw RangeError('radix');\r\n    if (this.isZero())\r\n        return '0';\r\n    if (this.isNegative()) { // Unsigned Longs are never negative\r\n        if (this.eq(MIN_VALUE)) {\r\n            // We need to change the Long value before it can be negated, so we remove\r\n            // the bottom-most digit in this base and then recurse to do the rest.\r\n            var radixLong = fromNumber(radix),\r\n                div = this.div(radixLong),\r\n                rem1 = div.mul(radixLong).sub(this);\r\n            return div.toString(radix) + rem1.toInt().toString(radix);\r\n        } else\r\n            return '-' + this.neg().toString(radix);\r\n    }\r\n\r\n    // Do several (6) digits each time through the loop, so as to\r\n    // minimize the calls to the very expensive emulated div.\r\n    var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned),\r\n        rem = this;\r\n    var result = '';\r\n    while (true) {\r\n        var remDiv = rem.div(radixToPower),\r\n            intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0,\r\n            digits = intval.toString(radix);\r\n        rem = remDiv;\r\n        if (rem.isZero())\r\n            return digits + result;\r\n        else {\r\n            while (digits.length < 6)\r\n                digits = '0' + digits;\r\n            result = '' + digits + result;\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as a signed integer.\r\n * @returns {number} Signed high bits\r\n */\r\nLongPrototype.getHighBits = function getHighBits() {\r\n    return this.high;\r\n};\r\n\r\n/**\r\n * Gets the high 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned high bits\r\n */\r\nLongPrototype.getHighBitsUnsigned = function getHighBitsUnsigned() {\r\n    return this.high >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as a signed integer.\r\n * @returns {number} Signed low bits\r\n */\r\nLongPrototype.getLowBits = function getLowBits() {\r\n    return this.low;\r\n};\r\n\r\n/**\r\n * Gets the low 32 bits as an unsigned integer.\r\n * @returns {number} Unsigned low bits\r\n */\r\nLongPrototype.getLowBitsUnsigned = function getLowBitsUnsigned() {\r\n    return this.low >>> 0;\r\n};\r\n\r\n/**\r\n * Gets the number of bits needed to represent the absolute value of this Long.\r\n * @returns {number}\r\n */\r\nLongPrototype.getNumBitsAbs = function getNumBitsAbs() {\r\n    if (this.isNegative()) // Unsigned Longs are never negative\r\n        return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();\r\n    var val = this.high != 0 ? this.high : this.low;\r\n    for (var bit = 31; bit > 0; bit--)\r\n        if ((val & (1 << bit)) != 0)\r\n            break;\r\n    return this.high != 0 ? bit + 33 : bit + 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isZero = function isZero() {\r\n    return this.high === 0 && this.low === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals zero. This is an alias of {@link Long#isZero}.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eqz = LongPrototype.isZero;\r\n\r\n/**\r\n * Tests if this Long's value is negative.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isNegative = function isNegative() {\r\n    return !this.unsigned && this.high < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is positive.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isPositive = function isPositive() {\r\n    return this.unsigned || this.high >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is odd.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isOdd = function isOdd() {\r\n    return (this.low & 1) === 1;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is even.\r\n * @returns {boolean}\r\n */\r\nLongPrototype.isEven = function isEven() {\r\n    return (this.low & 1) === 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.equals = function equals(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.unsigned !== other.unsigned && (this.high >>> 31) === 1 && (other.high >>> 31) === 1)\r\n        return false;\r\n    return this.high === other.high && this.low === other.low;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value equals the specified's. This is an alias of {@link Long#equals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.eq = LongPrototype.equals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.notEquals = function notEquals(other) {\r\n    return !this.eq(/* validates */ other);\r\n};\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.neq = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value differs from the specified's. This is an alias of {@link Long#notEquals}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ne = LongPrototype.notEquals;\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThan = function lessThan(other) {\r\n    return this.comp(/* validates */ other) < 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than the specified's. This is an alias of {@link Long#lessThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lt = LongPrototype.lessThan;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lessThanOrEqual = function lessThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) <= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.lte = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is less than or equal the specified's. This is an alias of {@link Long#lessThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.le = LongPrototype.lessThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThan = function greaterThan(other) {\r\n    return this.comp(/* validates */ other) > 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than the specified's. This is an alias of {@link Long#greaterThan}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gt = LongPrototype.greaterThan;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.greaterThanOrEqual = function greaterThanOrEqual(other) {\r\n    return this.comp(/* validates */ other) >= 0;\r\n};\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.gte = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Tests if this Long's value is greater than or equal the specified's. This is an alias of {@link Long#greaterThanOrEqual}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {boolean}\r\n */\r\nLongPrototype.ge = LongPrototype.greaterThanOrEqual;\r\n\r\n/**\r\n * Compares this Long's value with the specified's.\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.compare = function compare(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    if (this.eq(other))\r\n        return 0;\r\n    var thisNeg = this.isNegative(),\r\n        otherNeg = other.isNegative();\r\n    if (thisNeg && !otherNeg)\r\n        return -1;\r\n    if (!thisNeg && otherNeg)\r\n        return 1;\r\n    // At this point the sign bits are the same\r\n    if (!this.unsigned)\r\n        return this.sub(other).isNegative() ? -1 : 1;\r\n    // Both are positive if at least one is unsigned\r\n    return (other.high >>> 0) > (this.high >>> 0) || (other.high === this.high && (other.low >>> 0) > (this.low >>> 0)) ? -1 : 1;\r\n};\r\n\r\n/**\r\n * Compares this Long's value with the specified's. This is an alias of {@link Long#compare}.\r\n * @function\r\n * @param {!Long|number|string} other Other value\r\n * @returns {number} 0 if they are the same, 1 if the this is greater and -1\r\n *  if the given one is greater\r\n */\r\nLongPrototype.comp = LongPrototype.compare;\r\n\r\n/**\r\n * Negates this Long's value.\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.negate = function negate() {\r\n    if (!this.unsigned && this.eq(MIN_VALUE))\r\n        return MIN_VALUE;\r\n    return this.not().add(ONE);\r\n};\r\n\r\n/**\r\n * Negates this Long's value. This is an alias of {@link Long#negate}.\r\n * @function\r\n * @returns {!Long} Negated Long\r\n */\r\nLongPrototype.neg = LongPrototype.negate;\r\n\r\n/**\r\n * Returns the sum of this and the specified Long.\r\n * @param {!Long|number|string} addend Addend\r\n * @returns {!Long} Sum\r\n */\r\nLongPrototype.add = function add(addend) {\r\n    if (!isLong(addend))\r\n        addend = fromValue(addend);\r\n\r\n    // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = addend.high >>> 16;\r\n    var b32 = addend.high & 0xFFFF;\r\n    var b16 = addend.low >>> 16;\r\n    var b00 = addend.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 + b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 + b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 + b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 + b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long.\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.subtract = function subtract(subtrahend) {\r\n    if (!isLong(subtrahend))\r\n        subtrahend = fromValue(subtrahend);\r\n    return this.add(subtrahend.neg());\r\n};\r\n\r\n/**\r\n * Returns the difference of this and the specified Long. This is an alias of {@link Long#subtract}.\r\n * @function\r\n * @param {!Long|number|string} subtrahend Subtrahend\r\n * @returns {!Long} Difference\r\n */\r\nLongPrototype.sub = LongPrototype.subtract;\r\n\r\n/**\r\n * Returns the product of this and the specified Long.\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.multiply = function multiply(multiplier) {\r\n    if (this.isZero())\r\n        return ZERO;\r\n    if (!isLong(multiplier))\r\n        multiplier = fromValue(multiplier);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = wasm.mul(this.low,\r\n                           this.high,\r\n                           multiplier.low,\r\n                           multiplier.high);\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (multiplier.isZero())\r\n        return ZERO;\r\n    if (this.eq(MIN_VALUE))\r\n        return multiplier.isOdd() ? MIN_VALUE : ZERO;\r\n    if (multiplier.eq(MIN_VALUE))\r\n        return this.isOdd() ? MIN_VALUE : ZERO;\r\n\r\n    if (this.isNegative()) {\r\n        if (multiplier.isNegative())\r\n            return this.neg().mul(multiplier.neg());\r\n        else\r\n            return this.neg().mul(multiplier).neg();\r\n    } else if (multiplier.isNegative())\r\n        return this.mul(multiplier.neg()).neg();\r\n\r\n    // If both longs are small, use float multiplication\r\n    if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24))\r\n        return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);\r\n\r\n    // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\r\n    // We can skip products that would overflow.\r\n\r\n    var a48 = this.high >>> 16;\r\n    var a32 = this.high & 0xFFFF;\r\n    var a16 = this.low >>> 16;\r\n    var a00 = this.low & 0xFFFF;\r\n\r\n    var b48 = multiplier.high >>> 16;\r\n    var b32 = multiplier.high & 0xFFFF;\r\n    var b16 = multiplier.low >>> 16;\r\n    var b00 = multiplier.low & 0xFFFF;\r\n\r\n    var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\r\n    c00 += a00 * b00;\r\n    c16 += c00 >>> 16;\r\n    c00 &= 0xFFFF;\r\n    c16 += a16 * b00;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c16 += a00 * b16;\r\n    c32 += c16 >>> 16;\r\n    c16 &= 0xFFFF;\r\n    c32 += a32 * b00;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a16 * b16;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c32 += a00 * b32;\r\n    c48 += c32 >>> 16;\r\n    c32 &= 0xFFFF;\r\n    c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\r\n    c48 &= 0xFFFF;\r\n    return fromBits((c16 << 16) | c00, (c48 << 16) | c32, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the product of this and the specified Long. This is an alias of {@link Long#multiply}.\r\n * @function\r\n * @param {!Long|number|string} multiplier Multiplier\r\n * @returns {!Long} Product\r\n */\r\nLongPrototype.mul = LongPrototype.multiply;\r\n\r\n/**\r\n * Returns this Long divided by the specified. The result is signed if this Long is signed or\r\n *  unsigned if this Long is unsigned.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.divide = function divide(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n    if (divisor.isZero())\r\n        throw Error('division by zero');\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        // guard against signed division overflow: the largest\r\n        // negative number / -1 would be 1 larger than the largest\r\n        // positive number, due to two's complement.\r\n        if (!this.unsigned &&\r\n            this.high === -0x80000000 &&\r\n            divisor.low === -1 && divisor.high === -1) {\r\n            // be consistent with non-wasm code path\r\n            return this;\r\n        }\r\n        var low = (this.unsigned ? wasm.div_u : wasm.div_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    if (this.isZero())\r\n        return this.unsigned ? UZERO : ZERO;\r\n    var approx, rem, res;\r\n    if (!this.unsigned) {\r\n        // This section is only relevant for signed longs and is derived from the\r\n        // closure library as a whole.\r\n        if (this.eq(MIN_VALUE)) {\r\n            if (divisor.eq(ONE) || divisor.eq(NEG_ONE))\r\n                return MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\r\n            else if (divisor.eq(MIN_VALUE))\r\n                return ONE;\r\n            else {\r\n                // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\r\n                var halfThis = this.shr(1);\r\n                approx = halfThis.div(divisor).shl(1);\r\n                if (approx.eq(ZERO)) {\r\n                    return divisor.isNegative() ? ONE : NEG_ONE;\r\n                } else {\r\n                    rem = this.sub(divisor.mul(approx));\r\n                    res = approx.add(rem.div(divisor));\r\n                    return res;\r\n                }\r\n            }\r\n        } else if (divisor.eq(MIN_VALUE))\r\n            return this.unsigned ? UZERO : ZERO;\r\n        if (this.isNegative()) {\r\n            if (divisor.isNegative())\r\n                return this.neg().div(divisor.neg());\r\n            return this.neg().div(divisor).neg();\r\n        } else if (divisor.isNegative())\r\n            return this.div(divisor.neg()).neg();\r\n        res = ZERO;\r\n    } else {\r\n        // The algorithm below has not been made for unsigned longs. It's therefore\r\n        // required to take special care of the MSB prior to running it.\r\n        if (!divisor.unsigned)\r\n            divisor = divisor.toUnsigned();\r\n        if (divisor.gt(this))\r\n            return UZERO;\r\n        if (divisor.gt(this.shru(1))) // 15 >>> 1 = 7 ; with divisor = 8 ; true\r\n            return UONE;\r\n        res = UZERO;\r\n    }\r\n\r\n    // Repeat the following until the remainder is less than other:  find a\r\n    // floating-point that approximates remainder / other *from below*, add this\r\n    // into the result, and subtract it from the remainder.  It is critical that\r\n    // the approximate value is less than or equal to the real value so that the\r\n    // remainder never becomes negative.\r\n    rem = this;\r\n    while (rem.gte(divisor)) {\r\n        // Approximate the result of division. This may be a little greater or\r\n        // smaller than the actual value.\r\n        approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));\r\n\r\n        // We will tweak the approximate result by changing it in the 48-th digit or\r\n        // the smallest non-fractional digit, whichever is larger.\r\n        var log2 = Math.ceil(Math.log(approx) / Math.LN2),\r\n            delta = (log2 <= 48) ? 1 : pow_dbl(2, log2 - 48),\r\n\r\n        // Decrease the approximation until it is smaller than the remainder.  Note\r\n        // that if it is too large, the product overflows and is negative.\r\n            approxRes = fromNumber(approx),\r\n            approxRem = approxRes.mul(divisor);\r\n        while (approxRem.isNegative() || approxRem.gt(rem)) {\r\n            approx -= delta;\r\n            approxRes = fromNumber(approx, this.unsigned);\r\n            approxRem = approxRes.mul(divisor);\r\n        }\r\n\r\n        // We know the answer can't be zero... and actually, zero would cause\r\n        // infinite recursion since we would make no progress.\r\n        if (approxRes.isZero())\r\n            approxRes = ONE;\r\n\r\n        res = res.add(approxRes);\r\n        rem = rem.sub(approxRem);\r\n    }\r\n    return res;\r\n};\r\n\r\n/**\r\n * Returns this Long divided by the specified. This is an alias of {@link Long#divide}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Quotient\r\n */\r\nLongPrototype.div = LongPrototype.divide;\r\n\r\n/**\r\n * Returns this Long modulo the specified.\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.modulo = function modulo(divisor) {\r\n    if (!isLong(divisor))\r\n        divisor = fromValue(divisor);\r\n\r\n    // use wasm support if present\r\n    if (wasm) {\r\n        var low = (this.unsigned ? wasm.rem_u : wasm.rem_s)(\r\n            this.low,\r\n            this.high,\r\n            divisor.low,\r\n            divisor.high\r\n        );\r\n        return fromBits(low, wasm.get_high(), this.unsigned);\r\n    }\r\n\r\n    return this.sub(this.div(divisor).mul(divisor));\r\n};\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.mod = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns this Long modulo the specified. This is an alias of {@link Long#modulo}.\r\n * @function\r\n * @param {!Long|number|string} divisor Divisor\r\n * @returns {!Long} Remainder\r\n */\r\nLongPrototype.rem = LongPrototype.modulo;\r\n\r\n/**\r\n * Returns the bitwise NOT of this Long.\r\n * @returns {!Long}\r\n */\r\nLongPrototype.not = function not() {\r\n    return fromBits(~this.low, ~this.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise AND of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.and = function and(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low & other.low, this.high & other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise OR of this Long and the specified.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.or = function or(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low | other.low, this.high | other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns the bitwise XOR of this Long and the given one.\r\n * @param {!Long|number|string} other Other Long\r\n * @returns {!Long}\r\n */\r\nLongPrototype.xor = function xor(other) {\r\n    if (!isLong(other))\r\n        other = fromValue(other);\r\n    return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftLeft = function shiftLeft(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits(this.low << numBits, (this.high << numBits) | (this.low >>> (32 - numBits)), this.unsigned);\r\n    else\r\n        return fromBits(0, this.low << (numBits - 32), this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits shifted to the left by the given amount. This is an alias of {@link Long#shiftLeft}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shl = LongPrototype.shiftLeft;\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRight = function shiftRight(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    if ((numBits &= 63) === 0)\r\n        return this;\r\n    else if (numBits < 32)\r\n        return fromBits((this.low >>> numBits) | (this.high << (32 - numBits)), this.high >> numBits, this.unsigned);\r\n    else\r\n        return fromBits(this.high >> (numBits - 32), this.high >= 0 ? 0 : -1, this.unsigned);\r\n};\r\n\r\n/**\r\n * Returns this Long with bits arithmetically shifted to the right by the given amount. This is an alias of {@link Long#shiftRight}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr = LongPrototype.shiftRight;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount.\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shiftRightUnsigned = function shiftRightUnsigned(numBits) {\r\n    if (isLong(numBits))\r\n        numBits = numBits.toInt();\r\n    numBits &= 63;\r\n    if (numBits === 0)\r\n        return this;\r\n    else {\r\n        var high = this.high;\r\n        if (numBits < 32) {\r\n            var low = this.low;\r\n            return fromBits((low >>> numBits) | (high << (32 - numBits)), high >>> numBits, this.unsigned);\r\n        } else if (numBits === 32)\r\n            return fromBits(high, 0, this.unsigned);\r\n        else\r\n            return fromBits(high >>> (numBits - 32), 0, this.unsigned);\r\n    }\r\n};\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shru = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Returns this Long with bits logically shifted to the right by the given amount. This is an alias of {@link Long#shiftRightUnsigned}.\r\n * @function\r\n * @param {number|!Long} numBits Number of bits\r\n * @returns {!Long} Shifted Long\r\n */\r\nLongPrototype.shr_u = LongPrototype.shiftRightUnsigned;\r\n\r\n/**\r\n * Converts this Long to signed.\r\n * @returns {!Long} Signed long\r\n */\r\nLongPrototype.toSigned = function toSigned() {\r\n    if (!this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, false);\r\n};\r\n\r\n/**\r\n * Converts this Long to unsigned.\r\n * @returns {!Long} Unsigned long\r\n */\r\nLongPrototype.toUnsigned = function toUnsigned() {\r\n    if (this.unsigned)\r\n        return this;\r\n    return fromBits(this.low, this.high, true);\r\n};\r\n\r\n/**\r\n * Converts this Long to its byte representation.\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {!Array.<number>} Byte representation\r\n */\r\nLongPrototype.toBytes = function toBytes(le) {\r\n    return le ? this.toBytesLE() : this.toBytesBE();\r\n};\r\n\r\n/**\r\n * Converts this Long to its little endian byte representation.\r\n * @returns {!Array.<number>} Little endian byte representation\r\n */\r\nLongPrototype.toBytesLE = function toBytesLE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        lo        & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo >>> 16 & 0xff,\r\n        lo >>> 24       ,\r\n        hi        & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi >>> 16 & 0xff,\r\n        hi >>> 24\r\n    ];\r\n};\r\n\r\n/**\r\n * Converts this Long to its big endian byte representation.\r\n * @returns {!Array.<number>} Big endian byte representation\r\n */\r\nLongPrototype.toBytesBE = function toBytesBE() {\r\n    var hi = this.high,\r\n        lo = this.low;\r\n    return [\r\n        hi >>> 24       ,\r\n        hi >>> 16 & 0xff,\r\n        hi >>>  8 & 0xff,\r\n        hi        & 0xff,\r\n        lo >>> 24       ,\r\n        lo >>> 16 & 0xff,\r\n        lo >>>  8 & 0xff,\r\n        lo        & 0xff\r\n    ];\r\n};\r\n\r\n/**\r\n * Creates a Long from its byte representation.\r\n * @param {!Array.<number>} bytes Byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @param {boolean=} le Whether little or big endian, defaults to big endian\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytes = function fromBytes(bytes, unsigned, le) {\r\n    return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);\r\n};\r\n\r\n/**\r\n * Creates a Long from its little endian byte representation.\r\n * @param {!Array.<number>} bytes Little endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesLE = function fromBytesLE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[0]       |\r\n        bytes[1] <<  8 |\r\n        bytes[2] << 16 |\r\n        bytes[3] << 24,\r\n        bytes[4]       |\r\n        bytes[5] <<  8 |\r\n        bytes[6] << 16 |\r\n        bytes[7] << 24,\r\n        unsigned\r\n    );\r\n};\r\n\r\n/**\r\n * Creates a Long from its big endian byte representation.\r\n * @param {!Array.<number>} bytes Big endian byte representation\r\n * @param {boolean=} unsigned Whether unsigned or not, defaults to signed\r\n * @returns {Long} The corresponding Long value\r\n */\r\nLong.fromBytesBE = function fromBytesBE(bytes, unsigned) {\r\n    return new Long(\r\n        bytes[4] << 24 |\r\n        bytes[5] << 16 |\r\n        bytes[6] <<  8 |\r\n        bytes[7],\r\n        bytes[0] << 24 |\r\n        bytes[1] << 16 |\r\n        bytes[2] <<  8 |\r\n        bytes[3],\r\n        unsigned\r\n    );\r\n};\r\n\n\n//# sourceURL=webpack:///./node_modules/long/src/long.js?");

/***/ }),

/***/ "./node_modules/mitt/dist/mitt.mjs":
/*!*****************************************!*\
  !*** ./node_modules/mitt/dist/mitt.mjs ***!
  \*****************************************/
/*! exports provided: default */
/***/ (function(__webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony default export */ __webpack_exports__[\"default\"] = (function(n){return{all:n=n||new Map,on:function(t,e){var i=n.get(t);i?i.push(e):n.set(t,[e])},off:function(t,e){var i=n.get(t);i&&(e?i.splice(i.indexOf(e)>>>0,1):n.set(t,[]))},emit:function(t,e){var i=n.get(t);i&&i.slice().map(function(n){n(e)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(t,e)})}}});\n//# sourceMappingURL=mitt.mjs.map\n\n\n//# sourceURL=webpack:///./node_modules/mitt/dist/mitt.mjs?");

/***/ }),

/***/ "./node_modules/p-queue/dist/index.js":
/*!********************************************!*\
  !*** ./node_modules/p-queue/dist/index.js ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PQueue; });\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\n/* harmony import */ var eventemitter3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(eventemitter3__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var p_timeout__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! p-timeout */ \"./node_modules/p-queue/node_modules/p-timeout/index.js\");\n/* harmony import */ var _priority_queue_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./priority-queue.js */ \"./node_modules/p-queue/dist/priority-queue.js\");\n\n\n\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = () => { };\nconst timeoutError = new p_timeout__WEBPACK_IMPORTED_MODULE_1__[\"TimeoutError\"]();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends eventemitter3__WEBPACK_IMPORTED_MODULE_0___default.a {\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        Object.defineProperty(this, \"_carryoverConcurrencyCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isIntervalIgnored\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_intervalCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_intervalCap\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_interval\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_intervalEnd\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        Object.defineProperty(this, \"_intervalId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_timeoutId\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_queueClass\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_pendingCount\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: 0\n        });\n        // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n        Object.defineProperty(this, \"_concurrency\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_isPaused\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_resolveEmpty\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: empty\n        });\n        Object.defineProperty(this, \"_resolveIdle\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: empty\n        });\n        Object.defineProperty(this, \"_timeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        Object.defineProperty(this, \"_throwOnTimeout\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: void 0\n        });\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: _priority_queue_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"],\n            ...options\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit('next');\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit('idle');\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : Object(p_timeout__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    reject(error);\n                    this.emit('error', error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit('add');\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this._queue.size < limit) {\n            return;\n        }\n        return new Promise(resolve => {\n            const listener = () => {\n                if (this._queue.size < limit) {\n                    this.removeListener('next', listener);\n                    resolve();\n                }\n            };\n            this.on('next', listener);\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/p-queue/dist/index.js?");

/***/ }),

/***/ "./node_modules/p-queue/dist/lower-bound.js":
/*!**************************************************!*\
  !*** ./node_modules/p-queue/dist/lower-bound.js ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return lowerBound; });\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n\n\n//# sourceURL=webpack:///./node_modules/p-queue/dist/lower-bound.js?");

/***/ }),

/***/ "./node_modules/p-queue/dist/priority-queue.js":
/*!*****************************************************!*\
  !*** ./node_modules/p-queue/dist/priority-queue.js ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return PriorityQueue; });\n/* harmony import */ var _lower_bound_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lower-bound.js */ \"./node_modules/p-queue/dist/lower-bound.js\");\n\nclass PriorityQueue {\n    constructor() {\n        Object.defineProperty(this, \"_queue\", {\n            enumerable: true,\n            configurable: true,\n            writable: true,\n            value: []\n        });\n    }\n    enqueue(run, options) {\n        var _a;\n        options = {\n            priority: 0,\n            ...options\n        };\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && ((_a = this._queue[this.size - 1]) === null || _a === void 0 ? void 0 : _a.priority) >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = Object(_lower_bound_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(this._queue, element, (a, b) => b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\n\n\n//# sourceURL=webpack:///./node_modules/p-queue/dist/priority-queue.js?");

/***/ }),

/***/ "./node_modules/p-queue/node_modules/p-timeout/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/p-queue/node_modules/p-timeout/index.js ***!
  \**************************************************************/
/*! exports provided: TimeoutError, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TimeoutError\", function() { return TimeoutError; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"default\", function() { return pTimeout; });\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nfunction pTimeout(promise, milliseconds, fallback, options) {\n\tlet timer;\n\tconst cancelablePromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tresolve(promise);\n\t\t\treturn;\n\t\t}\n\n\t\toptions = {\n\t\t\tcustomTimers: {setTimeout, clearTimeout},\n\t\t\t...options\n\t\t};\n\n\t\ttimer = options.customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (typeof fallback === 'function') {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\treject(timeoutError);\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t} finally {\n\t\t\t\toptions.customTimers.clearTimeout.call(undefined, timer);\n\t\t\t}\n\t\t})();\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tclearTimeout(timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n\n\n//# sourceURL=webpack:///./node_modules/p-queue/node_modules/p-timeout/index.js?");

/***/ }),

/***/ "./node_modules/protobufjs/minimal.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/minimal.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("// minimal library entry point.\n\n\nmodule.exports = __webpack_require__(/*! ./src/index-minimal */ \"./node_modules/protobufjs/src/index-minimal.js\");\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/index-minimal.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/index-minimal.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nvar protobuf = exports;\n\n/**\n * Build type, one of `\"full\"`, `\"light\"` or `\"minimal\"`.\n * @name build\n * @type {string}\n * @const\n */\nprotobuf.build = \"minimal\";\n\n// Serialization\nprotobuf.Writer       = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\nprotobuf.BufferWriter = __webpack_require__(/*! ./writer_buffer */ \"./node_modules/protobufjs/src/writer_buffer.js\");\nprotobuf.Reader       = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\nprotobuf.BufferReader = __webpack_require__(/*! ./reader_buffer */ \"./node_modules/protobufjs/src/reader_buffer.js\");\n\n// Utility\nprotobuf.util         = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\nprotobuf.rpc          = __webpack_require__(/*! ./rpc */ \"./node_modules/protobufjs/src/rpc.js\");\nprotobuf.roots        = __webpack_require__(/*! ./roots */ \"./node_modules/protobufjs/src/roots.js\");\nprotobuf.configure    = configure;\n\n/* istanbul ignore next */\n/**\n * Reconfigures the library according to the environment.\n * @returns {undefined}\n */\nfunction configure() {\n    protobuf.util._configure();\n    protobuf.Writer._configure(protobuf.BufferWriter);\n    protobuf.Reader._configure(protobuf.BufferReader);\n}\n\n// Set up buffer utility according to the environment\nconfigure();\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/index-minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/reader.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Reader;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferReader; // cyclic\n\nvar LongBits  = util.LongBits,\n    utf8      = util.utf8;\n\n/* istanbul ignore next */\nfunction indexOutOfRange(reader, writeLength) {\n    return RangeError(\"index out of range: \" + reader.pos + \" + \" + (writeLength || 1) + \" > \" + reader.len);\n}\n\n/**\n * Constructs a new reader instance using the specified buffer.\n * @classdesc Wire format reader using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n * @param {Uint8Array} buffer Buffer to read from\n */\nfunction Reader(buffer) {\n\n    /**\n     * Read buffer.\n     * @type {Uint8Array}\n     */\n    this.buf = buffer;\n\n    /**\n     * Read buffer position.\n     * @type {number}\n     */\n    this.pos = 0;\n\n    /**\n     * Read buffer length.\n     * @type {number}\n     */\n    this.len = buffer.length;\n}\n\nvar create_array = typeof Uint8Array !== \"undefined\"\n    ? function create_typed_array(buffer) {\n        if (buffer instanceof Uint8Array || Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    }\n    /* istanbul ignore next */\n    : function create_array(buffer) {\n        if (Array.isArray(buffer))\n            return new Reader(buffer);\n        throw Error(\"illegal buffer\");\n    };\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup(buffer) {\n            return (Reader.create = function create_buffer(buffer) {\n                return util.Buffer.isBuffer(buffer)\n                    ? new BufferReader(buffer)\n                    /* istanbul ignore next */\n                    : create_array(buffer);\n            })(buffer);\n        }\n        /* istanbul ignore next */\n        : create_array;\n};\n\n/**\n * Creates a new reader using the specified buffer.\n * @function\n * @param {Uint8Array|Buffer} buffer Buffer to read from\n * @returns {Reader|BufferReader} A {@link BufferReader} if `buffer` is a Buffer, otherwise a {@link Reader}\n * @throws {Error} If `buffer` is not a valid buffer\n */\nReader.create = create();\n\nReader.prototype._slice = util.Array.prototype.subarray || /* istanbul ignore next */ util.Array.prototype.slice;\n\n/**\n * Reads a varint as an unsigned 32 bit value.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.uint32 = (function read_uint32_setup() {\n    var value = 4294967295; // optimizer type-hint, tends to deopt otherwise (?!)\n    return function read_uint32() {\n        value = (         this.buf[this.pos] & 127       ) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) <<  7) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 14) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] & 127) << 21) >>> 0; if (this.buf[this.pos++] < 128) return value;\n        value = (value | (this.buf[this.pos] &  15) << 28) >>> 0; if (this.buf[this.pos++] < 128) return value;\n\n        /* istanbul ignore if */\n        if ((this.pos += 5) > this.len) {\n            this.pos = this.len;\n            throw indexOutOfRange(this, 10);\n        }\n        return value;\n    };\n})();\n\n/**\n * Reads a varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.int32 = function read_int32() {\n    return this.uint32() | 0;\n};\n\n/**\n * Reads a zig-zag encoded varint as a signed 32 bit value.\n * @returns {number} Value read\n */\nReader.prototype.sint32 = function read_sint32() {\n    var value = this.uint32();\n    return value >>> 1 ^ -(value & 1) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readLongVarint() {\n    // tends to deopt with local vars for octet etc.\n    var bits = new LongBits(0, 0);\n    var i = 0;\n    if (this.len - this.pos > 4) { // fast route (lo)\n        for (; i < 4; ++i) {\n            // 1st..4th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 5th\n        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;\n        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >>  4) >>> 0;\n        if (this.buf[this.pos++] < 128)\n            return bits;\n        i = 0;\n    } else {\n        for (; i < 3; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 1st..3th\n            bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n        // 4th\n        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;\n        return bits;\n    }\n    if (this.len - this.pos > 4) { // fast route (hi)\n        for (; i < 5; ++i) {\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    } else {\n        for (; i < 5; ++i) {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n            // 6th..10th\n            bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;\n            if (this.buf[this.pos++] < 128)\n                return bits;\n        }\n    }\n    /* istanbul ignore next */\n    throw Error(\"invalid varint encoding\");\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads a varint as a signed 64 bit value.\n * @name Reader#int64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as an unsigned 64 bit value.\n * @name Reader#uint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a zig-zag encoded varint as a signed 64 bit value.\n * @name Reader#sint64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a varint as a boolean.\n * @returns {boolean} Value read\n */\nReader.prototype.bool = function read_bool() {\n    return this.uint32() !== 0;\n};\n\nfunction readFixed32_end(buf, end) { // note that this uses `end`, not `pos`\n    return (buf[end - 4]\n          | buf[end - 3] << 8\n          | buf[end - 2] << 16\n          | buf[end - 1] << 24) >>> 0;\n}\n\n/**\n * Reads fixed 32 bits as an unsigned 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.fixed32 = function read_fixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4);\n};\n\n/**\n * Reads fixed 32 bits as a signed 32 bit integer.\n * @returns {number} Value read\n */\nReader.prototype.sfixed32 = function read_sfixed32() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    return readFixed32_end(this.buf, this.pos += 4) | 0;\n};\n\n/* eslint-disable no-invalid-this */\n\nfunction readFixed64(/* this: Reader */) {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 8);\n\n    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));\n}\n\n/* eslint-enable no-invalid-this */\n\n/**\n * Reads fixed 64 bits.\n * @name Reader#fixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads zig-zag encoded fixed 64 bits.\n * @name Reader#sfixed64\n * @function\n * @returns {Long} Value read\n */\n\n/**\n * Reads a float (32 bit) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.float = function read_float() {\n\n    /* istanbul ignore if */\n    if (this.pos + 4 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readFloatLE(this.buf, this.pos);\n    this.pos += 4;\n    return value;\n};\n\n/**\n * Reads a double (64 bit float) as a number.\n * @function\n * @returns {number} Value read\n */\nReader.prototype.double = function read_double() {\n\n    /* istanbul ignore if */\n    if (this.pos + 8 > this.len)\n        throw indexOutOfRange(this, 4);\n\n    var value = util.float.readDoubleLE(this.buf, this.pos);\n    this.pos += 8;\n    return value;\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @returns {Uint8Array} Value read\n */\nReader.prototype.bytes = function read_bytes() {\n    var length = this.uint32(),\n        start  = this.pos,\n        end    = this.pos + length;\n\n    /* istanbul ignore if */\n    if (end > this.len)\n        throw indexOutOfRange(this, length);\n\n    this.pos += length;\n    if (Array.isArray(this.buf)) // plain array\n        return this.buf.slice(start, end);\n    return start === end // fix for IE 10/Win8 and others' subarray returning array of size 1\n        ? new this.buf.constructor(0)\n        : this._slice.call(this.buf, start, end);\n};\n\n/**\n * Reads a string preceeded by its byte length as a varint.\n * @returns {string} Value read\n */\nReader.prototype.string = function read_string() {\n    var bytes = this.bytes();\n    return utf8.read(bytes, 0, bytes.length);\n};\n\n/**\n * Skips the specified number of bytes if specified, otherwise skips a varint.\n * @param {number} [length] Length if known, otherwise a varint is assumed\n * @returns {Reader} `this`\n */\nReader.prototype.skip = function skip(length) {\n    if (typeof length === \"number\") {\n        /* istanbul ignore if */\n        if (this.pos + length > this.len)\n            throw indexOutOfRange(this, length);\n        this.pos += length;\n    } else {\n        do {\n            /* istanbul ignore if */\n            if (this.pos >= this.len)\n                throw indexOutOfRange(this);\n        } while (this.buf[this.pos++] & 128);\n    }\n    return this;\n};\n\n/**\n * Skips the next element of the specified wire type.\n * @param {number} wireType Wire type received\n * @returns {Reader} `this`\n */\nReader.prototype.skipType = function(wireType) {\n    switch (wireType) {\n        case 0:\n            this.skip();\n            break;\n        case 1:\n            this.skip(8);\n            break;\n        case 2:\n            this.skip(this.uint32());\n            break;\n        case 3:\n            while ((wireType = this.uint32() & 7) !== 4) {\n                this.skipType(wireType);\n            }\n            break;\n        case 5:\n            this.skip(4);\n            break;\n\n        /* istanbul ignore next */\n        default:\n            throw Error(\"invalid wire type \" + wireType + \" at offset \" + this.pos);\n    }\n    return this;\n};\n\nReader._configure = function(BufferReader_) {\n    BufferReader = BufferReader_;\n    Reader.create = create();\n    BufferReader._configure();\n\n    var fn = util.Long ? \"toLong\" : /* istanbul ignore next */ \"toNumber\";\n    util.merge(Reader.prototype, {\n\n        int64: function read_int64() {\n            return readLongVarint.call(this)[fn](false);\n        },\n\n        uint64: function read_uint64() {\n            return readLongVarint.call(this)[fn](true);\n        },\n\n        sint64: function read_sint64() {\n            return readLongVarint.call(this).zzDecode()[fn](false);\n        },\n\n        fixed64: function read_fixed64() {\n            return readFixed64.call(this)[fn](true);\n        },\n\n        sfixed64: function read_sfixed64() {\n            return readFixed64.call(this)[fn](false);\n        }\n\n    });\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/reader_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/reader_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = BufferReader;\n\n// extends Reader\nvar Reader = __webpack_require__(/*! ./reader */ \"./node_modules/protobufjs/src/reader.js\");\n(BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer reader instance.\n * @classdesc Wire format reader using node buffers.\n * @extends Reader\n * @constructor\n * @param {Buffer} buffer Buffer to read from\n */\nfunction BufferReader(buffer) {\n    Reader.call(this, buffer);\n\n    /**\n     * Read buffer.\n     * @name BufferReader#buf\n     * @type {Buffer}\n     */\n}\n\nBufferReader._configure = function () {\n    /* istanbul ignore else */\n    if (util.Buffer)\n        BufferReader.prototype._slice = util.Buffer.prototype.slice;\n};\n\n\n/**\n * @override\n */\nBufferReader.prototype.string = function read_string_buffer() {\n    var len = this.uint32(); // modifies pos\n    return this.buf.utf8Slice\n        ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len))\n        : this.buf.toString(\"utf-8\", this.pos, this.pos = Math.min(this.pos + len, this.len));\n};\n\n/**\n * Reads a sequence of bytes preceeded by its length as a varint.\n * @name BufferReader#bytes\n * @function\n * @returns {Buffer} Value read\n */\n\nBufferReader._configure();\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/reader_buffer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/roots.js":
/*!**********************************************!*\
  !*** ./node_modules/protobufjs/src/roots.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = {};\n\n/**\n * Named roots.\n * This is where pbjs stores generated structures (the option `-r, --root` specifies a name).\n * Can also be used manually to make roots available accross modules.\n * @name roots\n * @type {Object.<string,Root>}\n * @example\n * // pbjs -r myroot -o compiled.js ...\n *\n * // in another module:\n * require(\"./compiled.js\");\n *\n * // in any subsequent module:\n * var root = protobuf.roots[\"myroot\"];\n */\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/roots.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc.js":
/*!********************************************!*\
  !*** ./node_modules/protobufjs/src/rpc.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/**\n * Streaming RPC helpers.\n * @namespace\n */\nvar rpc = exports;\n\n/**\n * RPC implementation passed to {@link Service#create} performing a service request on network level, i.e. by utilizing http requests or websockets.\n * @typedef RPCImpl\n * @type {function}\n * @param {Method|rpc.ServiceMethod<Message<{}>,Message<{}>>} method Reflected or static method being called\n * @param {Uint8Array} requestData Request data\n * @param {RPCImplCallback} callback Callback function\n * @returns {undefined}\n * @example\n * function rpcImpl(method, requestData, callback) {\n *     if (protobuf.util.lcFirst(method.name) !== \"myMethod\") // compatible with static code\n *         throw Error(\"no such method\");\n *     asynchronouslyObtainAResponse(requestData, function(err, responseData) {\n *         callback(err, responseData);\n *     });\n * }\n */\n\n/**\n * Node-style callback as used by {@link RPCImpl}.\n * @typedef RPCImplCallback\n * @type {function}\n * @param {Error|null} error Error, if any, otherwise `null`\n * @param {Uint8Array|null} [response] Response data or `null` to signal end of stream, if there hasn't been an error\n * @returns {undefined}\n */\n\nrpc.Service = __webpack_require__(/*! ./rpc/service */ \"./node_modules/protobufjs/src/rpc/service.js\");\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/rpc/service.js":
/*!****************************************************!*\
  !*** ./node_modules/protobufjs/src/rpc/service.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Service;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n// Extends EventEmitter\n(Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;\n\n/**\n * A service method callback as used by {@link rpc.ServiceMethod|ServiceMethod}.\n *\n * Differs from {@link RPCImplCallback} in that it is an actual callback of a service method which may not return `response = null`.\n * @typedef rpc.ServiceMethodCallback\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {Error|null} error Error, if any\n * @param {TRes} [response] Response message\n * @returns {undefined}\n */\n\n/**\n * A service method part of a {@link rpc.Service} as created by {@link Service.create}.\n * @typedef rpc.ServiceMethod\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n * @type {function}\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} [callback] Node-style callback called with the error, if any, and the response message\n * @returns {Promise<Message<TRes>>} Promise if `callback` has been omitted, otherwise `undefined`\n */\n\n/**\n * Constructs a new RPC service instance.\n * @classdesc An RPC service as returned by {@link Service#create}.\n * @exports rpc.Service\n * @extends util.EventEmitter\n * @constructor\n * @param {RPCImpl} rpcImpl RPC implementation\n * @param {boolean} [requestDelimited=false] Whether requests are length-delimited\n * @param {boolean} [responseDelimited=false] Whether responses are length-delimited\n */\nfunction Service(rpcImpl, requestDelimited, responseDelimited) {\n\n    if (typeof rpcImpl !== \"function\")\n        throw TypeError(\"rpcImpl must be a function\");\n\n    util.EventEmitter.call(this);\n\n    /**\n     * RPC implementation. Becomes `null` once the service is ended.\n     * @type {RPCImpl|null}\n     */\n    this.rpcImpl = rpcImpl;\n\n    /**\n     * Whether requests are length-delimited.\n     * @type {boolean}\n     */\n    this.requestDelimited = Boolean(requestDelimited);\n\n    /**\n     * Whether responses are length-delimited.\n     * @type {boolean}\n     */\n    this.responseDelimited = Boolean(responseDelimited);\n}\n\n/**\n * Calls a service method through {@link rpc.Service#rpcImpl|rpcImpl}.\n * @param {Method|rpc.ServiceMethod<TReq,TRes>} method Reflected or static method\n * @param {Constructor<TReq>} requestCtor Request constructor\n * @param {Constructor<TRes>} responseCtor Response constructor\n * @param {TReq|Properties<TReq>} request Request message or plain object\n * @param {rpc.ServiceMethodCallback<TRes>} callback Service callback\n * @returns {undefined}\n * @template TReq extends Message<TReq>\n * @template TRes extends Message<TRes>\n */\nService.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {\n\n    if (!request)\n        throw TypeError(\"request must be specified\");\n\n    var self = this;\n    if (!callback)\n        return util.asPromise(rpcCall, self, method, requestCtor, responseCtor, request);\n\n    if (!self.rpcImpl) {\n        setTimeout(function() { callback(Error(\"already ended\")); }, 0);\n        return undefined;\n    }\n\n    try {\n        return self.rpcImpl(\n            method,\n            requestCtor[self.requestDelimited ? \"encodeDelimited\" : \"encode\"](request).finish(),\n            function rpcCallback(err, response) {\n\n                if (err) {\n                    self.emit(\"error\", err, method);\n                    return callback(err);\n                }\n\n                if (response === null) {\n                    self.end(/* endedByRPC */ true);\n                    return undefined;\n                }\n\n                if (!(response instanceof responseCtor)) {\n                    try {\n                        response = responseCtor[self.responseDelimited ? \"decodeDelimited\" : \"decode\"](response);\n                    } catch (err) {\n                        self.emit(\"error\", err, method);\n                        return callback(err);\n                    }\n                }\n\n                self.emit(\"data\", response, method);\n                return callback(null, response);\n            }\n        );\n    } catch (err) {\n        self.emit(\"error\", err, method);\n        setTimeout(function() { callback(err); }, 0);\n        return undefined;\n    }\n};\n\n/**\n * Ends this service and emits the `end` event.\n * @param {boolean} [endedByRPC=false] Whether the service has been ended by the RPC implementation.\n * @returns {rpc.Service} `this`\n */\nService.prototype.end = function end(endedByRPC) {\n    if (this.rpcImpl) {\n        if (!endedByRPC) // signal end to rpcImpl\n            this.rpcImpl(null, null, null);\n        this.rpcImpl = null;\n        this.emit(\"end\").off();\n    }\n    return this;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/rpc/service.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/longbits.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/util/longbits.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = LongBits;\n\nvar util = __webpack_require__(/*! ../util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs new long bits.\n * @classdesc Helper class for working with the low and high bits of a 64 bit value.\n * @memberof util\n * @constructor\n * @param {number} lo Low 32 bits, unsigned\n * @param {number} hi High 32 bits, unsigned\n */\nfunction LongBits(lo, hi) {\n\n    // note that the casts below are theoretically unnecessary as of today, but older statically\n    // generated converter code might still call the ctor with signed 32bits. kept for compat.\n\n    /**\n     * Low bits.\n     * @type {number}\n     */\n    this.lo = lo >>> 0;\n\n    /**\n     * High bits.\n     * @type {number}\n     */\n    this.hi = hi >>> 0;\n}\n\n/**\n * Zero bits.\n * @memberof util.LongBits\n * @type {util.LongBits}\n */\nvar zero = LongBits.zero = new LongBits(0, 0);\n\nzero.toNumber = function() { return 0; };\nzero.zzEncode = zero.zzDecode = function() { return this; };\nzero.length = function() { return 1; };\n\n/**\n * Zero hash.\n * @memberof util.LongBits\n * @type {string}\n */\nvar zeroHash = LongBits.zeroHash = \"\\0\\0\\0\\0\\0\\0\\0\\0\";\n\n/**\n * Constructs new long bits from the specified number.\n * @param {number} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.fromNumber = function fromNumber(value) {\n    if (value === 0)\n        return zero;\n    var sign = value < 0;\n    if (sign)\n        value = -value;\n    var lo = value >>> 0,\n        hi = (value - lo) / 4294967296 >>> 0;\n    if (sign) {\n        hi = ~hi >>> 0;\n        lo = ~lo >>> 0;\n        if (++lo > 4294967295) {\n            lo = 0;\n            if (++hi > 4294967295)\n                hi = 0;\n        }\n    }\n    return new LongBits(lo, hi);\n};\n\n/**\n * Constructs new long bits from a number, long or string.\n * @param {Long|number|string} value Value\n * @returns {util.LongBits} Instance\n */\nLongBits.from = function from(value) {\n    if (typeof value === \"number\")\n        return LongBits.fromNumber(value);\n    if (util.isString(value)) {\n        /* istanbul ignore else */\n        if (util.Long)\n            value = util.Long.fromString(value);\n        else\n            return LongBits.fromNumber(parseInt(value, 10));\n    }\n    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;\n};\n\n/**\n * Converts this long bits to a possibly unsafe JavaScript number.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {number} Possibly unsafe number\n */\nLongBits.prototype.toNumber = function toNumber(unsigned) {\n    if (!unsigned && this.hi >>> 31) {\n        var lo = ~this.lo + 1 >>> 0,\n            hi = ~this.hi     >>> 0;\n        if (!lo)\n            hi = hi + 1 >>> 0;\n        return -(lo + hi * 4294967296);\n    }\n    return this.lo + this.hi * 4294967296;\n};\n\n/**\n * Converts this long bits to a long.\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long} Long\n */\nLongBits.prototype.toLong = function toLong(unsigned) {\n    return util.Long\n        ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned))\n        /* istanbul ignore next */\n        : { low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned) };\n};\n\nvar charCodeAt = String.prototype.charCodeAt;\n\n/**\n * Constructs new long bits from the specified 8 characters long hash.\n * @param {string} hash Hash\n * @returns {util.LongBits} Bits\n */\nLongBits.fromHash = function fromHash(hash) {\n    if (hash === zeroHash)\n        return zero;\n    return new LongBits(\n        ( charCodeAt.call(hash, 0)\n        | charCodeAt.call(hash, 1) << 8\n        | charCodeAt.call(hash, 2) << 16\n        | charCodeAt.call(hash, 3) << 24) >>> 0\n    ,\n        ( charCodeAt.call(hash, 4)\n        | charCodeAt.call(hash, 5) << 8\n        | charCodeAt.call(hash, 6) << 16\n        | charCodeAt.call(hash, 7) << 24) >>> 0\n    );\n};\n\n/**\n * Converts this long bits to a 8 characters long hash.\n * @returns {string} Hash\n */\nLongBits.prototype.toHash = function toHash() {\n    return String.fromCharCode(\n        this.lo        & 255,\n        this.lo >>> 8  & 255,\n        this.lo >>> 16 & 255,\n        this.lo >>> 24      ,\n        this.hi        & 255,\n        this.hi >>> 8  & 255,\n        this.hi >>> 16 & 255,\n        this.hi >>> 24\n    );\n};\n\n/**\n * Zig-zag encodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzEncode = function zzEncode() {\n    var mask =   this.hi >> 31;\n    this.hi  = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;\n    this.lo  = ( this.lo << 1                   ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Zig-zag decodes this long bits.\n * @returns {util.LongBits} `this`\n */\nLongBits.prototype.zzDecode = function zzDecode() {\n    var mask = -(this.lo & 1);\n    this.lo  = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;\n    this.hi  = ( this.hi >>> 1                  ^ mask) >>> 0;\n    return this;\n};\n\n/**\n * Calculates the length of this longbits when encoded as a varint.\n * @returns {number} Length\n */\nLongBits.prototype.length = function length() {\n    var part0 =  this.lo,\n        part1 = (this.lo >>> 28 | this.hi << 4) >>> 0,\n        part2 =  this.hi >>> 24;\n    return part2 === 0\n         ? part1 === 0\n           ? part0 < 16384\n             ? part0 < 128 ? 1 : 2\n             : part0 < 2097152 ? 3 : 4\n           : part1 < 16384\n             ? part1 < 128 ? 5 : 6\n             : part1 < 2097152 ? 7 : 8\n         : part2 < 128 ? 9 : 10;\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/longbits.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/util/minimal.js":
/*!*****************************************************!*\
  !*** ./node_modules/protobufjs/src/util/minimal.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("/* WEBPACK VAR INJECTION */(function(global) {\nvar util = exports;\n\n// used to return a Promise where callback is omitted\nutil.asPromise = __webpack_require__(/*! @protobufjs/aspromise */ \"./node_modules/@protobufjs/aspromise/index.js\");\n\n// converts to / from base64 encoded strings\nutil.base64 = __webpack_require__(/*! @protobufjs/base64 */ \"./node_modules/@protobufjs/base64/index.js\");\n\n// base class of rpc.Service\nutil.EventEmitter = __webpack_require__(/*! @protobufjs/eventemitter */ \"./node_modules/@protobufjs/eventemitter/index.js\");\n\n// float handling accross browsers\nutil.float = __webpack_require__(/*! @protobufjs/float */ \"./node_modules/@protobufjs/float/index.js\");\n\n// requires modules optionally and hides the call from bundlers\nutil.inquire = __webpack_require__(/*! @protobufjs/inquire */ \"./node_modules/@protobufjs/inquire/index.js\");\n\n// converts to / from utf8 encoded strings\nutil.utf8 = __webpack_require__(/*! @protobufjs/utf8 */ \"./node_modules/@protobufjs/utf8/index.js\");\n\n// provides a node-like buffer pool in the browser\nutil.pool = __webpack_require__(/*! @protobufjs/pool */ \"./node_modules/@protobufjs/pool/index.js\");\n\n// utility to work with the low and high bits of a 64 bit value\nutil.LongBits = __webpack_require__(/*! ./longbits */ \"./node_modules/protobufjs/src/util/longbits.js\");\n\n/**\n * Whether running within node or not.\n * @memberof util\n * @type {boolean}\n */\nutil.isNode = Boolean(typeof global !== \"undefined\"\n                   && global\n                   && global.process\n                   && global.process.versions\n                   && global.process.versions.node);\n\n/**\n * Global object reference.\n * @memberof util\n * @type {Object}\n */\nutil.global = util.isNode && global\n           || typeof window !== \"undefined\" && window\n           || typeof self   !== \"undefined\" && self\n           || this; // eslint-disable-line no-invalid-this\n\n/**\n * An immuable empty array.\n * @memberof util\n * @type {Array.<*>}\n * @const\n */\nutil.emptyArray = Object.freeze ? Object.freeze([]) : /* istanbul ignore next */ []; // used on prototypes\n\n/**\n * An immutable empty object.\n * @type {Object}\n * @const\n */\nutil.emptyObject = Object.freeze ? Object.freeze({}) : /* istanbul ignore next */ {}; // used on prototypes\n\n/**\n * Tests if the specified value is an integer.\n * @function\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is an integer\n */\nutil.isInteger = Number.isInteger || /* istanbul ignore next */ function isInteger(value) {\n    return typeof value === \"number\" && isFinite(value) && Math.floor(value) === value;\n};\n\n/**\n * Tests if the specified value is a string.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a string\n */\nutil.isString = function isString(value) {\n    return typeof value === \"string\" || value instanceof String;\n};\n\n/**\n * Tests if the specified value is a non-null object.\n * @param {*} value Value to test\n * @returns {boolean} `true` if the value is a non-null object\n */\nutil.isObject = function isObject(value) {\n    return value && typeof value === \"object\";\n};\n\n/**\n * Checks if a property on a message is considered to be present.\n * This is an alias of {@link util.isSet}.\n * @function\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isset =\n\n/**\n * Checks if a property on a message is considered to be present.\n * @param {Object} obj Plain object or message instance\n * @param {string} prop Property name\n * @returns {boolean} `true` if considered to be present, otherwise `false`\n */\nutil.isSet = function isSet(obj, prop) {\n    var value = obj[prop];\n    if (value != null && obj.hasOwnProperty(prop)) // eslint-disable-line eqeqeq, no-prototype-builtins\n        return typeof value !== \"object\" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;\n    return false;\n};\n\n/**\n * Any compatible Buffer instance.\n * This is a minimal stand-alone definition of a Buffer instance. The actual type is that exported by node's typings.\n * @interface Buffer\n * @extends Uint8Array\n */\n\n/**\n * Node's Buffer class if available.\n * @type {Constructor<Buffer>}\n */\nutil.Buffer = (function() {\n    try {\n        var Buffer = util.inquire(\"buffer\").Buffer;\n        // refuse to use non-node buffers if not explicitly assigned (perf reasons):\n        return Buffer.prototype.utf8Write ? Buffer : /* istanbul ignore next */ null;\n    } catch (e) {\n        /* istanbul ignore next */\n        return null;\n    }\n})();\n\n// Internal alias of or polyfull for Buffer.from.\nutil._Buffer_from = null;\n\n// Internal alias of or polyfill for Buffer.allocUnsafe.\nutil._Buffer_allocUnsafe = null;\n\n/**\n * Creates a new buffer of whatever type supported by the environment.\n * @param {number|number[]} [sizeOrArray=0] Buffer size or number array\n * @returns {Uint8Array|Buffer} Buffer\n */\nutil.newBuffer = function newBuffer(sizeOrArray) {\n    /* istanbul ignore next */\n    return typeof sizeOrArray === \"number\"\n        ? util.Buffer\n            ? util._Buffer_allocUnsafe(sizeOrArray)\n            : new util.Array(sizeOrArray)\n        : util.Buffer\n            ? util._Buffer_from(sizeOrArray)\n            : typeof Uint8Array === \"undefined\"\n                ? sizeOrArray\n                : new Uint8Array(sizeOrArray);\n};\n\n/**\n * Array implementation used in the browser. `Uint8Array` if supported, otherwise `Array`.\n * @type {Constructor<Uint8Array>}\n */\nutil.Array = typeof Uint8Array !== \"undefined\" ? Uint8Array /* istanbul ignore next */ : Array;\n\n/**\n * Any compatible Long instance.\n * This is a minimal stand-alone definition of a Long instance. The actual type is that exported by long.js.\n * @interface Long\n * @property {number} low Low bits\n * @property {number} high High bits\n * @property {boolean} unsigned Whether unsigned or not\n */\n\n/**\n * Long.js's Long class if available.\n * @type {Constructor<Long>}\n */\nutil.Long = /* istanbul ignore next */ util.global.dcodeIO && /* istanbul ignore next */ util.global.dcodeIO.Long\n         || /* istanbul ignore next */ util.global.Long\n         || util.inquire(\"long\");\n\n/**\n * Regular expression used to verify 2 bit (`bool`) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key2Re = /^true|false|0|1$/;\n\n/**\n * Regular expression used to verify 32 bit (`int32` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key32Re = /^-?(?:0|[1-9][0-9]*)$/;\n\n/**\n * Regular expression used to verify 64 bit (`int64` etc.) map keys.\n * @type {RegExp}\n * @const\n */\nutil.key64Re = /^(?:[\\\\x00-\\\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;\n\n/**\n * Converts a number or long to an 8 characters long hash string.\n * @param {Long|number} value Value to convert\n * @returns {string} Hash\n */\nutil.longToHash = function longToHash(value) {\n    return value\n        ? util.LongBits.from(value).toHash()\n        : util.LongBits.zeroHash;\n};\n\n/**\n * Converts an 8 characters long hash string to a long or number.\n * @param {string} hash Hash\n * @param {boolean} [unsigned=false] Whether unsigned or not\n * @returns {Long|number} Original value\n */\nutil.longFromHash = function longFromHash(hash, unsigned) {\n    var bits = util.LongBits.fromHash(hash);\n    if (util.Long)\n        return util.Long.fromBits(bits.lo, bits.hi, unsigned);\n    return bits.toNumber(Boolean(unsigned));\n};\n\n/**\n * Merges the properties of the source object into the destination object.\n * @memberof util\n * @param {Object.<string,*>} dst Destination object\n * @param {Object.<string,*>} src Source object\n * @param {boolean} [ifNotSet=false] Merges only if the key is not already set\n * @returns {Object.<string,*>} Destination object\n */\nfunction merge(dst, src, ifNotSet) { // used by converters\n    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)\n        if (dst[keys[i]] === undefined || !ifNotSet)\n            dst[keys[i]] = src[keys[i]];\n    return dst;\n}\n\nutil.merge = merge;\n\n/**\n * Converts the first character of a string to lower case.\n * @param {string} str String to convert\n * @returns {string} Converted string\n */\nutil.lcFirst = function lcFirst(str) {\n    return str.charAt(0).toLowerCase() + str.substring(1);\n};\n\n/**\n * Creates a custom error constructor.\n * @memberof util\n * @param {string} name Error name\n * @returns {Constructor<Error>} Custom error constructor\n */\nfunction newError(name) {\n\n    function CustomError(message, properties) {\n\n        if (!(this instanceof CustomError))\n            return new CustomError(message, properties);\n\n        // Error.call(this, message);\n        // ^ just returns a new error instance because the ctor can be called as a function\n\n        Object.defineProperty(this, \"message\", { get: function() { return message; } });\n\n        /* istanbul ignore next */\n        if (Error.captureStackTrace) // node\n            Error.captureStackTrace(this, CustomError);\n        else\n            Object.defineProperty(this, \"stack\", { value: new Error().stack || \"\" });\n\n        if (properties)\n            merge(this, properties);\n    }\n\n    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;\n\n    Object.defineProperty(CustomError.prototype, \"name\", { get: function() { return name; } });\n\n    CustomError.prototype.toString = function toString() {\n        return this.name + \": \" + this.message;\n    };\n\n    return CustomError;\n}\n\nutil.newError = newError;\n\n/**\n * Constructs a new protocol error.\n * @classdesc Error subclass indicating a protocol specifc error.\n * @memberof util\n * @extends Error\n * @template T extends Message<T>\n * @constructor\n * @param {string} message Error message\n * @param {Object.<string,*>} [properties] Additional properties\n * @example\n * try {\n *     MyMessage.decode(someBuffer); // throws if required fields are missing\n * } catch (e) {\n *     if (e instanceof ProtocolError && e.instance)\n *         console.log(\"decoded so far: \" + JSON.stringify(e.instance));\n * }\n */\nutil.ProtocolError = newError(\"ProtocolError\");\n\n/**\n * So far decoded message instance.\n * @name util.ProtocolError#instance\n * @type {Message<T>}\n */\n\n/**\n * A OneOf getter as returned by {@link util.oneOfGetter}.\n * @typedef OneOfGetter\n * @type {function}\n * @returns {string|undefined} Set field name, if any\n */\n\n/**\n * Builds a getter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfGetter} Unbound getter\n */\nutil.oneOfGetter = function getOneOf(fieldNames) {\n    var fieldMap = {};\n    for (var i = 0; i < fieldNames.length; ++i)\n        fieldMap[fieldNames[i]] = 1;\n\n    /**\n     * @returns {string|undefined} Set field name, if any\n     * @this Object\n     * @ignore\n     */\n    return function() { // eslint-disable-line consistent-return\n        for (var keys = Object.keys(this), i = keys.length - 1; i > -1; --i)\n            if (fieldMap[keys[i]] === 1 && this[keys[i]] !== undefined && this[keys[i]] !== null)\n                return keys[i];\n    };\n};\n\n/**\n * A OneOf setter as returned by {@link util.oneOfSetter}.\n * @typedef OneOfSetter\n * @type {function}\n * @param {string|undefined} value Field name\n * @returns {undefined}\n */\n\n/**\n * Builds a setter for a oneof's present field name.\n * @param {string[]} fieldNames Field names\n * @returns {OneOfSetter} Unbound setter\n */\nutil.oneOfSetter = function setOneOf(fieldNames) {\n\n    /**\n     * @param {string} name Field name\n     * @returns {undefined}\n     * @this Object\n     * @ignore\n     */\n    return function(name) {\n        for (var i = 0; i < fieldNames.length; ++i)\n            if (fieldNames[i] !== name)\n                delete this[fieldNames[i]];\n    };\n};\n\n/**\n * Default conversion options used for {@link Message#toJSON} implementations.\n *\n * These options are close to proto3's JSON mapping with the exception that internal types like Any are handled just like messages. More precisely:\n *\n * - Longs become strings\n * - Enums become string keys\n * - Bytes become base64 encoded strings\n * - (Sub-)Messages become plain objects\n * - Maps become plain objects with all string keys\n * - Repeated fields become arrays\n * - NaN and Infinity for float and double fields become strings\n *\n * @type {IConversionOptions}\n * @see https://developers.google.com/protocol-buffers/docs/proto3?hl=en#json\n */\nutil.toJSONOptions = {\n    longs: String,\n    enums: String,\n    bytes: String,\n    json: true\n};\n\n// Sets up buffer utility according to the environment (called in index-minimal)\nutil._configure = function() {\n    var Buffer = util.Buffer;\n    /* istanbul ignore if */\n    if (!Buffer) {\n        util._Buffer_from = util._Buffer_allocUnsafe = null;\n        return;\n    }\n    // because node 4.x buffers are incompatible & immutable\n    // see: https://github.com/dcodeIO/protobuf.js/pull/665\n    util._Buffer_from = Buffer.from !== Uint8Array.from && Buffer.from ||\n        /* istanbul ignore next */\n        function Buffer_from(value, encoding) {\n            return new Buffer(value, encoding);\n        };\n    util._Buffer_allocUnsafe = Buffer.allocUnsafe ||\n        /* istanbul ignore next */\n        function Buffer_allocUnsafe(size) {\n            return new Buffer(size);\n        };\n};\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/util/minimal.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer.js":
/*!***********************************************!*\
  !*** ./node_modules/protobufjs/src/writer.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = Writer;\n\nvar util      = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\nvar BufferWriter; // cyclic\n\nvar LongBits  = util.LongBits,\n    base64    = util.base64,\n    utf8      = util.utf8;\n\n/**\n * Constructs a new writer operation instance.\n * @classdesc Scheduled writer operation.\n * @constructor\n * @param {function(*, Uint8Array, number)} fn Function to call\n * @param {number} len Value byte length\n * @param {*} val Value to write\n * @ignore\n */\nfunction Op(fn, len, val) {\n\n    /**\n     * Function to call.\n     * @type {function(Uint8Array, number, *)}\n     */\n    this.fn = fn;\n\n    /**\n     * Value byte length.\n     * @type {number}\n     */\n    this.len = len;\n\n    /**\n     * Next operation.\n     * @type {Writer.Op|undefined}\n     */\n    this.next = undefined;\n\n    /**\n     * Value to write.\n     * @type {*}\n     */\n    this.val = val; // type varies\n}\n\n/* istanbul ignore next */\nfunction noop() {} // eslint-disable-line no-empty-function\n\n/**\n * Constructs a new writer state instance.\n * @classdesc Copied writer state.\n * @memberof Writer\n * @constructor\n * @param {Writer} writer Writer to copy state from\n * @ignore\n */\nfunction State(writer) {\n\n    /**\n     * Current head.\n     * @type {Writer.Op}\n     */\n    this.head = writer.head;\n\n    /**\n     * Current tail.\n     * @type {Writer.Op}\n     */\n    this.tail = writer.tail;\n\n    /**\n     * Current buffer length.\n     * @type {number}\n     */\n    this.len = writer.len;\n\n    /**\n     * Next state.\n     * @type {State|null}\n     */\n    this.next = writer.states;\n}\n\n/**\n * Constructs a new writer instance.\n * @classdesc Wire format writer using `Uint8Array` if available, otherwise `Array`.\n * @constructor\n */\nfunction Writer() {\n\n    /**\n     * Current length.\n     * @type {number}\n     */\n    this.len = 0;\n\n    /**\n     * Operations head.\n     * @type {Object}\n     */\n    this.head = new Op(noop, 0, 0);\n\n    /**\n     * Operations tail\n     * @type {Object}\n     */\n    this.tail = this.head;\n\n    /**\n     * Linked forked states.\n     * @type {Object|null}\n     */\n    this.states = null;\n\n    // When a value is written, the writer calculates its byte length and puts it into a linked\n    // list of operations to perform when finish() is called. This both allows us to allocate\n    // buffers of the exact required size and reduces the amount of work we have to do compared\n    // to first calculating over objects and then encoding over objects. In our case, the encoding\n    // part is just a linked list walk calling operations with already prepared values.\n}\n\nvar create = function create() {\n    return util.Buffer\n        ? function create_buffer_setup() {\n            return (Writer.create = function create_buffer() {\n                return new BufferWriter();\n            })();\n        }\n        /* istanbul ignore next */\n        : function create_array() {\n            return new Writer();\n        };\n};\n\n/**\n * Creates a new writer.\n * @function\n * @returns {BufferWriter|Writer} A {@link BufferWriter} when Buffers are supported, otherwise a {@link Writer}\n */\nWriter.create = create();\n\n/**\n * Allocates a buffer of the specified size.\n * @param {number} size Buffer size\n * @returns {Uint8Array} Buffer\n */\nWriter.alloc = function alloc(size) {\n    return new util.Array(size);\n};\n\n// Use Uint8Array buffer pool in the browser, just like node does with buffers\n/* istanbul ignore else */\nif (util.Array !== Array)\n    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);\n\n/**\n * Pushes a new operation to the queue.\n * @param {function(Uint8Array, number, *)} fn Function to call\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @returns {Writer} `this`\n * @private\n */\nWriter.prototype._push = function push(fn, len, val) {\n    this.tail = this.tail.next = new Op(fn, len, val);\n    this.len += len;\n    return this;\n};\n\nfunction writeByte(val, buf, pos) {\n    buf[pos] = val & 255;\n}\n\nfunction writeVarint32(val, buf, pos) {\n    while (val > 127) {\n        buf[pos++] = val & 127 | 128;\n        val >>>= 7;\n    }\n    buf[pos] = val;\n}\n\n/**\n * Constructs a new varint writer operation instance.\n * @classdesc Scheduled varint writer operation.\n * @extends Op\n * @constructor\n * @param {number} len Value byte length\n * @param {number} val Value to write\n * @ignore\n */\nfunction VarintOp(len, val) {\n    this.len = len;\n    this.next = undefined;\n    this.val = val;\n}\n\nVarintOp.prototype = Object.create(Op.prototype);\nVarintOp.prototype.fn = writeVarint32;\n\n/**\n * Writes an unsigned 32 bit value as a varint.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.uint32 = function write_uint32(value) {\n    // here, the call to this.push has been inlined and a varint specific Op subclass is used.\n    // uint32 is by far the most frequently used operation and benefits significantly from this.\n    this.len += (this.tail = this.tail.next = new VarintOp(\n        (value = value >>> 0)\n                < 128       ? 1\n        : value < 16384     ? 2\n        : value < 2097152   ? 3\n        : value < 268435456 ? 4\n        :                     5,\n    value)).len;\n    return this;\n};\n\n/**\n * Writes a signed 32 bit value as a varint.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.int32 = function write_int32(value) {\n    return value < 0\n        ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) // 10 bytes per spec\n        : this.uint32(value);\n};\n\n/**\n * Writes a 32 bit value as a varint, zig-zag encoded.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sint32 = function write_sint32(value) {\n    return this.uint32((value << 1 ^ value >> 31) >>> 0);\n};\n\nfunction writeVarint64(val, buf, pos) {\n    while (val.hi) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;\n        val.hi >>>= 7;\n    }\n    while (val.lo > 127) {\n        buf[pos++] = val.lo & 127 | 128;\n        val.lo = val.lo >>> 7;\n    }\n    buf[pos++] = val.lo;\n}\n\n/**\n * Writes an unsigned 64 bit value as a varint.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.uint64 = function write_uint64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a signed 64 bit value as a varint.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.int64 = Writer.prototype.uint64;\n\n/**\n * Writes a signed 64 bit value as a varint, zig-zag encoded.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sint64 = function write_sint64(value) {\n    var bits = LongBits.from(value).zzEncode();\n    return this._push(writeVarint64, bits.length(), bits);\n};\n\n/**\n * Writes a boolish value as a varint.\n * @param {boolean} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bool = function write_bool(value) {\n    return this._push(writeByte, 1, value ? 1 : 0);\n};\n\nfunction writeFixed32(val, buf, pos) {\n    buf[pos    ] =  val         & 255;\n    buf[pos + 1] =  val >>> 8   & 255;\n    buf[pos + 2] =  val >>> 16  & 255;\n    buf[pos + 3] =  val >>> 24;\n}\n\n/**\n * Writes an unsigned 32 bit value as fixed 32 bits.\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.fixed32 = function write_fixed32(value) {\n    return this._push(writeFixed32, 4, value >>> 0);\n};\n\n/**\n * Writes a signed 32 bit value as fixed 32 bits.\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.sfixed32 = Writer.prototype.fixed32;\n\n/**\n * Writes an unsigned 64 bit value as fixed 64 bits.\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.fixed64 = function write_fixed64(value) {\n    var bits = LongBits.from(value);\n    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);\n};\n\n/**\n * Writes a signed 64 bit value as fixed 64 bits.\n * @function\n * @param {Long|number|string} value Value to write\n * @returns {Writer} `this`\n * @throws {TypeError} If `value` is a string and no long library is present.\n */\nWriter.prototype.sfixed64 = Writer.prototype.fixed64;\n\n/**\n * Writes a float (32 bit).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.float = function write_float(value) {\n    return this._push(util.float.writeFloatLE, 4, value);\n};\n\n/**\n * Writes a double (64 bit float).\n * @function\n * @param {number} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.double = function write_double(value) {\n    return this._push(util.float.writeDoubleLE, 8, value);\n};\n\nvar writeBytes = util.Array.prototype.set\n    ? function writeBytes_set(val, buf, pos) {\n        buf.set(val, pos); // also works for plain array values\n    }\n    /* istanbul ignore next */\n    : function writeBytes_for(val, buf, pos) {\n        for (var i = 0; i < val.length; ++i)\n            buf[pos + i] = val[i];\n    };\n\n/**\n * Writes a sequence of bytes.\n * @param {Uint8Array|string} value Buffer or base64 encoded string to write\n * @returns {Writer} `this`\n */\nWriter.prototype.bytes = function write_bytes(value) {\n    var len = value.length >>> 0;\n    if (!len)\n        return this._push(writeByte, 1, 0);\n    if (util.isString(value)) {\n        var buf = Writer.alloc(len = base64.length(value));\n        base64.decode(value, buf, 0);\n        value = buf;\n    }\n    return this.uint32(len)._push(writeBytes, len, value);\n};\n\n/**\n * Writes a string.\n * @param {string} value Value to write\n * @returns {Writer} `this`\n */\nWriter.prototype.string = function write_string(value) {\n    var len = utf8.length(value);\n    return len\n        ? this.uint32(len)._push(utf8.write, len, value)\n        : this._push(writeByte, 1, 0);\n};\n\n/**\n * Forks this writer's state by pushing it to a stack.\n * Calling {@link Writer#reset|reset} or {@link Writer#ldelim|ldelim} resets the writer to the previous state.\n * @returns {Writer} `this`\n */\nWriter.prototype.fork = function fork() {\n    this.states = new State(this);\n    this.head = this.tail = new Op(noop, 0, 0);\n    this.len = 0;\n    return this;\n};\n\n/**\n * Resets this instance to the last state.\n * @returns {Writer} `this`\n */\nWriter.prototype.reset = function reset() {\n    if (this.states) {\n        this.head   = this.states.head;\n        this.tail   = this.states.tail;\n        this.len    = this.states.len;\n        this.states = this.states.next;\n    } else {\n        this.head = this.tail = new Op(noop, 0, 0);\n        this.len  = 0;\n    }\n    return this;\n};\n\n/**\n * Resets to the last state and appends the fork state's current write length as a varint followed by its operations.\n * @returns {Writer} `this`\n */\nWriter.prototype.ldelim = function ldelim() {\n    var head = this.head,\n        tail = this.tail,\n        len  = this.len;\n    this.reset().uint32(len);\n    if (len) {\n        this.tail.next = head.next; // skip noop\n        this.tail = tail;\n        this.len += len;\n    }\n    return this;\n};\n\n/**\n * Finishes the write operation.\n * @returns {Uint8Array} Finished buffer\n */\nWriter.prototype.finish = function finish() {\n    var head = this.head.next, // skip noop\n        buf  = this.constructor.alloc(this.len),\n        pos  = 0;\n    while (head) {\n        head.fn(head.val, buf, pos);\n        pos += head.len;\n        head = head.next;\n    }\n    // this.head = this.tail = null;\n    return buf;\n};\n\nWriter._configure = function(BufferWriter_) {\n    BufferWriter = BufferWriter_;\n    Writer.create = create();\n    BufferWriter._configure();\n};\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer.js?");

/***/ }),

/***/ "./node_modules/protobufjs/src/writer_buffer.js":
/*!******************************************************!*\
  !*** ./node_modules/protobufjs/src/writer_buffer.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nmodule.exports = BufferWriter;\n\n// extends Writer\nvar Writer = __webpack_require__(/*! ./writer */ \"./node_modules/protobufjs/src/writer.js\");\n(BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;\n\nvar util = __webpack_require__(/*! ./util/minimal */ \"./node_modules/protobufjs/src/util/minimal.js\");\n\n/**\n * Constructs a new buffer writer instance.\n * @classdesc Wire format writer using node buffers.\n * @extends Writer\n * @constructor\n */\nfunction BufferWriter() {\n    Writer.call(this);\n}\n\nBufferWriter._configure = function () {\n    /**\n     * Allocates a buffer of the specified size.\n     * @function\n     * @param {number} size Buffer size\n     * @returns {Buffer} Buffer\n     */\n    BufferWriter.alloc = util._Buffer_allocUnsafe;\n\n    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === \"set\"\n        ? function writeBytesBuffer_set(val, buf, pos) {\n          buf.set(val, pos); // faster than copy (requires node >= 4 where Buffers extend Uint8Array and set is properly inherited)\n          // also works for plain array values\n        }\n        /* istanbul ignore next */\n        : function writeBytesBuffer_copy(val, buf, pos) {\n          if (val.copy) // Buffer values\n            val.copy(buf, pos, 0, val.length);\n          else for (var i = 0; i < val.length;) // plain array values\n            buf[pos++] = val[i++];\n        };\n};\n\n\n/**\n * @override\n */\nBufferWriter.prototype.bytes = function write_bytes_buffer(value) {\n    if (util.isString(value))\n        value = util._Buffer_from(value, \"base64\");\n    var len = value.length >>> 0;\n    this.uint32(len);\n    if (len)\n        this._push(BufferWriter.writeBytesBuffer, len, value);\n    return this;\n};\n\nfunction writeStringBuffer(val, buf, pos) {\n    if (val.length < 40) // plain js is faster for short strings (probably due to redundant assertions)\n        util.utf8.write(val, buf, pos);\n    else if (buf.utf8Write)\n        buf.utf8Write(val, pos);\n    else\n        buf.write(val, pos);\n}\n\n/**\n * @override\n */\nBufferWriter.prototype.string = function write_string_buffer(value) {\n    var len = util.Buffer.byteLength(value);\n    this.uint32(len);\n    if (len)\n        this._push(writeStringBuffer, len, value);\n    return this;\n};\n\n\n/**\n * Finishes the write operation.\n * @name BufferWriter#finish\n * @function\n * @returns {Buffer} Finished buffer\n */\n\nBufferWriter._configure();\n\n\n//# sourceURL=webpack:///./node_modules/protobufjs/src/writer_buffer.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./packages/atomicHelpers/landHelpers.ts":
/*!***********************************************!*\
  !*** ./packages/atomicHelpers/landHelpers.ts ***!
  \***********************************************/
/*! exports provided: getParcelSceneLimits, isAdjacent, isEqual */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParcelSceneLimits\", function() { return getParcelSceneLimits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isAdjacent\", function() { return isAdjacent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isEqual\", function() { return isEqual; });\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./packages/config/index.ts\");\n\nfunction getParcelSceneLimits(parcelCount) {\n    const log = Math.log2(parcelCount + 1);\n    const lineal = parcelCount;\n    return {\n        triangles: Math.floor(lineal * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].triangles),\n        bodies: Math.floor(lineal * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].bodies),\n        entities: Math.floor(lineal * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].entities),\n        materials: Math.floor(log * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].materials),\n        textures: Math.floor(log * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].textures),\n        geometries: Math.floor(log * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].geometries)\n    };\n}\nfunction isAdjacent(p1, p2) {\n    return ((p2.x === p1.x && (p2.y + 1 === p1.y || p2.y - 1 === p1.y)) ||\n        (p2.y === p1.y && (p2.x + 1 === p1.x || p2.x - 1 === p1.x)));\n}\nfunction isEqual(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n\n//# sourceURL=webpack:///./packages/atomicHelpers/landHelpers.ts?");

/***/ }),

/***/ "./packages/atomicHelpers/parcelScenePositions.ts":
/*!********************************************************!*\
  !*** ./packages/atomicHelpers/parcelScenePositions.ts ***!
  \********************************************************/
/*! exports provided: gridToWorld, worldToGrid, isInParcel, isWorldPositionInsideParcels, isOnLimits, gridToParcel, decodeParcelSceneBoundaries, encodeParcelPosition, encodeParcelSceneBoundaries, parseParcelPosition, isValidParcelSceneShape, areConnected */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gridToWorld\", function() { return gridToWorld; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"worldToGrid\", function() { return worldToGrid; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isInParcel\", function() { return isInParcel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isWorldPositionInsideParcels\", function() { return isWorldPositionInsideParcels; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isOnLimits\", function() { return isOnLimits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"gridToParcel\", function() { return gridToParcel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"decodeParcelSceneBoundaries\", function() { return decodeParcelSceneBoundaries; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encodeParcelPosition\", function() { return encodeParcelPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"encodeParcelSceneBoundaries\", function() { return encodeParcelSceneBoundaries; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parseParcelPosition\", function() { return parseParcelPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isValidParcelSceneShape\", function() { return isValidParcelSceneShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"areConnected\", function() { return areConnected; });\n/* harmony import */ var config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! config */ \"./packages/config/index.ts\");\n/* harmony import */ var _landHelpers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./landHelpers */ \"./packages/atomicHelpers/landHelpers.ts\");\n\n\nconst auxVec3 = { x: 0, y: 0, z: 0 };\nfunction gridToWorld(x, y, target = { x: 0, y: 0, z: 0 }) {\n    target.x = x * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].parcelSize;\n    target.y = 0;\n    target.z = y * config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].parcelSize;\n    return target;\n}\nfunction worldToGrid(vector, target = { x: 0, y: 0 }) {\n    target.x = Math.floor(vector.x / config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].parcelSize);\n    target.y = Math.floor(vector.z / config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].parcelSize);\n    return target;\n}\nconst highDelta = config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].parcelSize + config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].centimeter;\nconst lowDelta = config__WEBPACK_IMPORTED_MODULE_0__[\"parcelLimits\"].centimeter;\nfunction isInParcel(test, center) {\n    return (test.x < center.x + highDelta &&\n        test.x > center.x - lowDelta &&\n        test.z < center.z + highDelta &&\n        test.z > center.z - lowDelta);\n}\nfunction isWorldPositionInsideParcels(parcels, testWorldPosition) {\n    let isInside = false;\n    parcels.some((parcel) => {\n        const { x, y } = parseParcelPosition(parcel);\n        isInside = isInParcel(testWorldPosition, gridToWorld(x, y));\n        return isInside;\n    });\n    return isInside;\n}\nfunction isOnLimits({ maximum, minimum }, parcels) {\n    let minInside = false;\n    let maxInside = false;\n    for (let i = 0; i < parcels.length && (!minInside || !maxInside); i++) {\n        maxInside = maxInside || isInParcel(maximum, parcels[i]);\n        minInside = minInside || isInParcel(minimum, parcels[i]);\n    }\n    return minInside && maxInside;\n}\nfunction gridToParcel(base, x, y, target) {\n    gridToWorld(base.x, base.y, auxVec3);\n    gridToWorld(x, y, target);\n    target.x -= auxVec3.x;\n    target.y -= auxVec3.y;\n    target.z -= auxVec3.z;\n}\nfunction decodeParcelSceneBoundaries(boundaries) {\n    const [base, ...parcels] = boundaries.split(/\\s*;\\s*/).map(($) => parseParcelPosition($));\n    return { base, parcels };\n}\nfunction encodeParcelPosition(base) {\n    return `${base.x | 0},${base.y | 0}`;\n}\nfunction encodeParcelSceneBoundaries(base, parcels) {\n    let str = encodeParcelPosition(base);\n    for (let index = 0; index < parcels.length; index++) {\n        const parcel = parcels[index];\n        str = str + `;${encodeParcelPosition(parcel)}`;\n    }\n    return str;\n}\nfunction parseParcelPosition(position) {\n    const [x, y] = position\n        .trim()\n        .split(/\\s*,\\s*/)\n        .map(($) => parseInt($, 10));\n    return { x, y };\n}\nfunction isValidParcelSceneShape(parcels) {\n    return areConnected(parcels);\n}\nfunction areConnected(parcels) {\n    if (parcels.length === 0) {\n        return false;\n    }\n    const visited = visitParcel(parcels[0], parcels);\n    return visited.length === parcels.length;\n}\nfunction visitParcel(parcel, allParcels = [parcel], visited = []) {\n    const isVisited = visited.some((visitedParcel) => Object(_landHelpers__WEBPACK_IMPORTED_MODULE_1__[\"isEqual\"])(visitedParcel, parcel));\n    if (!isVisited) {\n        visited.push(parcel);\n        const neighbours = getNeighbours(parcel.x, parcel.y, allParcels);\n        neighbours.forEach((neighbours) => visitParcel(neighbours, allParcels, visited));\n    }\n    return visited;\n}\nfunction getIsNeighbourMatcher(x, y) {\n    return (coords) => (coords.x === x && (coords.y + 1 === y || coords.y - 1 === y)) ||\n        (coords.y === y && (coords.x + 1 === x || coords.x - 1 === x));\n}\nfunction getNeighbours(x, y, parcels) {\n    return parcels.filter(getIsNeighbourMatcher(x, y));\n}\n\n\n//# sourceURL=webpack:///./packages/atomicHelpers/parcelScenePositions.ts?");

/***/ }),

/***/ "./packages/config/index.ts":
/*!**********************************!*\
  !*** ./packages/config/index.ts ***!
  \**********************************/
/*! exports provided: NETWORK_HZ, interactionLimits, parcelLimits, playerConfigurations, PREVIEW, EDITOR, WORLD_EXPLORER, RENDERER_WS, OPEN_AVATAR_EDITOR, ENV_OVERRIDE, GIF_WORKERS, COMMS, COMMS_PROFILE_TIMEOUT, DECENTRALAND_SPACE, PARCEL_LOADING_ENABLED, UPDATE_CONTENT_SERVICE, FETCH_CONTENT_SERVICE, COMMS_SERVICE, HOTSCENES_SERVICE, POI_SERVICE, PREFERED_ISLAND, TRACE_RENDERER, LOS, DEBUG, DEBUG_COMMS, DEBUG_ANALYTICS, DEBUG_MOBILE, DEBUG_MESSAGES, DEBUG_MESSAGES_QUEUE_PERF, DEBUG_WS_MESSAGES, DEBUG_REDUX, DEBUG_LOGIN, DEBUG_PM, DEBUG_SCENE_LOG, DEBUG_KERNEL_LOG, DEBUG_PREFIX, RESET_TUTORIAL, ENGINE_DEBUG_PANEL, SCENE_DEBUG_PANEL, SHOW_FPS_COUNTER, HAS_INITIAL_POSITION_MARK, WSS_ENABLED, FORCE_SEND_MESSAGE, ASSET_BUNDLES_DOMAIN, QS_MAX_VISIBLE_PEERS, BUILDER_SERVER_URL, rootURLPreviewMode, PIN_CATALYST, FORCE_RENDERING_STYLE, commConfigurations, ETHEREUM_NETWORK, knownTLDs, getTLD, WITH_FIXED_ITEMS, WITH_FIXED_COLLECTIONS, ENABLE_EMPTY_SCENES, getAssetBundlesBaseUrl, getServerConfigurations, ethereumConfigurations, isRunningTest, genericAvatarSnapshots, getCatalystNodesDefaultURL */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"NETWORK_HZ\", function() { return NETWORK_HZ; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"interactionLimits\", function() { return interactionLimits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"parcelLimits\", function() { return parcelLimits; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"playerConfigurations\", function() { return playerConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PREVIEW\", function() { return PREVIEW; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EDITOR\", function() { return EDITOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WORLD_EXPLORER\", function() { return WORLD_EXPLORER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RENDERER_WS\", function() { return RENDERER_WS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OPEN_AVATAR_EDITOR\", function() { return OPEN_AVATAR_EDITOR; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ENV_OVERRIDE\", function() { return ENV_OVERRIDE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GIF_WORKERS\", function() { return GIF_WORKERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMS\", function() { return COMMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMS_PROFILE_TIMEOUT\", function() { return COMMS_PROFILE_TIMEOUT; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DECENTRALAND_SPACE\", function() { return DECENTRALAND_SPACE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PARCEL_LOADING_ENABLED\", function() { return PARCEL_LOADING_ENABLED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UPDATE_CONTENT_SERVICE\", function() { return UPDATE_CONTENT_SERVICE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FETCH_CONTENT_SERVICE\", function() { return FETCH_CONTENT_SERVICE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"COMMS_SERVICE\", function() { return COMMS_SERVICE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HOTSCENES_SERVICE\", function() { return HOTSCENES_SERVICE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"POI_SERVICE\", function() { return POI_SERVICE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PREFERED_ISLAND\", function() { return PREFERED_ISLAND; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TRACE_RENDERER\", function() { return TRACE_RENDERER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LOS\", function() { return LOS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG\", function() { return DEBUG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_COMMS\", function() { return DEBUG_COMMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_ANALYTICS\", function() { return DEBUG_ANALYTICS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_MOBILE\", function() { return DEBUG_MOBILE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_MESSAGES\", function() { return DEBUG_MESSAGES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_MESSAGES_QUEUE_PERF\", function() { return DEBUG_MESSAGES_QUEUE_PERF; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_WS_MESSAGES\", function() { return DEBUG_WS_MESSAGES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_REDUX\", function() { return DEBUG_REDUX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_LOGIN\", function() { return DEBUG_LOGIN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_PM\", function() { return DEBUG_PM; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_SCENE_LOG\", function() { return DEBUG_SCENE_LOG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_KERNEL_LOG\", function() { return DEBUG_KERNEL_LOG; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DEBUG_PREFIX\", function() { return DEBUG_PREFIX; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RESET_TUTORIAL\", function() { return RESET_TUTORIAL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ENGINE_DEBUG_PANEL\", function() { return ENGINE_DEBUG_PANEL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SCENE_DEBUG_PANEL\", function() { return SCENE_DEBUG_PANEL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SHOW_FPS_COUNTER\", function() { return SHOW_FPS_COUNTER; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HAS_INITIAL_POSITION_MARK\", function() { return HAS_INITIAL_POSITION_MARK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WSS_ENABLED\", function() { return WSS_ENABLED; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FORCE_SEND_MESSAGE\", function() { return FORCE_SEND_MESSAGE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ASSET_BUNDLES_DOMAIN\", function() { return ASSET_BUNDLES_DOMAIN; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QS_MAX_VISIBLE_PEERS\", function() { return QS_MAX_VISIBLE_PEERS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BUILDER_SERVER_URL\", function() { return BUILDER_SERVER_URL; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"rootURLPreviewMode\", function() { return rootURLPreviewMode; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PIN_CATALYST\", function() { return PIN_CATALYST; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FORCE_RENDERING_STYLE\", function() { return FORCE_RENDERING_STYLE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"commConfigurations\", function() { return commConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ETHEREUM_NETWORK\", function() { return ETHEREUM_NETWORK; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"knownTLDs\", function() { return knownTLDs; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getTLD\", function() { return getTLD; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WITH_FIXED_ITEMS\", function() { return WITH_FIXED_ITEMS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"WITH_FIXED_COLLECTIONS\", function() { return WITH_FIXED_COLLECTIONS; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ENABLE_EMPTY_SCENES\", function() { return ENABLE_EMPTY_SCENES; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getAssetBundlesBaseUrl\", function() { return getAssetBundlesBaseUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getServerConfigurations\", function() { return getServerConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ethereumConfigurations\", function() { return ethereumConfigurations; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"isRunningTest\", function() { return isRunningTest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"genericAvatarSnapshots\", function() { return genericAvatarSnapshots; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getCatalystNodesDefaultURL\", function() { return getCatalystNodesDefaultURL; });\n/* harmony import */ var _dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/urn-resolver/dist/contracts */ \"./node_modules/@dcl/urn-resolver/dist/contracts.js\");\n/* harmony import */ var _dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_store_isolatedStore__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/store/isolatedStore */ \"./packages/shared/store/isolatedStore.ts\");\nvar _a;\n\n\nconst NETWORK_HZ = 10;\nvar interactionLimits;\n(function (interactionLimits) {\n    interactionLimits.clickDistance = 10;\n})(interactionLimits || (interactionLimits = {}));\nvar parcelLimits;\n(function (parcelLimits) {\n    parcelLimits.entities = 200;\n    parcelLimits.triangles = 10000;\n    parcelLimits.bodies = 300;\n    parcelLimits.textures = 10;\n    parcelLimits.materials = 20;\n    parcelLimits.height = 20;\n    parcelLimits.geometries = 200;\n    parcelLimits.parcelSize = 16;\n    parcelLimits.halfParcelSize = parcelLimits.parcelSize / 2;\n    parcelLimits.centimeter = 0.01;\n    parcelLimits.visibleRadius = 4;\n    parcelLimits.maxParcelX = 150;\n    parcelLimits.maxParcelZ = 150;\n    parcelLimits.minParcelX = -150;\n    parcelLimits.minParcelZ = -150;\n})(parcelLimits || (parcelLimits = {}));\nvar playerConfigurations;\n(function (playerConfigurations) {\n    playerConfigurations.gravity = -0.2;\n    playerConfigurations.height = 1.6;\n    playerConfigurations.handFromBodyDistance = 0.5;\n    playerConfigurations.speed = 2;\n    playerConfigurations.runningSpeed = 8;\n    playerConfigurations.inertia = 0.01;\n    playerConfigurations.angularSensibility = 500;\n})(playerConfigurations || (playerConfigurations = {}));\nconst PREVIEW = !!globalThis.preview;\nconst EDITOR = !!globalThis.isEditor;\nconst WORLD_EXPLORER = !EDITOR && !PREVIEW;\nconst RENDERER_WS = location.search.includes('ws');\nconst OPEN_AVATAR_EDITOR = location.search.includes('OPEN_AVATAR_EDITOR') && WORLD_EXPLORER;\nconst ENV_OVERRIDE = location.search.includes('ENV');\nconst GIF_WORKERS = location.search.includes('GIF_WORKERS');\nconst qs = new URLSearchParams(location.search);\nfunction ensureQueryStringUrl(value) {\n    if (!value)\n        return null;\n    if (typeof value === 'string')\n        return addHttpsIfNoProtocolIsSet(value);\n    return addHttpsIfNoProtocolIsSet(value[0]);\n}\nfunction ensureSingleString(value) {\n    if (!value)\n        return null;\n    if (typeof value === 'string')\n        return value;\n    return value[0];\n}\nconst USE_LOCAL_COMMS = location.search.includes('LOCAL_COMMS') || PREVIEW;\nconst COMMS = !qs.has('COMMS') && USE_LOCAL_COMMS ? 'v1' : qs.get('COMMS') ? ensureSingleString(qs.get('COMMS')) : 'v2';\nconst COMMS_PROFILE_TIMEOUT = 10000;\nconst DECENTRALAND_SPACE = qs.get('SPACE');\nconst PARCEL_LOADING_ENABLED = !DECENTRALAND_SPACE || qs.has('DISABLE_PARCEL_LOADING');\nconst UPDATE_CONTENT_SERVICE = ensureQueryStringUrl(qs.get('UPDATE_CONTENT_SERVICE'));\nconst FETCH_CONTENT_SERVICE = ensureQueryStringUrl(qs.get('FETCH_CONTENT_SERVICE'));\nconst COMMS_SERVICE = ensureSingleString(qs.get('COMMS_SERVICE'));\nconst HOTSCENES_SERVICE = ensureSingleString(qs.get('HOTSCENES_SERVICE'));\nconst POI_SERVICE = ensureSingleString(qs.get('POI_SERVICE'));\nconst PREFERED_ISLAND = ensureSingleString(qs.get('island'));\nconst TRACE_RENDERER = ensureSingleString(qs.get('TRACE_RENDERER'));\nconst LOS = ensureSingleString(qs.get('LOS'));\nconst DEBUG = location.search.includes('DEBUG_MODE') || !!globalThis.mocha || PREVIEW || EDITOR;\nconst DEBUG_COMMS = qs.has('DEBUG_COMMS');\nconst DEBUG_ANALYTICS = location.search.includes('DEBUG_ANALYTICS');\nconst DEBUG_MOBILE = location.search.includes('DEBUG_MOBILE');\nconst DEBUG_MESSAGES = location.search.includes('DEBUG_MESSAGES');\nconst DEBUG_MESSAGES_QUEUE_PERF = location.search.includes('DEBUG_MESSAGES_QUEUE_PERF');\nconst DEBUG_WS_MESSAGES = location.search.includes('DEBUG_WS_MESSAGES');\nconst DEBUG_REDUX = location.search.includes('DEBUG_REDUX');\nconst DEBUG_LOGIN = location.search.includes('DEBUG_LOGIN');\nconst DEBUG_PM = location.search.includes('DEBUG_PM');\nconst DEBUG_SCENE_LOG = DEBUG || location.search.includes('DEBUG_SCENE_LOG');\nconst DEBUG_KERNEL_LOG = !PREVIEW || location.search.includes('DEBUG_KERNEL_LOG');\nconst DEBUG_PREFIX = ensureSingleString(qs.get('DEBUG_PREFIX'));\nconst RESET_TUTORIAL = location.search.includes('RESET_TUTORIAL');\nconst ENGINE_DEBUG_PANEL = location.search.includes('ENGINE_DEBUG_PANEL');\nconst SCENE_DEBUG_PANEL = location.search.includes('SCENE_DEBUG_PANEL') && !ENGINE_DEBUG_PANEL;\nconst SHOW_FPS_COUNTER = location.search.includes('SHOW_FPS_COUNTER') || DEBUG;\nconst HAS_INITIAL_POSITION_MARK = location.search.includes('position');\nconst WSS_ENABLED = !!ensureSingleString(qs.get('ws'));\nconst FORCE_SEND_MESSAGE = location.search.includes('FORCE_SEND_MESSAGE');\nconst ASSET_BUNDLES_DOMAIN = ensureSingleString(qs.get('ASSET_BUNDLES_DOMAIN'));\nconst QS_MAX_VISIBLE_PEERS = typeof qs.get('MAX_VISIBLE_PEERS') === 'string' ? parseInt(qs.get('MAX_VISIBLE_PEERS'), 10) : undefined;\nconst BUILDER_SERVER_URL = (_a = ensureSingleString(qs.get('BUILDER_SERVER_URL'))) !== null && _a !== void 0 ? _a : 'https://builder-api.decentraland.org/v1';\nconst rootURLPreviewMode = () => {\n    var _a;\n    if (typeof qs.get('CATALYST') === 'string' && ((_a = qs.get('CATALYST')) === null || _a === void 0 ? void 0 : _a.length) !== 0) {\n        return addHttpsIfNoProtocolIsSet(qs.get('CATALYST'));\n    }\n    return `${location.origin}${location.pathname}`.replace(/\\/$/, '');\n};\nconst PIN_CATALYST = PREVIEW\n    ? rootURLPreviewMode()\n    : typeof qs.get('CATALYST') === 'string'\n        ? addHttpsIfNoProtocolIsSet(qs.get('CATALYST'))\n        : undefined;\nconst FORCE_RENDERING_STYLE = ensureSingleString(qs.get('FORCE_RENDERING_STYLE'));\nconst META_CONFIG_URL = ensureSingleString(qs.get('META_CONFIG_URL'));\nvar commConfigurations;\n(function (commConfigurations) {\n    commConfigurations.debug = true;\n    commConfigurations.commRadius = 4;\n    commConfigurations.sendAnalytics = true;\n    commConfigurations.peerTtlMs = 60000;\n    commConfigurations.autoChangeRealmInterval = typeof qs.get('AUTO_CHANGE_INTERVAL') === 'string' ? parseInt(qs.get('AUTO_CHANGE_INTERVAL'), 10) * 1000 : 40000;\n    commConfigurations.defaultIceServers = [\n        { urls: 'stun:stun.l.google.com:19302' },\n        {\n            urls: 'turn:coturn-raw.decentraland.services:3478',\n            credential: 'passworddcl',\n            username: 'usernamedcl'\n        }\n    ];\n    commConfigurations.voiceChatUseHRTF = location.search.includes('VOICE_CHAT_USE_HRTF');\n})(commConfigurations || (commConfigurations = {}));\nvar ETHEREUM_NETWORK;\n(function (ETHEREUM_NETWORK) {\n    ETHEREUM_NETWORK[\"MAINNET\"] = \"mainnet\";\n    ETHEREUM_NETWORK[\"GOERLI\"] = \"goerli\";\n})(ETHEREUM_NETWORK || (ETHEREUM_NETWORK = {}));\nconst knownTLDs = ['zone', 'org', 'today'];\nfunction getTLD() {\n    if (ENV_OVERRIDE) {\n        return location.search.match(/ENV=(\\w+)/)[1];\n    }\n    const previsionalTld = location.hostname.match(/(\\w+)$/)[0];\n    if (knownTLDs.includes(previsionalTld))\n        return previsionalTld;\n    return 'org';\n}\nconst WITH_FIXED_ITEMS = (qs.get('WITH_ITEMS') && ensureSingleString(qs.get('WITH_ITEMS'))) || '';\nconst WITH_FIXED_COLLECTIONS = (qs.get('WITH_COLLECTIONS') && ensureSingleString(qs.get('WITH_COLLECTIONS'))) || '';\nconst ENABLE_EMPTY_SCENES = !location.search.includes('DISABLE_EMPTY_SCENES');\nfunction getAssetBundlesBaseUrl(network) {\n    var _a;\n    const state = shared_store_isolatedStore__WEBPACK_IMPORTED_MODULE_1__[\"store\"].getState();\n    return (ASSET_BUNDLES_DOMAIN || ((_a = state.meta.config.explorer) === null || _a === void 0 ? void 0 : _a.assetBundlesFetchUrl) || getDefaultAssetBundlesBaseUrl(network));\n}\nfunction getDefaultAssetBundlesBaseUrl(network) {\n    const tld = network === ETHEREUM_NETWORK.MAINNET ? 'org' : 'zone';\n    return `https://content-assets-as-bundle.decentraland.${tld}`;\n}\nfunction getServerConfigurations(network) {\n    var _a;\n    const tld = network === ETHEREUM_NETWORK.MAINNET ? 'org' : 'zone';\n    const metaConfigBaseUrl = META_CONFIG_URL || `https://config.decentraland.${tld}/explorer.json`;\n    const questsUrl = (_a = ensureSingleString(qs.get('QUESTS_SERVER_URL'))) !== null && _a !== void 0 ? _a : `https://quests-api.decentraland.${network ? 'org' : 'io'}`;\n    return {\n        explorerConfiguration: `${metaConfigBaseUrl}?t=${new Date().getTime()}`,\n        questsUrl\n    };\n}\nfunction assertValue(val) {\n    if (!val)\n        throw new Error('Value is missing');\n    return val;\n}\nvar ethereumConfigurations;\n(function (ethereumConfigurations) {\n    ethereumConfigurations.mainnet = {\n        wss: 'wss://rpc.decentraland.org/mainnet',\n        http: 'https://rpc.decentraland.org/mainnet',\n        etherscan: 'https://etherscan.io',\n        names: 'https://api.thegraph.com/subgraphs/name/decentraland/marketplace',\n        LANDProxy: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"mainnet\"].LANDProxy),\n        EstateProxy: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"mainnet\"].EstateProxy),\n        CatalystProxy: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"mainnet\"].CatalystProxy),\n        MANAToken: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"mainnet\"].MANAToken)\n    };\n    ethereumConfigurations.goerli = {\n        wss: 'wss://rpc.decentraland.org/goerli',\n        http: 'https://rpc.decentraland.org/goerli',\n        etherscan: 'https://goerli.etherscan.io',\n        names: 'https://api.thegraph.com/subgraphs/name/decentraland/marketplace-goerli',\n        LANDProxy: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"goerli\"].LANDProxy),\n        EstateProxy: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"goerli\"].EstateProxy),\n        CatalystProxy: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"goerli\"].CatalystProxy || _dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"goerli\"].Catalyst),\n        MANAToken: assertValue(_dcl_urn_resolver_dist_contracts__WEBPACK_IMPORTED_MODULE_0__[\"goerli\"].MANAToken)\n    };\n})(ethereumConfigurations || (ethereumConfigurations = {}));\nconst isRunningTest = globalThis['isRunningTests'] === true;\nconst genericAvatarSnapshots = {\n    body: 'QmSav1o6QK37Jj1yhbmhYk9MJc6c2H5DWbWzPVsg9JLYfF',\n    face256: 'QmSqZ2npVD4RLdqe17FzGCFcN29RfvmqmEd2FcQUctxaKk'\n};\nfunction getCatalystNodesDefaultURL() {\n    return `https://peer.decentraland.${getTLD()}/lambdas/contracts/servers`;\n}\nfunction addHttpsIfNoProtocolIsSet(domain) {\n    if (typeof domain === 'undefined' || domain === null)\n        return domain;\n    if (!domain.startsWith('http')) {\n        return `https://${domain}`;\n    }\n    return domain;\n}\n\n\n//# sourceURL=webpack:///./packages/config/index.ts?");

/***/ }),

/***/ "./packages/scene-system/scene.system.ts":
/*!***********************************************!*\
  !*** ./packages/scene-system/scene.system.ts ***!
  \***********************************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _sdk_disable_wasm__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sdk/disable-wasm */ \"./packages/scene-system/sdk/disable-wasm.ts\");\n/* harmony import */ var _sdk_disable_wasm__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_sdk_disable_wasm__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _dcl_rpc__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @dcl/rpc */ \"./node_modules/@dcl/rpc/dist/index.js\");\n/* harmony import */ var _dcl_rpc__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _dcl_rpc_dist_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @dcl/rpc/dist/transports/WebWorker */ \"./node_modules/@dcl/rpc/dist/transports/WebWorker.js\");\n/* harmony import */ var _dcl_rpc_dist_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _sdk_SceneRuntime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sdk/SceneRuntime */ \"./packages/scene-system/sdk/SceneRuntime.ts\");\n\n\n\n\nObject(_dcl_rpc__WEBPACK_IMPORTED_MODULE_1__[\"createRpcClient\"])(Object(_dcl_rpc_dist_transports_WebWorker__WEBPACK_IMPORTED_MODULE_2__[\"WebWorkerTransport\"])(self))\n    .then(_sdk_SceneRuntime__WEBPACK_IMPORTED_MODULE_3__[\"startSceneRuntime\"])\n    .catch((err) => console.error(err));\n\n\n//# sourceURL=webpack:///./packages/scene-system/scene.system.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/Fetch.ts":
/*!********************************************!*\
  !*** ./packages/scene-system/sdk/Fetch.ts ***!
  \********************************************/
/*! exports provided: createFetch */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createFetch\", function() { return createFetch; });\n/* harmony import */ var p_queue_dist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! p-queue/dist */ \"./node_modules/p-queue/dist/index.js\");\n\nconst TIMEOUT_LIMIT = 29000;\nfunction createFetch({ canUseFetch, previewMode, log, originalFetch }) {\n    const fifoFetch = new p_queue_dist__WEBPACK_IMPORTED_MODULE_0__[\"default\"]({ concurrency: 1 });\n    return async (resource, init) => {\n        const url = resource instanceof Request ? resource.url : resource;\n        if (url.toLowerCase().substr(0, 8) !== 'https://') {\n            if (previewMode) {\n                log(\" Warning: Can't make an unsafe http request in deployed scenes, please consider upgrading to https. url=\" +\n                    url);\n            }\n            else {\n                return Promise.reject(new Error(\"Can't make an unsafe http request, please upgrade to https. url=\" + url));\n            }\n        }\n        if (!canUseFetch) {\n            return Promise.reject(new Error('This scene is not allowed to use fetch.'));\n        }\n        async function fetchRequest() {\n            const abortController = new AbortController();\n            const timeout = setTimeout(() => {\n                abortController.abort();\n            }, Math.max((init === null || init === void 0 ? void 0 : init.timeout) || TIMEOUT_LIMIT, 1));\n            try {\n                return await originalFetch(resource, Object.assign({ signal: abortController.signal }, init));\n            }\n            finally {\n                clearTimeout(timeout);\n            }\n        }\n        return fifoFetch.add(fetchRequest);\n    };\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/Fetch.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/SceneRuntime.ts":
/*!***************************************************!*\
  !*** ./packages/scene-system/sdk/SceneRuntime.ts ***!
  \***************************************************/
/*! exports provided: startSceneRuntime */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"startSceneRuntime\", function() { return startSceneRuntime; });\n/* harmony import */ var _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../shared/apis/client */ \"./packages/shared/apis/client/index.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils */ \"./packages/scene-system/sdk/Utils.ts\");\n/* harmony import */ var _sandbox__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sandbox */ \"./packages/scene-system/sdk/sandbox.ts\");\n/* harmony import */ var shared_protocol_kernel_apis_Permissions_gen__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! shared/protocol/kernel/apis/Permissions.gen */ \"./packages/shared/protocol/kernel/apis/Permissions.gen.ts\");\n/* harmony import */ var _runtime_DecentralandInterface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./runtime/DecentralandInterface */ \"./packages/scene-system/sdk/runtime/DecentralandInterface.ts\");\n/* harmony import */ var _runtime_SetupFpsThrottling__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./runtime/SetupFpsThrottling */ \"./packages/scene-system/sdk/runtime/SetupFpsThrottling.ts\");\n/* harmony import */ var _runtime_DevToolsAdapter__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./runtime/DevToolsAdapter */ \"./packages/scene-system/sdk/runtime/DevToolsAdapter.ts\");\n/* harmony import */ var _runtime_Events__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./runtime/Events */ \"./packages/scene-system/sdk/runtime/Events.ts\");\n/* harmony import */ var atomicHelpers_parcelScenePositions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! atomicHelpers/parcelScenePositions */ \"./packages/atomicHelpers/parcelScenePositions.ts\");\n\n\n\n\n\n\n\n\n\nasync function startSceneRuntime(client) {\n    var _a, _b;\n    const workerName = self.name;\n    const clientPort = await client.createPort(`scene-${workerName}`);\n    const [EngineAPI, EnvironmentAPI, Permissions, DevTools] = await Promise.all([\n        _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__[\"LoadableAPIs\"].EngineAPI(clientPort),\n        _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__[\"LoadableAPIs\"].EnvironmentAPI(clientPort),\n        _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__[\"LoadableAPIs\"].Permissions(clientPort),\n        _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__[\"LoadableAPIs\"].DevTools(clientPort)\n    ]);\n    const [canUseWebsocket, canUseFetch] = (await Permissions.hasManyPermissions({\n        permissions: [shared_protocol_kernel_apis_Permissions_gen__WEBPACK_IMPORTED_MODULE_3__[\"PermissionItem\"].USE_WEBSOCKET, shared_protocol_kernel_apis_Permissions_gen__WEBPACK_IMPORTED_MODULE_3__[\"PermissionItem\"].USE_FETCH]\n    })).hasManyPermission;\n    const devToolsAdapter = new _runtime_DevToolsAdapter__WEBPACK_IMPORTED_MODULE_6__[\"DevToolsAdapter\"](DevTools);\n    const eventState = { allowOpenExternalUrl: false };\n    const onEventFunctions = [];\n    const onUpdateFunctions = [];\n    const onStartFunctions = [];\n    const batchEvents = {\n        events: []\n    };\n    const bootstrapData = await EnvironmentAPI.getBootstrapData({});\n    const fullData = JSON.parse(((_a = bootstrapData.entity) === null || _a === void 0 ? void 0 : _a.metadataJson) || '{}');\n    const isPreview = await EnvironmentAPI.isPreviewMode({});\n    const unsafeAllowed = await EnvironmentAPI.areUnsafeRequestAllowed({});\n    const explorerConfiguration = await EnvironmentAPI.getExplorerConfiguration({});\n    if (!fullData || !fullData.main) {\n        throw new Error(`No boostrap data`);\n    }\n    const mappingName = fullData.main;\n    const mapping = (_b = bootstrapData.entity) === null || _b === void 0 ? void 0 : _b.content.find(($) => $.file === mappingName);\n    if (!mapping) {\n        await EngineAPI.sendBatch({ actions: [Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"initMessagesFinished\"])()] });\n        throw new Error(`SDK: Error while loading scene. Main file missing.`);\n    }\n    const url = Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"resolveMapping\"])(mapping.hash, mappingName, bootstrapData.baseUrl);\n    const codeRequest = await fetch(url);\n    if (!codeRequest.ok) {\n        await EngineAPI.sendBatch({ actions: [Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"initMessagesFinished\"])()] });\n        throw new Error(`SDK: Error while loading ${url} (${mappingName} -> ${mapping === null || mapping === void 0 ? void 0 : mapping.file}:${mapping === null || mapping === void 0 ? void 0 : mapping.hash}) the mapping was not found`);\n    }\n    _Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentSerializeOpt\"].useBinaryTransform = explorerConfiguration.configurations['enableBinaryTransform'] === 'true';\n    let didStart = false;\n    let updateIntervalMs = 1000 / 30;\n    async function sendBatchAndProcessEvents() {\n        const actions = batchEvents.events;\n        if (actions.length) {\n            batchEvents.events = [];\n        }\n        const res = await EngineAPI.sendBatch({ actions });\n        for (const e of res.events) {\n            eventReceiver(Object(_runtime_Events__WEBPACK_IMPORTED_MODULE_7__[\"EventDataToRuntimeEvent\"])(e));\n        }\n    }\n    function eventReceiver(event) {\n        if (event.type === 'raycastResponse') {\n            const idAsNumber = parseInt(event.data.queryId, 10);\n            if (_Utils__WEBPACK_IMPORTED_MODULE_1__[\"numberToIdStore\"][idAsNumber]) {\n                event.data.queryId = _Utils__WEBPACK_IMPORTED_MODULE_1__[\"numberToIdStore\"][idAsNumber].toString();\n            }\n        }\n        if (!didStart && event.type === 'sceneStart') {\n            didStart = true;\n            for (const startFunctionCb of onStartFunctions) {\n                try {\n                    startFunctionCb();\n                }\n                catch (e) {\n                    devToolsAdapter.error(e);\n                }\n            }\n        }\n        if (isPointerEvent(event)) {\n            eventState.allowOpenExternalUrl = true;\n        }\n        for (const cb of onEventFunctions) {\n            try {\n                cb(event);\n            }\n            catch (err) {\n                devToolsAdapter.error(err);\n            }\n        }\n        eventState.allowOpenExternalUrl = false;\n    }\n    let start = performance.now();\n    function reschedule() {\n        const ms = Math.max((updateIntervalMs - (performance.now() - start)) | 0, 0);\n        setTimeout(mainLoop, ms);\n    }\n    function mainLoop() {\n        const now = performance.now();\n        const dtMillis = now - start;\n        start = now;\n        const dtSecs = dtMillis / 1000;\n        for (const trigger of onUpdateFunctions) {\n            try {\n                trigger(dtSecs);\n            }\n            catch (e) {\n                devToolsAdapter.error(e);\n            }\n        }\n        sendBatchAndProcessEvents().catch(devToolsAdapter.error).finally(reschedule);\n    }\n    try {\n        const sourceCode = await codeRequest.text();\n        const dcl = Object(_runtime_DecentralandInterface__WEBPACK_IMPORTED_MODULE_4__[\"createDecentralandInterface\"])({\n            clientPort,\n            onError: (err) => devToolsAdapter.error(err),\n            onLog: (...args) => devToolsAdapter.log(...args),\n            sceneId: bootstrapData.id,\n            eventState,\n            batchEvents,\n            EngineAPI,\n            onEventFunctions,\n            onStartFunctions,\n            onUpdateFunctions\n        });\n        const runtimeExecutionContext = Object(_sandbox__WEBPACK_IMPORTED_MODULE_2__[\"prepareSandboxContext\"])({\n            dcl,\n            canUseFetch,\n            canUseWebsocket,\n            log: dcl.log,\n            previewMode: isPreview.isPreview || unsafeAllowed.status\n        });\n        if (bootstrapData.useFPSThrottling === true) {\n            Object(_runtime_SetupFpsThrottling__WEBPACK_IMPORTED_MODULE_5__[\"setupFpsThrottling\"])(dcl, fullData.scene.parcels.map(atomicHelpers_parcelScenePositions__WEBPACK_IMPORTED_MODULE_8__[\"parseParcelPosition\"]), (newValue) => {\n                updateIntervalMs = newValue;\n            });\n        }\n        await Object(_sandbox__WEBPACK_IMPORTED_MODULE_2__[\"customEval\"])(sourceCode, runtimeExecutionContext);\n    }\n    catch (err) {\n        await EngineAPI.sendBatch({ actions: [Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"initMessagesFinished\"])()] });\n        devToolsAdapter.error(new Error(`SceneRuntime: Error while evaluating the scene ${workerName}`));\n        await sleep(100);\n        throw err;\n    }\n    batchEvents.events.push(Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"initMessagesFinished\"])());\n    do {\n        await sendBatchAndProcessEvents();\n    } while (!didStart && (await sleep(100)));\n    mainLoop();\n}\nfunction isPointerEvent(event) {\n    var _a, _b;\n    switch (event.type) {\n        case 'uuidEvent':\n            return ((_b = (_a = event.data) === null || _a === void 0 ? void 0 : _a.payload) === null || _b === void 0 ? void 0 : _b.buttonId) !== undefined;\n    }\n    return false;\n}\nasync function sleep(ms) {\n    await new Promise((resolve) => setTimeout(resolve, Math.max(ms | 0, 0)));\n    return true;\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/SceneRuntime.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/Utils.ts":
/*!********************************************!*\
  !*** ./packages/scene-system/sdk/Utils.ts ***!
  \********************************************/
/*! exports provided: componentSerializeOpt, generatePBObject, componentNameRE, resolveMapping, numberToIdStore, getIdAsNumber, initMessagesFinished */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"componentSerializeOpt\", function() { return componentSerializeOpt; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"generatePBObject\", function() { return generatePBObject; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"componentNameRE\", function() { return componentNameRE; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"resolveMapping\", function() { return resolveMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"numberToIdStore\", function() { return numberToIdStore; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getIdAsNumber\", function() { return getIdAsNumber; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"initMessagesFinished\", function() { return initMessagesFinished; });\n/* harmony import */ var _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/ecs-math */ \"./node_modules/@dcl/ecs-math/dist/index.js\");\n/* harmony import */ var _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/EngineAPI.gen */ \"./packages/shared/protocol/kernel/apis/EngineAPI.gen.ts\");\n/* harmony import */ var shared_protocol_renderer_protocol_EngineInterface_gen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shared/protocol/renderer-protocol/EngineInterface.gen */ \"./packages/shared/protocol/renderer-protocol/EngineInterface.gen.ts\");\n\n\n\nconst VECTOR3_MEMBER_CAP = 1000000;\nconst pbTransform = {\n    position: new _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](),\n    rotation: new _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Quaternion\"](),\n    scale: new _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"]()\n};\nconst TRANSFORM_CLASS_ID = 1;\nconst transformData = new ArrayBuffer(40);\nconst transformView = new DataView(transformData);\nconst componentSerializeOpt = {\n    useBinaryTransform: true\n};\nfunction generatePBObject(classId, json) {\n    if (classId === TRANSFORM_CLASS_ID) {\n        const transform = JSON.parse(json);\n        if (!componentSerializeOpt.useBinaryTransform)\n            return serializeTransform(transform);\n        else\n            return serializeTransformNoProtobuff(transform);\n    }\n    return json;\n}\nfunction serializeTransform(transform) {\n    pbTransform.position.set(Math.fround(transform.position.x), Math.fround(transform.position.y), Math.fround(transform.position.z));\n    capVector(pbTransform.position, VECTOR3_MEMBER_CAP);\n    pbTransform.rotation.copyFrom(transform.rotation);\n    pbTransform.scale.set(Math.fround(transform.scale.x), Math.fround(transform.scale.y), Math.fround(transform.scale.z));\n    capVector(pbTransform.scale, VECTOR3_MEMBER_CAP);\n    const arrayBuffer = shared_protocol_renderer_protocol_EngineInterface_gen__WEBPACK_IMPORTED_MODULE_2__[\"PBTransform\"].encode(pbTransform).finish();\n    return btoa(String.fromCharCode(...arrayBuffer));\n}\nfunction serializeTransformNoProtobuff(transform) {\n    const cappedVector = new _dcl_ecs_math__WEBPACK_IMPORTED_MODULE_0__[\"Vector3\"](Math.fround(transform.position.x), Math.fround(transform.position.y), Math.fround(transform.position.z));\n    capVector(cappedVector, VECTOR3_MEMBER_CAP);\n    let offset = 0;\n    transformView.setFloat32(offset, cappedVector.x, true);\n    transformView.setFloat32((offset += 4), cappedVector.y, true);\n    transformView.setFloat32((offset += 4), cappedVector.z, true);\n    transformView.setFloat32((offset += 4), transform.rotation.x, true);\n    transformView.setFloat32((offset += 4), transform.rotation.y, true);\n    transformView.setFloat32((offset += 4), transform.rotation.z, true);\n    transformView.setFloat32((offset += 4), transform.rotation.w, true);\n    cappedVector.set(Math.fround(transform.scale.x), Math.fround(transform.scale.y), Math.fround(transform.scale.z));\n    capVector(cappedVector, VECTOR3_MEMBER_CAP);\n    transformView.setFloat32((offset += 4), cappedVector.x, true);\n    transformView.setFloat32((offset += 4), cappedVector.y, true);\n    transformView.setFloat32((offset += 4), cappedVector.z, true);\n    const arrayBuffer = new Uint8Array(transformData);\n    const base64Value = btoa(String.fromCharCode(...arrayBuffer));\n    return base64Value;\n}\nfunction capVector(targetVector, cap) {\n    if (Math.abs(targetVector.x) > cap) {\n        targetVector.x = cap * Math.sign(targetVector.x);\n    }\n    if (Math.abs(targetVector.y) > cap) {\n        targetVector.y = cap * Math.sign(targetVector.y);\n    }\n    if (Math.abs(targetVector.z) > cap) {\n        targetVector.z = cap * Math.sign(targetVector.z);\n    }\n}\nconst dataUrlRE = /^data:[^/]+\\/[^;]+;base64,/;\nconst blobRE = /^blob:http/;\nconst componentNameRE = /^(engine\\.)/;\nfunction resolveMapping(mapping, mappingName, baseUrl) {\n    let url = mappingName;\n    if (mapping) {\n        url = mapping;\n    }\n    if (dataUrlRE.test(url)) {\n        return url;\n    }\n    if (blobRE.test(url)) {\n        return url;\n    }\n    return (baseUrl.endsWith('/') ? baseUrl : baseUrl + '/') + url;\n}\nconst idToNumberStore = {};\nconst numberToIdStore = {};\nlet idToNumberStoreCounter = 10;\nfunction addIdToStorage(id, idAsNumber) {\n    idToNumberStore[id] = idAsNumber;\n    numberToIdStore[idAsNumber] = id;\n}\nfunction getIdAsNumber(id) {\n    if (!idToNumberStore.hasOwnProperty(id)) {\n        idToNumberStoreCounter++;\n        addIdToStorage(id, idToNumberStoreCounter);\n        return idToNumberStoreCounter;\n    }\n    else {\n        return idToNumberStore[id];\n    }\n}\nfunction initMessagesFinished() {\n    return {\n        type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_1__[\"EAType\"].InitMessagesFinished,\n        tag: 'scene',\n        payload: { initMessagesFinished: {} }\n    };\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/Utils.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/WebSocket.ts":
/*!************************************************!*\
  !*** ./packages/scene-system/sdk/WebSocket.ts ***!
  \************************************************/
/*! exports provided: createWebSocket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createWebSocket\", function() { return createWebSocket; });\nfunction createWebSocket({ canUseWebsocket, previewMode, log }) {\n    return class RestrictedWebSocket extends WebSocket {\n        constructor(url, protocols) {\n            if (url.toString().toLowerCase().substr(0, 4) !== 'wss:') {\n                if (previewMode) {\n                    log(\" Warning: can't connect to unsafe WebSocket (ws) server in deployed scenes, consider upgrading to wss.\");\n                }\n                else {\n                    throw new Error(\"Can't connect to unsafe WebSocket server\");\n                }\n            }\n            if (!canUseWebsocket) {\n                throw new Error(\"This scene doesn't have allowed to use WebSocket\");\n            }\n            super(url.toString(), protocols);\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/WebSocket.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/disable-wasm.ts":
/*!***************************************************!*\
  !*** ./packages/scene-system/sdk/disable-wasm.ts ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\nglobalThis.WebAssembly.Instance = function () {\n    throw new Error('Wasm is not allowed in scene runtimes');\n};\nglobalThis.WebAssembly.Module = function () {\n    throw new Error('Wasm is not allowed in scene runtimes');\n};\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/disable-wasm.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/runtime/DecentralandInterface.ts":
/*!********************************************************************!*\
  !*** ./packages/scene-system/sdk/runtime/DecentralandInterface.ts ***!
  \********************************************************************/
/*! exports provided: createDecentralandInterface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createDecentralandInterface\", function() { return createDecentralandInterface; });\n/* harmony import */ var _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../shared/apis/client */ \"./packages/shared/apis/client/index.ts\");\n/* harmony import */ var _Utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../Utils */ \"./packages/scene-system/sdk/Utils.ts\");\n/* harmony import */ var shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! shared/protocol/kernel/apis/EngineAPI.gen */ \"./packages/shared/protocol/kernel/apis/EngineAPI.gen.ts\");\n\n\n\nfunction createDecentralandInterface(options) {\n    const { batchEvents, onError, onLog, sceneId, onEventFunctions, clientPort, eventState } = options;\n    const sceneLoadedModules = {};\n    const dcl = {\n        DEBUG: true,\n        log(...args) {\n            onLog(...args);\n        },\n        openExternalUrl(url) {\n            try {\n                const u = new URL(url);\n                if (u.protocol !== 'https:')\n                    throw new Error('Only https: external links are allowed');\n            }\n            catch (err) {\n                onError(err);\n                return;\n            }\n            if (JSON.stringify(url).length > 49000) {\n                onError(new Error('URL payload cannot exceed 49.000 bytes'));\n                return;\n            }\n            if (eventState.allowOpenExternalUrl) {\n                batchEvents.events.push({\n                    type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].OpenExternalUrl,\n                    tag: '',\n                    payload: { openExternalUrl: { url } }\n                });\n            }\n            else {\n                this.error('openExternalUrl can only be used inside a pointerEvent');\n            }\n        },\n        openNFTDialog(assetContractAddress, tokenId, comment) {\n            if (eventState.allowOpenExternalUrl) {\n                const payloadLength = assetContractAddress.length + tokenId.length + ((comment === null || comment === void 0 ? void 0 : comment.length) || 0);\n                if (payloadLength > 49000) {\n                    onError(new Error('OpenNFT payload cannot exceed 49.000 bytes'));\n                    return;\n                }\n                batchEvents.events.push({\n                    type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].OpenNFTDialog,\n                    tag: '',\n                    payload: { openNftDialog: { assetContractAddress, tokenId, comment: comment || '' } }\n                });\n            }\n            else {\n                this.error('openNFTDialog can only be used inside a pointerEvent');\n            }\n        },\n        addEntity(entityId) {\n            if (entityId === '0') {\n                return;\n            }\n            batchEvents.events.push({\n                type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].CreateEntity,\n                payload: { createEntity: { id: entityId } }\n            });\n        },\n        removeEntity(entityId) {\n            batchEvents.events.push({\n                type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].RemoveEntity,\n                payload: { removeEntity: { id: entityId } }\n            });\n        },\n        onUpdate(cb) {\n            if (typeof cb !== 'function') {\n                onError(new Error('onUpdate must be called with only a function argument'));\n            }\n            else {\n                options.onUpdateFunctions.push(cb);\n            }\n        },\n        onEvent(cb) {\n            if (typeof cb !== 'function') {\n                onError(new Error('onEvent must be called with only a function argument'));\n            }\n            else {\n                onEventFunctions.push(cb);\n            }\n        },\n        updateEntityComponent(entityId, componentName, classId, json) {\n            if (json.length > 49000) {\n                onError(new Error('Component payload cannot exceed 49.000 bytes'));\n                return;\n            }\n            if (_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"].test(componentName)) {\n                batchEvents.events.push({\n                    type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].UpdateEntityComponent,\n                    tag: sceneId + '_' + entityId + '_' + classId,\n                    payload: {\n                        updateEntityComponent: {\n                            entityId,\n                            classId,\n                            name: componentName.replace(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"], ''),\n                            json: Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"generatePBObject\"])(classId, json)\n                        }\n                    }\n                });\n            }\n        },\n        attachEntityComponent(entityId, componentName, id) {\n            if (_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"].test(componentName)) {\n                batchEvents.events.push({\n                    type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].AttachEntityComponent,\n                    tag: entityId,\n                    payload: {\n                        attachEntityComponent: {\n                            entityId,\n                            name: componentName.replace(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"], ''),\n                            id\n                        }\n                    }\n                });\n            }\n        },\n        removeEntityComponent(entityId, componentName) {\n            if (_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"].test(componentName)) {\n                batchEvents.events.push({\n                    type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].ComponentRemoved,\n                    tag: entityId,\n                    payload: {\n                        componentRemoved: {\n                            entityId,\n                            name: componentName.replace(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"], '')\n                        }\n                    }\n                });\n            }\n        },\n        setParent(entityId, parentId) {\n            batchEvents.events.push({\n                type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].SetEntityParent,\n                tag: entityId,\n                payload: {\n                    setEntityParent: {\n                        entityId,\n                        parentId\n                    }\n                }\n            });\n        },\n        query(queryType, payload) {\n            payload.queryId = Object(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"getIdAsNumber\"])(payload.queryId).toString();\n            batchEvents.events.push({\n                type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].Query,\n                tag: sceneId + '_' + payload.queryId,\n                payload: {\n                    query: {\n                        queryId: Object(shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"queryTypeFromJSON\"])(queryType),\n                        payload: JSON.stringify(payload)\n                    }\n                }\n            });\n        },\n        subscribe(eventName) {\n            options.EngineAPI.subscribe({ eventId: eventName }).catch((err) => onError(err));\n        },\n        unsubscribe(eventName) {\n            options.EngineAPI.unsubscribe({ eventId: eventName }).catch((err) => onError(err));\n        },\n        componentCreated(id, componentName, classId) {\n            if (_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"].test(componentName)) {\n                batchEvents.events.push({\n                    type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].ComponentCreated,\n                    tag: id,\n                    payload: {\n                        componentCreated: {\n                            id,\n                            classId,\n                            name: componentName.replace(_Utils__WEBPACK_IMPORTED_MODULE_1__[\"componentNameRE\"], '')\n                        }\n                    }\n                });\n            }\n        },\n        componentDisposed(id) {\n            batchEvents.events.push({\n                type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].ComponentDisposed,\n                tag: id,\n                payload: {\n                    componentDisposed: { id }\n                }\n            });\n        },\n        componentUpdated(id, json) {\n            batchEvents.events.push({\n                type: shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_2__[\"EAType\"].ComponentUpdated,\n                tag: id,\n                payload: {\n                    componentUpdated: {\n                        id,\n                        json\n                    }\n                }\n            });\n        },\n        loadModule: async (_moduleName) => {\n            if (!(_moduleName in sceneLoadedModules)) {\n                const loadedModule = loadSceneModule(clientPort, _moduleName);\n                sceneLoadedModules[_moduleName] = {\n                    rpcHandle: _moduleName,\n                    __INTERNAL_UNSAFE_loadedModule: loadedModule,\n                    methods: Object.keys(loadedModule).map((name) => ({ name }))\n                };\n            }\n            return sceneLoadedModules[_moduleName];\n        },\n        callRpc: async (rpcHandle, methodName, args) => {\n            const module = sceneLoadedModules[rpcHandle];\n            if (!module) {\n                throw new Error(`RPCHandle: ${rpcHandle} is not loaded`);\n            }\n            return module.__INTERNAL_UNSAFE_loadedModule[methodName].apply(module, args);\n        },\n        onStart(cb) {\n            options.onStartFunctions.push(cb);\n        },\n        error(message, data) {\n            onError(Object.assign(new Error(message), { data }));\n        }\n    };\n    return dcl;\n}\nfunction loadSceneModule(clientPort, moduleName) {\n    const moduleToLoad = moduleName.replace(/^@decentraland\\//, 'Legacy').replace(/^~system\\//, '');\n    try {\n        if (moduleToLoad in _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__[\"LoadableAPIs\"]) {\n            return _shared_apis_client__WEBPACK_IMPORTED_MODULE_0__[\"LoadableAPIs\"][moduleToLoad](clientPort);\n        }\n        else {\n            throw new Error('The module is not available in the list!');\n        }\n    }\n    catch (e) {\n        throw Object.assign(new Error(`Error getting the methods of ${moduleToLoad}: ` + e.message), {\n            original: e\n        });\n    }\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/runtime/DecentralandInterface.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/runtime/DevToolsAdapter.ts":
/*!**************************************************************!*\
  !*** ./packages/scene-system/sdk/runtime/DevToolsAdapter.ts ***!
  \**************************************************************/
/*! exports provided: DevToolsAdapter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DevToolsAdapter\", function() { return DevToolsAdapter; });\nclass DevToolsAdapter {\n    constructor(devTools) {\n        this.devTools = devTools;\n        this.exceptions = [];\n        this.catchHandler = (...args) => console.log(...args);\n    }\n    log(...args) {\n        const params = {\n            type: 'log',\n            timestamp: performance.now(),\n            executionContextId: 0,\n            args: args.map(($) => {\n                let value = undefined;\n                let unserializableValue = undefined;\n                const type = typeof $;\n                if (type === 'object' && $ !== null) {\n                    try {\n                        JSON.stringify($);\n                        value = $;\n                    }\n                    catch (error) {\n                        unserializableValue = Object.prototype.toString.apply($);\n                    }\n                }\n                else if (type === 'number' && (isNaN($) || !isFinite($))) {\n                    unserializableValue = Object.prototype.toString.apply($);\n                }\n                else {\n                    value = $;\n                }\n                const remoteObject = {\n                    type: typeof $,\n                    value,\n                    unserializableValue\n                };\n                return remoteObject;\n            })\n        };\n        this.devTools.event({\n            type: 'Runtime.consoleAPICalled',\n            jsonPayload: JSON.stringify([params])\n        }).catch(this.catchHandler);\n    }\n    error(e) {\n        const exceptionId = this.exceptions.push(e) - 1;\n        let value = undefined;\n        let unserializableValue = undefined;\n        try {\n            value = JSON.stringify(e);\n            if (value === '{}' && e instanceof Error) {\n                value = JSON.stringify({\n                    message: e.message,\n                    name: e.name,\n                    stack: e.stack\n                });\n            }\n        }\n        catch (error) {\n            unserializableValue = e.toString();\n        }\n        const exception = {\n            type: typeof e,\n            value,\n            unserializableValue\n        };\n        const param = {\n            timestamp: performance.now(),\n            exceptionDetails: {\n                text: e.toString() + '\\n' + e.stack,\n                exceptionId,\n                columnNumber: 0,\n                lineNumber: 0,\n                exception\n            }\n        };\n        this.devTools.event({\n            type: 'Runtime.exceptionThrown',\n            jsonPayload: JSON.stringify([param])\n        }).catch(this.catchHandler);\n    }\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/runtime/DevToolsAdapter.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/runtime/Events.ts":
/*!*****************************************************!*\
  !*** ./packages/scene-system/sdk/runtime/Events.ts ***!
  \*****************************************************/
/*! exports provided: EventDataToRuntimeEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDataToRuntimeEvent\", function() { return EventDataToRuntimeEvent; });\n/* harmony import */ var shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! shared/protocol/kernel/apis/EngineAPI.gen */ \"./packages/shared/protocol/kernel/apis/EngineAPI.gen.ts\");\n\nfunction EventDataToRuntimeEvent(e) {\n    var _a;\n    switch (e.type) {\n        case shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_0__[\"EventDataType\"].Generic:\n            return { type: ((_a = e.generic) === null || _a === void 0 ? void 0 : _a.eventId) || '', data: JSON.parse(e.generic.eventData || '{}') };\n        case shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_0__[\"EventDataType\"].PositionChanged:\n            return { type: 'positionChanged', data: e.positionChanged };\n        case shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_0__[\"EventDataType\"].RotationChanged:\n            return { type: 'rotationChanged', data: e.rotationChanged };\n    }\n    return { type: '', data: '{}' };\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/runtime/Events.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/runtime/SetupFpsThrottling.ts":
/*!*****************************************************************!*\
  !*** ./packages/scene-system/sdk/runtime/SetupFpsThrottling.ts ***!
  \*****************************************************************/
/*! exports provided: setupFpsThrottling */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setupFpsThrottling\", function() { return setupFpsThrottling; });\n/* harmony import */ var _dcl_legacy_ecs_dist_decentraland_Math__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/legacy-ecs/dist/decentraland/Math */ \"./node_modules/@dcl/legacy-ecs/dist/decentraland/Math.js\");\n\nfunction setupFpsThrottling(dcl, parcels, onChangeUpdateInterval) {\n    dcl.subscribe('positionChanged');\n    dcl.onEvent((event) => {\n        if (event.type !== 'positionChanged') {\n            return;\n        }\n        const e = event.data;\n        const PARCEL_SIZE = 16;\n        const playerPosition = new _dcl_legacy_ecs_dist_decentraland_Math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"](Math.floor(e.cameraPosition.x / PARCEL_SIZE), Math.floor(e.cameraPosition.z / PARCEL_SIZE));\n        if (playerPosition === undefined) {\n            return;\n        }\n        const playerPos = playerPosition;\n        let sqrDistanceToPlayerInParcels = 10 * 10;\n        let isInsideScene = false;\n        for (const parcel of parcels) {\n            sqrDistanceToPlayerInParcels = Math.min(sqrDistanceToPlayerInParcels, _dcl_legacy_ecs_dist_decentraland_Math__WEBPACK_IMPORTED_MODULE_0__[\"Vector2\"].DistanceSquared(playerPos, parcel));\n            if (parcel.x === playerPos.x && parcel.y === playerPos.y) {\n                isInsideScene = true;\n            }\n        }\n        let fps = 1;\n        if (isInsideScene) {\n            fps = 30;\n        }\n        else if (sqrDistanceToPlayerInParcels <= 2 * 2) {\n            fps = 20;\n        }\n        else if (sqrDistanceToPlayerInParcels <= 3 * 3) {\n            fps = 10;\n        }\n        else if (sqrDistanceToPlayerInParcels <= 4 * 4) {\n            fps = 5;\n        }\n        onChangeUpdateInterval(1000 / fps);\n    });\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/runtime/SetupFpsThrottling.ts?");

/***/ }),

/***/ "./packages/scene-system/sdk/sandbox.ts":
/*!**********************************************!*\
  !*** ./packages/scene-system/sdk/sandbox.ts ***!
  \**********************************************/
/*! exports provided: customEval, prepareSandboxContext */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"customEval\", function() { return customEval; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"prepareSandboxContext\", function() { return prepareSandboxContext; });\n/* harmony import */ var _Fetch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Fetch */ \"./packages/scene-system/sdk/Fetch.ts\");\n/* harmony import */ var _WebSocket__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./WebSocket */ \"./packages/scene-system/sdk/WebSocket.ts\");\n\n\nconst allowListES5 = [\n    'eval',\n    'parseInt',\n    'parseFloat',\n    'isNaN',\n    'isFinite',\n    'decodeURI',\n    'decodeURIComponent',\n    'encodeURI',\n    'encodeURIComponent',\n    'escape',\n    'unescape',\n    'Object',\n    'Function',\n    'String',\n    'Boolean',\n    'Number',\n    'Math',\n    'Date',\n    'RegExp',\n    'Error',\n    'EvalError',\n    'RangeError',\n    'ReferenceError',\n    'SyntaxError',\n    'TypeError',\n    'URIError',\n    'JSON',\n    'Array',\n    'Promise',\n    'NaN',\n    'Infinity'\n];\nconst defer = Promise.resolve().then.bind(Promise.resolve());\nasync function customEval(code, context) {\n    const sandbox = {};\n    const resultKey = 'SAFE_EVAL_' + Math.floor(Math.random() * 1000000);\n    sandbox[resultKey] = {};\n    Object.keys(context).forEach(function (key) {\n        sandbox[key] = context[key];\n    });\n    sandbox.window = sandbox;\n    sandbox.self = sandbox;\n    return defer(() => new Function('code', `with (this) { ${code} }`).call(sandbox, code));\n}\nfunction getES5Context(base) {\n    allowListES5.forEach(($) => (base[$] = globalThis[$]));\n    return base;\n}\nfunction prepareSandboxContext(options) {\n    const originalFetch = globalThis.fetch;\n    const restrictedWebSocket = Object(_WebSocket__WEBPACK_IMPORTED_MODULE_1__[\"createWebSocket\"])(options);\n    const restrictedFetch = Object(_Fetch__WEBPACK_IMPORTED_MODULE_0__[\"createFetch\"])(Object.assign(Object.assign({}, options), { originalFetch }));\n    globalThis.fetch = restrictedFetch;\n    globalThis.WebSocket = restrictedWebSocket;\n    const env = { dcl: options.dcl, WebSocket: restrictedWebSocket, fetch: restrictedFetch };\n    return getES5Context(env);\n}\n\n\n//# sourceURL=webpack:///./packages/scene-system/sdk/sandbox.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/CommunicationsController.ts":
/*!*****************************************************************!*\
  !*** ./packages/shared/apis/client/CommunicationsController.ts ***!
  \*****************************************************************/
/*! exports provided: CommunicationsControllerServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommunicationsControllerServiceClient\", function() { return CommunicationsControllerServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_CommunicationsController_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/CommunicationsController.gen */ \"./packages/shared/protocol/kernel/apis/CommunicationsController.gen.ts\");\n\n\nvar CommunicationsControllerServiceClient;\n(function (CommunicationsControllerServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_CommunicationsController_gen__WEBPACK_IMPORTED_MODULE_1__[\"CommunicationsControllerServiceDefinition\"]);\n    }\n    CommunicationsControllerServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_CommunicationsController_gen__WEBPACK_IMPORTED_MODULE_1__[\"CommunicationsControllerServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async send(message) {\n                await originalService.send({ message });\n            } });\n    }\n    CommunicationsControllerServiceClient.createLegacy = createLegacy;\n})(CommunicationsControllerServiceClient || (CommunicationsControllerServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/CommunicationsController.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/DevTools.ts":
/*!*************************************************!*\
  !*** ./packages/shared/apis/client/DevTools.ts ***!
  \*************************************************/
/*! exports provided: createDevToolsServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createDevToolsServiceClient\", function() { return createDevToolsServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_DevTools_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/DevTools.gen */ \"./packages/shared/protocol/kernel/apis/DevTools.gen.ts\");\n\n\nfunction createDevToolsServiceClient(clientPort) {\n    const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_DevTools_gen__WEBPACK_IMPORTED_MODULE_1__[\"DevToolsServiceDefinition\"]);\n    return originalService;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/DevTools.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/EngineAPI.ts":
/*!**************************************************!*\
  !*** ./packages/shared/apis/client/EngineAPI.ts ***!
  \**************************************************/
/*! exports provided: createEngineAPIServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createEngineAPIServiceClient\", function() { return createEngineAPIServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/EngineAPI.gen */ \"./packages/shared/protocol/kernel/apis/EngineAPI.gen.ts\");\n\n\nfunction createEngineAPIServiceClient(clientPort) {\n    const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_EngineAPI_gen__WEBPACK_IMPORTED_MODULE_1__[\"EngineAPIServiceDefinition\"]);\n    return originalService;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/EngineAPI.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/EnvironmentAPI.ts":
/*!*******************************************************!*\
  !*** ./packages/shared/apis/client/EnvironmentAPI.ts ***!
  \*******************************************************/
/*! exports provided: EnvironmentAPIServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EnvironmentAPIServiceClient\", function() { return EnvironmentAPIServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_EnvironmentAPI_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/EnvironmentAPI.gen */ \"./packages/shared/protocol/kernel/apis/EnvironmentAPI.gen.ts\");\n\n\nvar EnvironmentAPIServiceClient;\n(function (EnvironmentAPIServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_EnvironmentAPI_gen__WEBPACK_IMPORTED_MODULE_1__[\"EnvironmentAPIServiceDefinition\"]);\n    }\n    EnvironmentAPIServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_EnvironmentAPI_gen__WEBPACK_IMPORTED_MODULE_1__[\"EnvironmentAPIServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async getBootstrapData() {\n                var _a, _b, _c;\n                const res = await originalService.getBootstrapData({});\n                const sceneMetadata = JSON.parse(((_a = res.entity) === null || _a === void 0 ? void 0 : _a.metadataJson) || '{}');\n                return {\n                    sceneId: res.id,\n                    name: ((_b = sceneMetadata.display) === null || _b === void 0 ? void 0 : _b.title) || 'Unnamed',\n                    main: sceneMetadata.main,\n                    baseUrl: res.baseUrl,\n                    mappings: ((_c = res.entity) === null || _c === void 0 ? void 0 : _c.content) || [],\n                    useFPSThrottling: res.useFPSThrottling,\n                    data: sceneMetadata\n                };\n            },\n            async areUnsafeRequestAllowed() {\n                return (await originalService.areUnsafeRequestAllowed({})).status;\n            },\n            async getCurrentRealm() {\n                const res = await originalService.getCurrentRealm({});\n                return res.currentRealm;\n            },\n            async isPreviewMode() {\n                const res = await originalService.isPreviewMode({});\n                return res.isPreview;\n            },\n            async getExplorerConfiguration() {\n                return await originalService.getExplorerConfiguration({});\n            },\n            async getPlatform() {\n                return (await originalService.getPlatform({})).platform;\n            },\n            async getDecentralandTime() {\n                return await originalService.getDecentralandTime({});\n            } });\n    }\n    EnvironmentAPIServiceClient.createLegacy = createLegacy;\n})(EnvironmentAPIServiceClient || (EnvironmentAPIServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/EnvironmentAPI.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/EthereumController.ts":
/*!***********************************************************!*\
  !*** ./packages/shared/apis/client/EthereumController.ts ***!
  \***********************************************************/
/*! exports provided: EthereumControllerServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EthereumControllerServiceClient\", function() { return EthereumControllerServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_EthereumController_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/EthereumController.gen */ \"./packages/shared/protocol/kernel/apis/EthereumController.gen.ts\");\n\n\nvar EthereumControllerServiceClient;\n(function (EthereumControllerServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_EthereumController_gen__WEBPACK_IMPORTED_MODULE_1__[\"EthereumControllerServiceDefinition\"]);\n    }\n    EthereumControllerServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_EthereumController_gen__WEBPACK_IMPORTED_MODULE_1__[\"EthereumControllerServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async requirePayment(toAddress, amount, currency) {\n                const response = await originalService.requirePayment({ toAddress, amount, currency });\n                return JSON.parse(response.jsonAnyResponse);\n            },\n            async signMessage(message) {\n                return await originalService.signMessage({ message });\n            },\n            async convertMessageToObject(message) {\n                return (await originalService.convertMessageToObject({ message })).dict;\n            },\n            async sendAsync(message) {\n                return JSON.parse((await originalService.sendAsync({\n                    id: message.id,\n                    method: message.method,\n                    jsonParams: JSON.stringify(message.params)\n                })).jsonAnyResponse);\n            },\n            async getUserAccount() {\n                return (await originalService.getUserAccount({})).address;\n            } });\n    }\n    EthereumControllerServiceClient.createLegacy = createLegacy;\n})(EthereumControllerServiceClient || (EthereumControllerServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/EthereumController.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/ExperimentalAPI.ts":
/*!********************************************************!*\
  !*** ./packages/shared/apis/client/ExperimentalAPI.ts ***!
  \********************************************************/
/*! exports provided: createExperimentalAPIServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createExperimentalAPIServiceClient\", function() { return createExperimentalAPIServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_ExperimentalAPI_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/ExperimentalAPI.gen */ \"./packages/shared/protocol/kernel/apis/ExperimentalAPI.gen.ts\");\n\n\nfunction createExperimentalAPIServiceClient(clientPort) {\n    return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_ExperimentalAPI_gen__WEBPACK_IMPORTED_MODULE_1__[\"ExperimentalAPIServiceDefinition\"]);\n}\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/ExperimentalAPI.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/ParcelIdentity.ts":
/*!*******************************************************!*\
  !*** ./packages/shared/apis/client/ParcelIdentity.ts ***!
  \*******************************************************/
/*! exports provided: ParcelIdentityServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParcelIdentityServiceClient\", function() { return ParcelIdentityServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_ParcelIdentity_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/ParcelIdentity.gen */ \"./packages/shared/protocol/kernel/apis/ParcelIdentity.gen.ts\");\n\n\nvar ParcelIdentityServiceClient;\n(function (ParcelIdentityServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_ParcelIdentity_gen__WEBPACK_IMPORTED_MODULE_1__[\"ParcelIdentityServiceDefinition\"]);\n    }\n    ParcelIdentityServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_ParcelIdentity_gen__WEBPACK_IMPORTED_MODULE_1__[\"ParcelIdentityServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async getParcel() {\n                var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n                const data = await originalService.getParcel({});\n                return {\n                    land: {\n                        sceneId: ((_a = data.land) === null || _a === void 0 ? void 0 : _a.sceneId) || '',\n                        sceneJsonData: JSON.parse(((_b = data.land) === null || _b === void 0 ? void 0 : _b.sceneJsonData) || '{}'),\n                        baseUrl: ((_c = data.land) === null || _c === void 0 ? void 0 : _c.baseUrl) || '',\n                        baseUrlBundles: ((_d = data.land) === null || _d === void 0 ? void 0 : _d.baseUrlBundles) || '',\n                        mappingsResponse: {\n                            root_cid: ((_f = (_e = data.land) === null || _e === void 0 ? void 0 : _e.mappingsResponse) === null || _f === void 0 ? void 0 : _f.rootCid) || '',\n                            parcel_id: ((_h = (_g = data.land) === null || _g === void 0 ? void 0 : _g.mappingsResponse) === null || _h === void 0 ? void 0 : _h.parcelId) || '',\n                            contents: ((_k = (_j = data.land) === null || _j === void 0 ? void 0 : _j.mappingsResponse) === null || _k === void 0 ? void 0 : _k.contents) || []\n                        }\n                    },\n                    cid: data.cid\n                };\n            },\n            async getSceneId() {\n                const data = await originalService.getSceneId({});\n                return data.sceneId;\n            } });\n    }\n    ParcelIdentityServiceClient.createLegacy = createLegacy;\n})(ParcelIdentityServiceClient || (ParcelIdentityServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/ParcelIdentity.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/Permissions.ts":
/*!****************************************************!*\
  !*** ./packages/shared/apis/client/Permissions.ts ***!
  \****************************************************/
/*! exports provided: createPermissionsServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createPermissionsServiceClient\", function() { return createPermissionsServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_Permissions_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/Permissions.gen */ \"./packages/shared/protocol/kernel/apis/Permissions.gen.ts\");\n\n\nfunction createPermissionsServiceClient(clientPort) {\n    return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_Permissions_gen__WEBPACK_IMPORTED_MODULE_1__[\"PermissionsServiceDefinition\"]);\n}\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/Permissions.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/Players.ts":
/*!************************************************!*\
  !*** ./packages/shared/apis/client/Players.ts ***!
  \************************************************/
/*! exports provided: PlayersServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlayersServiceClient\", function() { return PlayersServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_Players_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/Players.gen */ \"./packages/shared/protocol/kernel/apis/Players.gen.ts\");\n\n\nvar PlayersServiceClient;\n(function (PlayersServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_Players_gen__WEBPACK_IMPORTED_MODULE_1__[\"PlayersServiceDefinition\"]);\n    }\n    PlayersServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_Players_gen__WEBPACK_IMPORTED_MODULE_1__[\"PlayersServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async getPlayerData(opt) {\n                const originalResponse = await originalService.getPlayerData({ userId: opt.userId });\n                if (!originalResponse.data) {\n                    return null;\n                }\n                return Object.assign(Object.assign({}, originalResponse.data), { avatar: Object.assign(Object.assign({}, originalResponse.data.avatar), { snapshots: originalResponse.data.avatar.snapshots }), publicKey: originalResponse.data.publicKey || null });\n            },\n            async getConnectedPlayers() {\n                return (await originalService.getConnectedPlayers({})).players;\n            },\n            async getPlayersInScene() {\n                return (await originalService.getPlayersInScene({})).players;\n            } });\n    }\n    PlayersServiceClient.createLegacy = createLegacy;\n})(PlayersServiceClient || (PlayersServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/Players.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/PortableExperiences.ts":
/*!************************************************************!*\
  !*** ./packages/shared/apis/client/PortableExperiences.ts ***!
  \************************************************************/
/*! exports provided: PortableExperienceServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PortableExperienceServiceClient\", function() { return PortableExperienceServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_PortableExperiences_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/PortableExperiences.gen */ \"./packages/shared/protocol/kernel/apis/PortableExperiences.gen.ts\");\n\n\nvar PortableExperienceServiceClient;\n(function (PortableExperienceServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_PortableExperiences_gen__WEBPACK_IMPORTED_MODULE_1__[\"PortableExperiencesServiceDefinition\"]);\n    }\n    PortableExperienceServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_PortableExperiences_gen__WEBPACK_IMPORTED_MODULE_1__[\"PortableExperiencesServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async spawn(pid) {\n                return await originalService.spawn({ pid });\n            },\n            async kill(pid) {\n                return (await originalService.kill({ pid })).status;\n            },\n            async exit() {\n                return (await originalService.exit({})).status;\n            },\n            async getPortableExperiencesLoaded() {\n                return {\n                    portableExperiences: (await originalService.getPortableExperiencesLoaded({})).loaded\n                };\n            } });\n    }\n    PortableExperienceServiceClient.createLegacy = createLegacy;\n})(PortableExperienceServiceClient || (PortableExperienceServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/PortableExperiences.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/RestrictedActions.ts":
/*!**********************************************************!*\
  !*** ./packages/shared/apis/client/RestrictedActions.ts ***!
  \**********************************************************/
/*! exports provided: RestrictedActionsServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RestrictedActionsServiceClient\", function() { return RestrictedActionsServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_RestrictedActions_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/RestrictedActions.gen */ \"./packages/shared/protocol/kernel/apis/RestrictedActions.gen.ts\");\n\n\nvar RestrictedActionsServiceClient;\n(function (RestrictedActionsServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_RestrictedActions_gen__WEBPACK_IMPORTED_MODULE_1__[\"RestrictedActionsServiceDefinition\"]);\n    }\n    RestrictedActionsServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_RestrictedActions_gen__WEBPACK_IMPORTED_MODULE_1__[\"RestrictedActionsServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async movePlayerTo(newPosition, cameraTarget) {\n                await originalService.movePlayerTo({\n                    newRelativePosition: newPosition,\n                    cameraTarget: cameraTarget || undefined\n                });\n            },\n            async triggerEmote(emote) {\n                await originalService.triggerEmote({ predefinedEmote: emote.predefined });\n            } });\n    }\n    RestrictedActionsServiceClient.createLegacy = createLegacy;\n})(RestrictedActionsServiceClient || (RestrictedActionsServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/RestrictedActions.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/SignedFetch.ts":
/*!****************************************************!*\
  !*** ./packages/shared/apis/client/SignedFetch.ts ***!
  \****************************************************/
/*! exports provided: SignedFetchServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignedFetchServiceClient\", function() { return SignedFetchServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_SignedFetch_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/SignedFetch.gen */ \"./packages/shared/protocol/kernel/apis/SignedFetch.gen.ts\");\n\n\nvar SignedFetchServiceClient;\n(function (SignedFetchServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_SignedFetch_gen__WEBPACK_IMPORTED_MODULE_1__[\"SignedFetchServiceDefinition\"]);\n    }\n    SignedFetchServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_SignedFetch_gen__WEBPACK_IMPORTED_MODULE_1__[\"SignedFetchServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async signedFetch(url, originalInit) {\n                let init = undefined;\n                if (originalInit) {\n                    init = { headers: {} };\n                    if (originalInit.headers && typeof originalInit.headers === 'object') {\n                        init.headers = originalInit.headers;\n                    }\n                    if (originalInit.body && typeof originalInit.body === 'string') {\n                        init.body = originalInit.body;\n                    }\n                    if (originalInit.method && typeof originalInit.method === 'string') {\n                        init.method = originalInit.method;\n                    }\n                }\n                const responseBodyType = (originalInit === null || originalInit === void 0 ? void 0 : originalInit.responseBodyType) || 'text';\n                const result = await originalService.signedFetch({ url, init });\n                return {\n                    ok: result.ok,\n                    status: result.status,\n                    statusText: result.statusText,\n                    headers: result.headers,\n                    json: responseBodyType === 'json' ? JSON.parse(result.body) : undefined,\n                    text: responseBodyType === 'text' ? result.body : undefined\n                };\n            } });\n    }\n    SignedFetchServiceClient.createLegacy = createLegacy;\n})(SignedFetchServiceClient || (SignedFetchServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/SignedFetch.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/SocialController.ts":
/*!*********************************************************!*\
  !*** ./packages/shared/apis/client/SocialController.ts ***!
  \*********************************************************/
/*! exports provided: createSocialControllerServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createSocialControllerServiceClient\", function() { return createSocialControllerServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_SocialController_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/SocialController.gen */ \"./packages/shared/protocol/kernel/apis/SocialController.gen.ts\");\n\n\nfunction createSocialControllerServiceClient(clientPort) {\n    const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_SocialController_gen__WEBPACK_IMPORTED_MODULE_1__[\"SocialControllerServiceDefinition\"]);\n    return originalService;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/SocialController.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/UserActionModule.ts":
/*!*********************************************************!*\
  !*** ./packages/shared/apis/client/UserActionModule.ts ***!
  \*********************************************************/
/*! exports provided: UserActionModuleServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserActionModuleServiceClient\", function() { return UserActionModuleServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_UserActionModule_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/UserActionModule.gen */ \"./packages/shared/protocol/kernel/apis/UserActionModule.gen.ts\");\n\n\nvar UserActionModuleServiceClient;\n(function (UserActionModuleServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_UserActionModule_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserActionModuleServiceDefinition\"]);\n    }\n    UserActionModuleServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_UserActionModule_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserActionModuleServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async requestTeleport(destination) {\n                await originalService.requestTeleport({ destination });\n            } });\n    }\n    UserActionModuleServiceClient.createLegacy = createLegacy;\n})(UserActionModuleServiceClient || (UserActionModuleServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/UserActionModule.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/UserIdentity.ts":
/*!*****************************************************!*\
  !*** ./packages/shared/apis/client/UserIdentity.ts ***!
  \*****************************************************/
/*! exports provided: UserIdentityServiceClient */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserIdentityServiceClient\", function() { return UserIdentityServiceClient; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_UserIdentity_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/UserIdentity.gen */ \"./packages/shared/protocol/kernel/apis/UserIdentity.gen.ts\");\n\n\nvar UserIdentityServiceClient;\n(function (UserIdentityServiceClient) {\n    function create(clientPort) {\n        return _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_UserIdentity_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserIdentityServiceDefinition\"]);\n    }\n    UserIdentityServiceClient.create = create;\n    function createLegacy(clientPort) {\n        const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_UserIdentity_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserIdentityServiceDefinition\"]);\n        return Object.assign(Object.assign({}, originalService), { async getUserPublicKey() {\n                const realResponse = await originalService.getUserPublicKey({});\n                return realResponse.address || null;\n            },\n            async getUserData() {\n                const realResponse = await originalService.getUserData({});\n                if (!realResponse.data) {\n                    return null;\n                }\n                return Object.assign(Object.assign({}, realResponse.data), { avatar: Object.assign(Object.assign({}, realResponse.data.avatar), { snapshots: realResponse.data.avatar.snapshots }), publicKey: realResponse.data.publicKey || null });\n            } });\n    }\n    UserIdentityServiceClient.createLegacy = createLegacy;\n})(UserIdentityServiceClient || (UserIdentityServiceClient = {}));\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/UserIdentity.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/Web3Provider.ts":
/*!*****************************************************!*\
  !*** ./packages/shared/apis/client/Web3Provider.ts ***!
  \*****************************************************/
/*! exports provided: createLegacyWeb3Provider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"createLegacyWeb3Provider\", function() { return createLegacyWeb3Provider; });\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @dcl/rpc/dist/codegen */ \"./node_modules/@dcl/rpc/dist/codegen.js\");\n/* harmony import */ var _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var shared_protocol_kernel_apis_EthereumController_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! shared/protocol/kernel/apis/EthereumController.gen */ \"./packages/shared/protocol/kernel/apis/EthereumController.gen.ts\");\n\n\nfunction createLegacyWeb3Provider(clientPort) {\n    const originalService = _dcl_rpc_dist_codegen__WEBPACK_IMPORTED_MODULE_0__[\"loadService\"](clientPort, shared_protocol_kernel_apis_EthereumController_gen__WEBPACK_IMPORTED_MODULE_1__[\"EthereumControllerServiceDefinition\"]);\n    async function request(message) {\n        const response = await originalService.sendAsync({\n            id: message.id,\n            method: message.method,\n            jsonParams: JSON.stringify(message.params)\n        });\n        return JSON.parse(response.jsonAnyResponse);\n    }\n    return {\n        async getProvider() {\n            return {\n                send(message, callback) {\n                    if (message && callback && callback instanceof Function) {\n                        request(message)\n                            .then((x) => callback(null, x))\n                            .catch(callback);\n                    }\n                    else {\n                        throw new Error('Decentraland provider only allows async calls');\n                    }\n                },\n                sendAsync(message, callback) {\n                    request(message)\n                        .then((x) => callback(null, x))\n                        .catch(callback);\n                }\n            };\n        }\n    };\n}\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/Web3Provider.ts?");

/***/ }),

/***/ "./packages/shared/apis/client/index.ts":
/*!**********************************************!*\
  !*** ./packages/shared/apis/client/index.ts ***!
  \**********************************************/
/*! exports provided: LoadableAPIs */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"LoadableAPIs\", function() { return LoadableAPIs; });\n/* harmony import */ var _CommunicationsController__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./CommunicationsController */ \"./packages/shared/apis/client/CommunicationsController.ts\");\n/* harmony import */ var _DevTools__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DevTools */ \"./packages/shared/apis/client/DevTools.ts\");\n/* harmony import */ var _EngineAPI__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./EngineAPI */ \"./packages/shared/apis/client/EngineAPI.ts\");\n/* harmony import */ var _EnvironmentAPI__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EnvironmentAPI */ \"./packages/shared/apis/client/EnvironmentAPI.ts\");\n/* harmony import */ var _EthereumController__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./EthereumController */ \"./packages/shared/apis/client/EthereumController.ts\");\n/* harmony import */ var _ExperimentalAPI__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./ExperimentalAPI */ \"./packages/shared/apis/client/ExperimentalAPI.ts\");\n/* harmony import */ var _ParcelIdentity__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ParcelIdentity */ \"./packages/shared/apis/client/ParcelIdentity.ts\");\n/* harmony import */ var _Permissions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./Permissions */ \"./packages/shared/apis/client/Permissions.ts\");\n/* harmony import */ var _Players__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./Players */ \"./packages/shared/apis/client/Players.ts\");\n/* harmony import */ var _PortableExperiences__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./PortableExperiences */ \"./packages/shared/apis/client/PortableExperiences.ts\");\n/* harmony import */ var _RestrictedActions__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./RestrictedActions */ \"./packages/shared/apis/client/RestrictedActions.ts\");\n/* harmony import */ var _SignedFetch__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./SignedFetch */ \"./packages/shared/apis/client/SignedFetch.ts\");\n/* harmony import */ var _SocialController__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./SocialController */ \"./packages/shared/apis/client/SocialController.ts\");\n/* harmony import */ var _UserActionModule__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./UserActionModule */ \"./packages/shared/apis/client/UserActionModule.ts\");\n/* harmony import */ var _UserIdentity__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./UserIdentity */ \"./packages/shared/apis/client/UserIdentity.ts\");\n/* harmony import */ var _Web3Provider__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./Web3Provider */ \"./packages/shared/apis/client/Web3Provider.ts\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst LoadableAPIs = {\n    DevTools: _DevTools__WEBPACK_IMPORTED_MODULE_1__[\"createDevToolsServiceClient\"],\n    EngineAPI: _EngineAPI__WEBPACK_IMPORTED_MODULE_2__[\"createEngineAPIServiceClient\"],\n    ExperimentalAPI: _ExperimentalAPI__WEBPACK_IMPORTED_MODULE_5__[\"createExperimentalAPIServiceClient\"],\n    Permissions: _Permissions__WEBPACK_IMPORTED_MODULE_7__[\"createPermissionsServiceClient\"],\n    SignedFetch: _SignedFetch__WEBPACK_IMPORTED_MODULE_11__[\"SignedFetchServiceClient\"].create,\n    CommunicationsController: _CommunicationsController__WEBPACK_IMPORTED_MODULE_0__[\"CommunicationsControllerServiceClient\"].create,\n    EnvironmentAPI: _EnvironmentAPI__WEBPACK_IMPORTED_MODULE_3__[\"EnvironmentAPIServiceClient\"].create,\n    EthereumController: _EthereumController__WEBPACK_IMPORTED_MODULE_4__[\"EthereumControllerServiceClient\"].create,\n    ParcelIdentity: _ParcelIdentity__WEBPACK_IMPORTED_MODULE_6__[\"ParcelIdentityServiceClient\"].create,\n    Players: _Players__WEBPACK_IMPORTED_MODULE_8__[\"PlayersServiceClient\"].create,\n    PortableExperience: _PortableExperiences__WEBPACK_IMPORTED_MODULE_9__[\"PortableExperienceServiceClient\"].create,\n    RestrictedActions: _RestrictedActions__WEBPACK_IMPORTED_MODULE_10__[\"RestrictedActionsServiceClient\"].create,\n    UserActionModule: _UserActionModule__WEBPACK_IMPORTED_MODULE_13__[\"UserActionModuleServiceClient\"].create,\n    UserIdentity: _UserIdentity__WEBPACK_IMPORTED_MODULE_14__[\"UserIdentityServiceClient\"].create,\n    LegacySignedFetch: _SignedFetch__WEBPACK_IMPORTED_MODULE_11__[\"SignedFetchServiceClient\"].createLegacy,\n    LegacyCommunicationsController: _CommunicationsController__WEBPACK_IMPORTED_MODULE_0__[\"CommunicationsControllerServiceClient\"].createLegacy,\n    LegacyEnvironmentAPI: _EnvironmentAPI__WEBPACK_IMPORTED_MODULE_3__[\"EnvironmentAPIServiceClient\"].createLegacy,\n    LegacyEthereumController: _EthereumController__WEBPACK_IMPORTED_MODULE_4__[\"EthereumControllerServiceClient\"].createLegacy,\n    LegacyParcelIdentity: _ParcelIdentity__WEBPACK_IMPORTED_MODULE_6__[\"ParcelIdentityServiceClient\"].createLegacy,\n    LegacyPlayers: _Players__WEBPACK_IMPORTED_MODULE_8__[\"PlayersServiceClient\"].createLegacy,\n    LegacyPortableExperience: _PortableExperiences__WEBPACK_IMPORTED_MODULE_9__[\"PortableExperienceServiceClient\"].createLegacy,\n    LegacyRestrictedActions: _RestrictedActions__WEBPACK_IMPORTED_MODULE_10__[\"RestrictedActionsServiceClient\"].createLegacy,\n    LegacyRestrictedActionModule: _RestrictedActions__WEBPACK_IMPORTED_MODULE_10__[\"RestrictedActionsServiceClient\"].createLegacy,\n    LegacyUserActionModule: _UserActionModule__WEBPACK_IMPORTED_MODULE_13__[\"UserActionModuleServiceClient\"].createLegacy,\n    LegacyIdentity: _UserIdentity__WEBPACK_IMPORTED_MODULE_14__[\"UserIdentityServiceClient\"].createLegacy,\n    ['Legacyweb3-provider']: _Web3Provider__WEBPACK_IMPORTED_MODULE_15__[\"createLegacyWeb3Provider\"],\n    LegacySocialController: _SocialController__WEBPACK_IMPORTED_MODULE_12__[\"createSocialControllerServiceClient\"]\n};\n\n\n//# sourceURL=webpack:///./packages/shared/apis/client/index.ts?");

/***/ }),

/***/ "./packages/shared/protocol/common/ContentMapping.gen.ts":
/*!***************************************************************!*\
  !*** ./packages/shared/protocol/common/ContentMapping.gen.ts ***!
  \***************************************************************/
/*! exports provided: protobufPackage, ContentMapping */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ContentMapping\", function() { return ContentMapping; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"decentraland.common\";\nfunction createBaseContentMapping() {\n    return { file: \"\", hash: \"\" };\n}\nconst ContentMapping = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.file !== \"\") {\n            writer.uint32(10).string(message.file);\n        }\n        if (message.hash !== \"\") {\n            writer.uint32(18).string(message.hash);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseContentMapping();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.file = reader.string();\n                    break;\n                case 2:\n                    message.hash = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { file: isSet(object.file) ? String(object.file) : \"\", hash: isSet(object.hash) ? String(object.hash) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.file !== undefined && (obj.file = message.file);\n        message.hash !== undefined && (obj.hash = message.hash);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseContentMapping();\n        message.file = (_a = object.file) !== null && _a !== void 0 ? _a : \"\";\n        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/common/ContentMapping.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/google/protobuf/empty.gen.ts":
/*!***************************************************************!*\
  !*** ./packages/shared/protocol/google/protobuf/empty.gen.ts ***!
  \***************************************************************/
/*! exports provided: protobufPackage, Empty */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Empty\", function() { return Empty; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"google.protobuf\";\nfunction createBaseEmpty() {\n    return {};\n}\nconst Empty = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEmpty();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseEmpty();\n        return message;\n    },\n};\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/google/protobuf/empty.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/CommunicationsController.gen.ts":
/*!******************************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/CommunicationsController.gen.ts ***!
  \******************************************************************************/
/*! exports provided: protobufPackage, RealSendRequest, RealSendResponse, CommunicationsControllerServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RealSendRequest\", function() { return RealSendRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RealSendResponse\", function() { return RealSendResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CommunicationsControllerServiceDefinition\", function() { return CommunicationsControllerServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseRealSendRequest() {\n    return { message: \"\" };\n}\nconst RealSendRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.message !== \"\") {\n            writer.uint32(10).string(message.message);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRealSendRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { message: isSet(object.message) ? String(object.message) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.message !== undefined && (obj.message = message.message);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRealSendRequest();\n        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseRealSendResponse() {\n    return {};\n}\nconst RealSendResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRealSendResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseRealSendResponse();\n        return message;\n    },\n};\nconst CommunicationsControllerServiceDefinition = {\n    name: \"CommunicationsControllerService\",\n    fullName: \"CommunicationsControllerService\",\n    methods: {\n        send: {\n            name: \"Send\",\n            requestType: RealSendRequest,\n            requestStream: false,\n            responseType: RealSendResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/CommunicationsController.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/DevTools.gen.ts":
/*!**************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/DevTools.gen.ts ***!
  \**************************************************************/
/*! exports provided: protobufPackage, DevToolsBody, EventResponse, DevToolsServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DevToolsBody\", function() { return DevToolsBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventResponse\", function() { return EventResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"DevToolsServiceDefinition\", function() { return DevToolsServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseDevToolsBody() {\n    return { type: \"\", jsonPayload: \"\" };\n}\nconst DevToolsBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.type !== \"\") {\n            writer.uint32(10).string(message.type);\n        }\n        if (message.jsonPayload !== \"\") {\n            writer.uint32(18).string(message.jsonPayload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseDevToolsBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.string();\n                    break;\n                case 2:\n                    message.jsonPayload = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type) ? String(object.type) : \"\",\n            jsonPayload: isSet(object.jsonPayload) ? String(object.jsonPayload) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = message.type);\n        message.jsonPayload !== undefined && (obj.jsonPayload = message.jsonPayload);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseDevToolsBody();\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : \"\";\n        message.jsonPayload = (_b = object.jsonPayload) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseEventResponse() {\n    return {};\n}\nconst EventResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEventResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseEventResponse();\n        return message;\n    },\n};\nconst DevToolsServiceDefinition = {\n    name: \"DevToolsService\",\n    fullName: \"DevToolsService\",\n    methods: {\n        event: {\n            name: \"Event\",\n            requestType: DevToolsBody,\n            requestStream: false,\n            responseType: EventResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/DevTools.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/EngineAPI.gen.ts":
/*!***************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/EngineAPI.gen.ts ***!
  \***************************************************************/
/*! exports provided: protobufPackage, QueryType, queryTypeFromJSON, queryTypeToJSON, EAType, eATypeFromJSON, eATypeToJSON, EventDataType, eventDataTypeFromJSON, eventDataTypeToJSON, OpenExternalUrlBody, OpenNFTDialogBody, CreateEntityBody, RemoveEntityBody, UpdateEntityComponentBody, AttachEntityComponentBody, ComponentRemovedBody, SetEntityParentBody, QueryBody, ComponentCreatedBody, ComponentDisposedBody, ComponentUpdatedBody, InitMessagesFinishedBody, Payload, EntityAction, ManyEntityAction, SendBatchResponse, UnsubscribeRequest, SubscribeRequest, SubscribeResponse, UnsubscribeResponse, GenericPayload, ReadOnlyVector3, ReadOnlyQuaternion, PositionChangedPayload, RotationChangedPayload, EventData, EngineAPIServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QueryType\", function() { return QueryType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"queryTypeFromJSON\", function() { return queryTypeFromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"queryTypeToJSON\", function() { return queryTypeToJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EAType\", function() { return EAType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eATypeFromJSON\", function() { return eATypeFromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eATypeToJSON\", function() { return eATypeToJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventDataType\", function() { return EventDataType; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eventDataTypeFromJSON\", function() { return eventDataTypeFromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"eventDataTypeToJSON\", function() { return eventDataTypeToJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OpenExternalUrlBody\", function() { return OpenExternalUrlBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"OpenNFTDialogBody\", function() { return OpenNFTDialogBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"CreateEntityBody\", function() { return CreateEntityBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RemoveEntityBody\", function() { return RemoveEntityBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UpdateEntityComponentBody\", function() { return UpdateEntityComponentBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AttachEntityComponentBody\", function() { return AttachEntityComponentBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentRemovedBody\", function() { return ComponentRemovedBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SetEntityParentBody\", function() { return SetEntityParentBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"QueryBody\", function() { return QueryBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentCreatedBody\", function() { return ComponentCreatedBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentDisposedBody\", function() { return ComponentDisposedBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ComponentUpdatedBody\", function() { return ComponentUpdatedBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InitMessagesFinishedBody\", function() { return InitMessagesFinishedBody; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Payload\", function() { return Payload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EntityAction\", function() { return EntityAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ManyEntityAction\", function() { return ManyEntityAction; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SendBatchResponse\", function() { return SendBatchResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsubscribeRequest\", function() { return UnsubscribeRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubscribeRequest\", function() { return SubscribeRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SubscribeResponse\", function() { return SubscribeResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UnsubscribeResponse\", function() { return UnsubscribeResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GenericPayload\", function() { return GenericPayload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadOnlyVector3\", function() { return ReadOnlyVector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ReadOnlyQuaternion\", function() { return ReadOnlyQuaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PositionChangedPayload\", function() { return PositionChangedPayload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RotationChangedPayload\", function() { return RotationChangedPayload; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EventData\", function() { return EventData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EngineAPIServiceDefinition\", function() { return EngineAPIServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nvar QueryType;\n(function (QueryType) {\n    QueryType[QueryType[\"InvalidQueryType\"] = 0] = \"InvalidQueryType\";\n    QueryType[QueryType[\"HitFirst\"] = 1] = \"HitFirst\";\n    QueryType[QueryType[\"HitAll\"] = 2] = \"HitAll\";\n    QueryType[QueryType[\"HitFirstAvatar\"] = 3] = \"HitFirstAvatar\";\n    QueryType[QueryType[\"HitAllAvatars\"] = 4] = \"HitAllAvatars\";\n    QueryType[QueryType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(QueryType || (QueryType = {}));\nfunction queryTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"InvalidQueryType\":\n            return QueryType.InvalidQueryType;\n        case 1:\n        case \"HitFirst\":\n            return QueryType.HitFirst;\n        case 2:\n        case \"HitAll\":\n            return QueryType.HitAll;\n        case 3:\n        case \"HitFirstAvatar\":\n            return QueryType.HitFirstAvatar;\n        case 4:\n        case \"HitAllAvatars\":\n            return QueryType.HitAllAvatars;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return QueryType.UNRECOGNIZED;\n    }\n}\nfunction queryTypeToJSON(object) {\n    switch (object) {\n        case QueryType.InvalidQueryType:\n            return \"InvalidQueryType\";\n        case QueryType.HitFirst:\n            return \"HitFirst\";\n        case QueryType.HitAll:\n            return \"HitAll\";\n        case QueryType.HitFirstAvatar:\n            return \"HitFirstAvatar\";\n        case QueryType.HitAllAvatars:\n            return \"HitAllAvatars\";\n        case QueryType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nvar EAType;\n(function (EAType) {\n    EAType[EAType[\"InvalidEAType\"] = 0] = \"InvalidEAType\";\n    EAType[EAType[\"OpenExternalUrl\"] = 1] = \"OpenExternalUrl\";\n    EAType[EAType[\"OpenNFTDialog\"] = 2] = \"OpenNFTDialog\";\n    EAType[EAType[\"CreateEntity\"] = 3] = \"CreateEntity\";\n    EAType[EAType[\"RemoveEntity\"] = 4] = \"RemoveEntity\";\n    EAType[EAType[\"UpdateEntityComponent\"] = 5] = \"UpdateEntityComponent\";\n    EAType[EAType[\"AttachEntityComponent\"] = 6] = \"AttachEntityComponent\";\n    EAType[EAType[\"ComponentRemoved\"] = 7] = \"ComponentRemoved\";\n    EAType[EAType[\"SetEntityParent\"] = 8] = \"SetEntityParent\";\n    EAType[EAType[\"Query\"] = 9] = \"Query\";\n    EAType[EAType[\"ComponentCreated\"] = 10] = \"ComponentCreated\";\n    EAType[EAType[\"ComponentDisposed\"] = 11] = \"ComponentDisposed\";\n    EAType[EAType[\"ComponentUpdated\"] = 12] = \"ComponentUpdated\";\n    EAType[EAType[\"InitMessagesFinished\"] = 13] = \"InitMessagesFinished\";\n    EAType[EAType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(EAType || (EAType = {}));\nfunction eATypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"InvalidEAType\":\n            return EAType.InvalidEAType;\n        case 1:\n        case \"OpenExternalUrl\":\n            return EAType.OpenExternalUrl;\n        case 2:\n        case \"OpenNFTDialog\":\n            return EAType.OpenNFTDialog;\n        case 3:\n        case \"CreateEntity\":\n            return EAType.CreateEntity;\n        case 4:\n        case \"RemoveEntity\":\n            return EAType.RemoveEntity;\n        case 5:\n        case \"UpdateEntityComponent\":\n            return EAType.UpdateEntityComponent;\n        case 6:\n        case \"AttachEntityComponent\":\n            return EAType.AttachEntityComponent;\n        case 7:\n        case \"ComponentRemoved\":\n            return EAType.ComponentRemoved;\n        case 8:\n        case \"SetEntityParent\":\n            return EAType.SetEntityParent;\n        case 9:\n        case \"Query\":\n            return EAType.Query;\n        case 10:\n        case \"ComponentCreated\":\n            return EAType.ComponentCreated;\n        case 11:\n        case \"ComponentDisposed\":\n            return EAType.ComponentDisposed;\n        case 12:\n        case \"ComponentUpdated\":\n            return EAType.ComponentUpdated;\n        case 13:\n        case \"InitMessagesFinished\":\n            return EAType.InitMessagesFinished;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return EAType.UNRECOGNIZED;\n    }\n}\nfunction eATypeToJSON(object) {\n    switch (object) {\n        case EAType.InvalidEAType:\n            return \"InvalidEAType\";\n        case EAType.OpenExternalUrl:\n            return \"OpenExternalUrl\";\n        case EAType.OpenNFTDialog:\n            return \"OpenNFTDialog\";\n        case EAType.CreateEntity:\n            return \"CreateEntity\";\n        case EAType.RemoveEntity:\n            return \"RemoveEntity\";\n        case EAType.UpdateEntityComponent:\n            return \"UpdateEntityComponent\";\n        case EAType.AttachEntityComponent:\n            return \"AttachEntityComponent\";\n        case EAType.ComponentRemoved:\n            return \"ComponentRemoved\";\n        case EAType.SetEntityParent:\n            return \"SetEntityParent\";\n        case EAType.Query:\n            return \"Query\";\n        case EAType.ComponentCreated:\n            return \"ComponentCreated\";\n        case EAType.ComponentDisposed:\n            return \"ComponentDisposed\";\n        case EAType.ComponentUpdated:\n            return \"ComponentUpdated\";\n        case EAType.InitMessagesFinished:\n            return \"InitMessagesFinished\";\n        case EAType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nvar EventDataType;\n(function (EventDataType) {\n    EventDataType[EventDataType[\"Generic\"] = 0] = \"Generic\";\n    EventDataType[EventDataType[\"PositionChanged\"] = 1] = \"PositionChanged\";\n    EventDataType[EventDataType[\"RotationChanged\"] = 2] = \"RotationChanged\";\n    EventDataType[EventDataType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(EventDataType || (EventDataType = {}));\nfunction eventDataTypeFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"Generic\":\n            return EventDataType.Generic;\n        case 1:\n        case \"PositionChanged\":\n            return EventDataType.PositionChanged;\n        case 2:\n        case \"RotationChanged\":\n            return EventDataType.RotationChanged;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return EventDataType.UNRECOGNIZED;\n    }\n}\nfunction eventDataTypeToJSON(object) {\n    switch (object) {\n        case EventDataType.Generic:\n            return \"Generic\";\n        case EventDataType.PositionChanged:\n            return \"PositionChanged\";\n        case EventDataType.RotationChanged:\n            return \"RotationChanged\";\n        case EventDataType.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBaseOpenExternalUrlBody() {\n    return { url: \"\" };\n}\nconst OpenExternalUrlBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.url !== \"\") {\n            writer.uint32(10).string(message.url);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOpenExternalUrlBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.url = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { url: isSet(object.url) ? String(object.url) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.url !== undefined && (obj.url = message.url);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseOpenExternalUrlBody();\n        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseOpenNFTDialogBody() {\n    return { assetContractAddress: \"\", tokenId: \"\", comment: undefined };\n}\nconst OpenNFTDialogBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.assetContractAddress !== \"\") {\n            writer.uint32(10).string(message.assetContractAddress);\n        }\n        if (message.tokenId !== \"\") {\n            writer.uint32(18).string(message.tokenId);\n        }\n        if (message.comment !== undefined) {\n            writer.uint32(26).string(message.comment);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseOpenNFTDialogBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.assetContractAddress = reader.string();\n                    break;\n                case 2:\n                    message.tokenId = reader.string();\n                    break;\n                case 3:\n                    message.comment = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            assetContractAddress: isSet(object.assetContractAddress) ? String(object.assetContractAddress) : \"\",\n            tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n            comment: isSet(object.comment) ? String(object.comment) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.assetContractAddress !== undefined && (obj.assetContractAddress = message.assetContractAddress);\n        message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n        message.comment !== undefined && (obj.comment = message.comment);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseOpenNFTDialogBody();\n        message.assetContractAddress = (_a = object.assetContractAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.tokenId = (_b = object.tokenId) !== null && _b !== void 0 ? _b : \"\";\n        message.comment = (_c = object.comment) !== null && _c !== void 0 ? _c : undefined;\n        return message;\n    },\n};\nfunction createBaseCreateEntityBody() {\n    return { id: \"\" };\n}\nconst CreateEntityBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseCreateEntityBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseCreateEntityBody();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseRemoveEntityBody() {\n    return { id: \"\" };\n}\nconst RemoveEntityBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRemoveEntityBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRemoveEntityBody();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseUpdateEntityComponentBody() {\n    return { entityId: \"\", classId: 0, name: \"\", json: \"\" };\n}\nconst UpdateEntityComponentBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.classId !== 0) {\n            writer.uint32(16).int32(message.classId);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(26).string(message.name);\n        }\n        if (message.json !== \"\") {\n            writer.uint32(34).string(message.json);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUpdateEntityComponentBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.classId = reader.int32();\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                case 4:\n                    message.json = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            classId: isSet(object.classId) ? Number(object.classId) : 0,\n            name: isSet(object.name) ? String(object.name) : \"\",\n            json: isSet(object.json) ? String(object.json) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.classId !== undefined && (obj.classId = Math.round(message.classId));\n        message.name !== undefined && (obj.name = message.name);\n        message.json !== undefined && (obj.json = message.json);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseUpdateEntityComponentBody();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.classId = (_b = object.classId) !== null && _b !== void 0 ? _b : 0;\n        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : \"\";\n        message.json = (_d = object.json) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nfunction createBaseAttachEntityComponentBody() {\n    return { entityId: \"\", name: \"\", id: \"\" };\n}\nconst AttachEntityComponentBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(18).string(message.name);\n        }\n        if (message.id !== \"\") {\n            writer.uint32(26).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAttachEntityComponentBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            name: isSet(object.name) ? String(object.name) : \"\",\n            id: isSet(object.id) ? String(object.id) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.name !== undefined && (obj.name = message.name);\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseAttachEntityComponentBody();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n        message.id = (_c = object.id) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseComponentRemovedBody() {\n    return { entityId: \"\", name: \"\" };\n}\nconst ComponentRemovedBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(18).string(message.name);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComponentRemovedBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            name: isSet(object.name) ? String(object.name) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.name !== undefined && (obj.name = message.name);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseComponentRemovedBody();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSetEntityParentBody() {\n    return { entityId: \"\", parentId: \"\" };\n}\nconst SetEntityParentBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.parentId !== \"\") {\n            writer.uint32(18).string(message.parentId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSetEntityParentBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.parentId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            parentId: isSet(object.parentId) ? String(object.parentId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.parentId !== undefined && (obj.parentId = message.parentId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSetEntityParentBody();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.parentId = (_b = object.parentId) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseQueryBody() {\n    return { queryId: 0, payload: \"\" };\n}\nconst QueryBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.queryId !== 0) {\n            writer.uint32(8).int32(message.queryId);\n        }\n        if (message.payload !== \"\") {\n            writer.uint32(18).string(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseQueryBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.queryId = reader.int32();\n                    break;\n                case 2:\n                    message.payload = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            queryId: isSet(object.queryId) ? queryTypeFromJSON(object.queryId) : 0,\n            payload: isSet(object.payload) ? String(object.payload) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.queryId !== undefined && (obj.queryId = queryTypeToJSON(message.queryId));\n        message.payload !== undefined && (obj.payload = message.payload);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseQueryBody();\n        message.queryId = (_a = object.queryId) !== null && _a !== void 0 ? _a : 0;\n        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseComponentCreatedBody() {\n    return { id: \"\", classId: 0, name: \"\" };\n}\nconst ComponentCreatedBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.classId !== 0) {\n            writer.uint32(16).int32(message.classId);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(26).string(message.name);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComponentCreatedBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.classId = reader.int32();\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            classId: isSet(object.classId) ? Number(object.classId) : 0,\n            name: isSet(object.name) ? String(object.name) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.classId !== undefined && (obj.classId = Math.round(message.classId));\n        message.name !== undefined && (obj.name = message.name);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseComponentCreatedBody();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.classId = (_b = object.classId) !== null && _b !== void 0 ? _b : 0;\n        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseComponentDisposedBody() {\n    return { id: \"\" };\n}\nconst ComponentDisposedBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComponentDisposedBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseComponentDisposedBody();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseComponentUpdatedBody() {\n    return { id: \"\", json: \"\" };\n}\nconst ComponentUpdatedBody = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.json !== \"\") {\n            writer.uint32(18).string(message.json);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseComponentUpdatedBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.json = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\", json: isSet(object.json) ? String(object.json) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.json !== undefined && (obj.json = message.json);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseComponentUpdatedBody();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.json = (_b = object.json) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseInitMessagesFinishedBody() {\n    return {};\n}\nconst InitMessagesFinishedBody = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInitMessagesFinishedBody();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseInitMessagesFinishedBody();\n        return message;\n    },\n};\nfunction createBasePayload() {\n    return {\n        openExternalUrl: undefined,\n        openNftDialog: undefined,\n        createEntity: undefined,\n        removeEntity: undefined,\n        updateEntityComponent: undefined,\n        attachEntityComponent: undefined,\n        componentRemoved: undefined,\n        setEntityParent: undefined,\n        query: undefined,\n        componentCreated: undefined,\n        componentDisposed: undefined,\n        componentUpdated: undefined,\n        initMessagesFinished: undefined,\n    };\n}\nconst Payload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.openExternalUrl !== undefined) {\n            OpenExternalUrlBody.encode(message.openExternalUrl, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.openNftDialog !== undefined) {\n            OpenNFTDialogBody.encode(message.openNftDialog, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.createEntity !== undefined) {\n            CreateEntityBody.encode(message.createEntity, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.removeEntity !== undefined) {\n            RemoveEntityBody.encode(message.removeEntity, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.updateEntityComponent !== undefined) {\n            UpdateEntityComponentBody.encode(message.updateEntityComponent, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.attachEntityComponent !== undefined) {\n            AttachEntityComponentBody.encode(message.attachEntityComponent, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.componentRemoved !== undefined) {\n            ComponentRemovedBody.encode(message.componentRemoved, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.setEntityParent !== undefined) {\n            SetEntityParentBody.encode(message.setEntityParent, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.query !== undefined) {\n            QueryBody.encode(message.query, writer.uint32(74).fork()).ldelim();\n        }\n        if (message.componentCreated !== undefined) {\n            ComponentCreatedBody.encode(message.componentCreated, writer.uint32(82).fork()).ldelim();\n        }\n        if (message.componentDisposed !== undefined) {\n            ComponentDisposedBody.encode(message.componentDisposed, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.componentUpdated !== undefined) {\n            ComponentUpdatedBody.encode(message.componentUpdated, writer.uint32(98).fork()).ldelim();\n        }\n        if (message.initMessagesFinished !== undefined) {\n            InitMessagesFinishedBody.encode(message.initMessagesFinished, writer.uint32(106).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.openExternalUrl = OpenExternalUrlBody.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.openNftDialog = OpenNFTDialogBody.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.createEntity = CreateEntityBody.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.removeEntity = RemoveEntityBody.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.updateEntityComponent = UpdateEntityComponentBody.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.attachEntityComponent = AttachEntityComponentBody.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.componentRemoved = ComponentRemovedBody.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.setEntityParent = SetEntityParentBody.decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.query = QueryBody.decode(reader, reader.uint32());\n                    break;\n                case 10:\n                    message.componentCreated = ComponentCreatedBody.decode(reader, reader.uint32());\n                    break;\n                case 11:\n                    message.componentDisposed = ComponentDisposedBody.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.componentUpdated = ComponentUpdatedBody.decode(reader, reader.uint32());\n                    break;\n                case 13:\n                    message.initMessagesFinished = InitMessagesFinishedBody.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            openExternalUrl: isSet(object.openExternalUrl) ? OpenExternalUrlBody.fromJSON(object.openExternalUrl) : undefined,\n            openNftDialog: isSet(object.openNftDialog) ? OpenNFTDialogBody.fromJSON(object.openNftDialog) : undefined,\n            createEntity: isSet(object.createEntity) ? CreateEntityBody.fromJSON(object.createEntity) : undefined,\n            removeEntity: isSet(object.removeEntity) ? RemoveEntityBody.fromJSON(object.removeEntity) : undefined,\n            updateEntityComponent: isSet(object.updateEntityComponent)\n                ? UpdateEntityComponentBody.fromJSON(object.updateEntityComponent)\n                : undefined,\n            attachEntityComponent: isSet(object.attachEntityComponent)\n                ? AttachEntityComponentBody.fromJSON(object.attachEntityComponent)\n                : undefined,\n            componentRemoved: isSet(object.componentRemoved)\n                ? ComponentRemovedBody.fromJSON(object.componentRemoved)\n                : undefined,\n            setEntityParent: isSet(object.setEntityParent) ? SetEntityParentBody.fromJSON(object.setEntityParent) : undefined,\n            query: isSet(object.query) ? QueryBody.fromJSON(object.query) : undefined,\n            componentCreated: isSet(object.componentCreated)\n                ? ComponentCreatedBody.fromJSON(object.componentCreated)\n                : undefined,\n            componentDisposed: isSet(object.componentDisposed)\n                ? ComponentDisposedBody.fromJSON(object.componentDisposed)\n                : undefined,\n            componentUpdated: isSet(object.componentUpdated)\n                ? ComponentUpdatedBody.fromJSON(object.componentUpdated)\n                : undefined,\n            initMessagesFinished: isSet(object.initMessagesFinished)\n                ? InitMessagesFinishedBody.fromJSON(object.initMessagesFinished)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.openExternalUrl !== undefined &&\n            (obj.openExternalUrl = message.openExternalUrl ? OpenExternalUrlBody.toJSON(message.openExternalUrl) : undefined);\n        message.openNftDialog !== undefined &&\n            (obj.openNftDialog = message.openNftDialog ? OpenNFTDialogBody.toJSON(message.openNftDialog) : undefined);\n        message.createEntity !== undefined &&\n            (obj.createEntity = message.createEntity ? CreateEntityBody.toJSON(message.createEntity) : undefined);\n        message.removeEntity !== undefined &&\n            (obj.removeEntity = message.removeEntity ? RemoveEntityBody.toJSON(message.removeEntity) : undefined);\n        message.updateEntityComponent !== undefined && (obj.updateEntityComponent = message.updateEntityComponent\n            ? UpdateEntityComponentBody.toJSON(message.updateEntityComponent)\n            : undefined);\n        message.attachEntityComponent !== undefined && (obj.attachEntityComponent = message.attachEntityComponent\n            ? AttachEntityComponentBody.toJSON(message.attachEntityComponent)\n            : undefined);\n        message.componentRemoved !== undefined && (obj.componentRemoved = message.componentRemoved\n            ? ComponentRemovedBody.toJSON(message.componentRemoved)\n            : undefined);\n        message.setEntityParent !== undefined &&\n            (obj.setEntityParent = message.setEntityParent ? SetEntityParentBody.toJSON(message.setEntityParent) : undefined);\n        message.query !== undefined && (obj.query = message.query ? QueryBody.toJSON(message.query) : undefined);\n        message.componentCreated !== undefined && (obj.componentCreated = message.componentCreated\n            ? ComponentCreatedBody.toJSON(message.componentCreated)\n            : undefined);\n        message.componentDisposed !== undefined && (obj.componentDisposed = message.componentDisposed\n            ? ComponentDisposedBody.toJSON(message.componentDisposed)\n            : undefined);\n        message.componentUpdated !== undefined && (obj.componentUpdated = message.componentUpdated\n            ? ComponentUpdatedBody.toJSON(message.componentUpdated)\n            : undefined);\n        message.initMessagesFinished !== undefined && (obj.initMessagesFinished = message.initMessagesFinished\n            ? InitMessagesFinishedBody.toJSON(message.initMessagesFinished)\n            : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePayload();\n        message.openExternalUrl = (object.openExternalUrl !== undefined && object.openExternalUrl !== null)\n            ? OpenExternalUrlBody.fromPartial(object.openExternalUrl)\n            : undefined;\n        message.openNftDialog = (object.openNftDialog !== undefined && object.openNftDialog !== null)\n            ? OpenNFTDialogBody.fromPartial(object.openNftDialog)\n            : undefined;\n        message.createEntity = (object.createEntity !== undefined && object.createEntity !== null)\n            ? CreateEntityBody.fromPartial(object.createEntity)\n            : undefined;\n        message.removeEntity = (object.removeEntity !== undefined && object.removeEntity !== null)\n            ? RemoveEntityBody.fromPartial(object.removeEntity)\n            : undefined;\n        message.updateEntityComponent =\n            (object.updateEntityComponent !== undefined && object.updateEntityComponent !== null)\n                ? UpdateEntityComponentBody.fromPartial(object.updateEntityComponent)\n                : undefined;\n        message.attachEntityComponent =\n            (object.attachEntityComponent !== undefined && object.attachEntityComponent !== null)\n                ? AttachEntityComponentBody.fromPartial(object.attachEntityComponent)\n                : undefined;\n        message.componentRemoved = (object.componentRemoved !== undefined && object.componentRemoved !== null)\n            ? ComponentRemovedBody.fromPartial(object.componentRemoved)\n            : undefined;\n        message.setEntityParent = (object.setEntityParent !== undefined && object.setEntityParent !== null)\n            ? SetEntityParentBody.fromPartial(object.setEntityParent)\n            : undefined;\n        message.query = (object.query !== undefined && object.query !== null)\n            ? QueryBody.fromPartial(object.query)\n            : undefined;\n        message.componentCreated = (object.componentCreated !== undefined && object.componentCreated !== null)\n            ? ComponentCreatedBody.fromPartial(object.componentCreated)\n            : undefined;\n        message.componentDisposed = (object.componentDisposed !== undefined && object.componentDisposed !== null)\n            ? ComponentDisposedBody.fromPartial(object.componentDisposed)\n            : undefined;\n        message.componentUpdated = (object.componentUpdated !== undefined && object.componentUpdated !== null)\n            ? ComponentUpdatedBody.fromPartial(object.componentUpdated)\n            : undefined;\n        message.initMessagesFinished = (object.initMessagesFinished !== undefined && object.initMessagesFinished !== null)\n            ? InitMessagesFinishedBody.fromPartial(object.initMessagesFinished)\n            : undefined;\n        return message;\n    },\n};\nfunction createBaseEntityAction() {\n    return { type: 0, tag: undefined, payload: undefined };\n}\nconst EntityAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.type !== 0) {\n            writer.uint32(8).int32(message.type);\n        }\n        if (message.tag !== undefined) {\n            writer.uint32(18).string(message.tag);\n        }\n        if (message.payload !== undefined) {\n            Payload.encode(message.payload, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEntityAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.int32();\n                    break;\n                case 2:\n                    message.tag = reader.string();\n                    break;\n                case 3:\n                    message.payload = Payload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type) ? eATypeFromJSON(object.type) : 0,\n            tag: isSet(object.tag) ? String(object.tag) : undefined,\n            payload: isSet(object.payload) ? Payload.fromJSON(object.payload) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = eATypeToJSON(message.type));\n        message.tag !== undefined && (obj.tag = message.tag);\n        message.payload !== undefined && (obj.payload = message.payload ? Payload.toJSON(message.payload) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseEntityAction();\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;\n        message.tag = (_b = object.tag) !== null && _b !== void 0 ? _b : undefined;\n        message.payload = (object.payload !== undefined && object.payload !== null)\n            ? Payload.fromPartial(object.payload)\n            : undefined;\n        return message;\n    },\n};\nfunction createBaseManyEntityAction() {\n    return { actions: [] };\n}\nconst ManyEntityAction = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        for (const v of message.actions) {\n            EntityAction.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseManyEntityAction();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.actions.push(EntityAction.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { actions: Array.isArray(object === null || object === void 0 ? void 0 : object.actions) ? object.actions.map((e) => EntityAction.fromJSON(e)) : [] };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.actions) {\n            obj.actions = message.actions.map((e) => e ? EntityAction.toJSON(e) : undefined);\n        }\n        else {\n            obj.actions = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseManyEntityAction();\n        message.actions = ((_a = object.actions) === null || _a === void 0 ? void 0 : _a.map((e) => EntityAction.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseSendBatchResponse() {\n    return { events: [] };\n}\nconst SendBatchResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        for (const v of message.events) {\n            EventData.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendBatchResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.events.push(EventData.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => EventData.fromJSON(e)) : [] };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.events) {\n            obj.events = message.events.map((e) => e ? EventData.toJSON(e) : undefined);\n        }\n        else {\n            obj.events = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSendBatchResponse();\n        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e) => EventData.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseUnsubscribeRequest() {\n    return { eventId: \"\" };\n}\nconst UnsubscribeRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.eventId !== \"\") {\n            writer.uint32(10).string(message.eventId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnsubscribeRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { eventId: isSet(object.eventId) ? String(object.eventId) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.eventId !== undefined && (obj.eventId = message.eventId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseUnsubscribeRequest();\n        message.eventId = (_a = object.eventId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseSubscribeRequest() {\n    return { eventId: \"\" };\n}\nconst SubscribeRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.eventId !== \"\") {\n            writer.uint32(10).string(message.eventId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubscribeRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.eventId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { eventId: isSet(object.eventId) ? String(object.eventId) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.eventId !== undefined && (obj.eventId = message.eventId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSubscribeRequest();\n        message.eventId = (_a = object.eventId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseSubscribeResponse() {\n    return {};\n}\nconst SubscribeResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSubscribeResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseSubscribeResponse();\n        return message;\n    },\n};\nfunction createBaseUnsubscribeResponse() {\n    return {};\n}\nconst UnsubscribeResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUnsubscribeResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseUnsubscribeResponse();\n        return message;\n    },\n};\nfunction createBaseGenericPayload() {\n    return { eventId: \"\", eventData: \"\" };\n}\nconst GenericPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.eventId !== \"\") {\n            writer.uint32(26).string(message.eventId);\n        }\n        if (message.eventData !== \"\") {\n            writer.uint32(34).string(message.eventData);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGenericPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 3:\n                    message.eventId = reader.string();\n                    break;\n                case 4:\n                    message.eventData = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            eventId: isSet(object.eventId) ? String(object.eventId) : \"\",\n            eventData: isSet(object.eventData) ? String(object.eventData) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.eventId !== undefined && (obj.eventId = message.eventId);\n        message.eventData !== undefined && (obj.eventData = message.eventData);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGenericPayload();\n        message.eventId = (_a = object.eventId) !== null && _a !== void 0 ? _a : \"\";\n        message.eventData = (_b = object.eventData) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseReadOnlyVector3() {\n    return { x: 0, y: 0, z: 0 };\n}\nconst ReadOnlyVector3 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.x !== 0) {\n            writer.uint32(13).float(message.x);\n        }\n        if (message.y !== 0) {\n            writer.uint32(21).float(message.y);\n        }\n        if (message.z !== 0) {\n            writer.uint32(29).float(message.z);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseReadOnlyVector3();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                case 3:\n                    message.z = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            x: isSet(object.x) ? Number(object.x) : 0,\n            y: isSet(object.y) ? Number(object.y) : 0,\n            z: isSet(object.z) ? Number(object.z) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        message.z !== undefined && (obj.z = message.z);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseReadOnlyVector3();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : 0;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;\n        message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBaseReadOnlyQuaternion() {\n    return { x: 0, y: 0, z: 0, w: 0 };\n}\nconst ReadOnlyQuaternion = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.x !== 0) {\n            writer.uint32(13).float(message.x);\n        }\n        if (message.y !== 0) {\n            writer.uint32(21).float(message.y);\n        }\n        if (message.z !== 0) {\n            writer.uint32(29).float(message.z);\n        }\n        if (message.w !== 0) {\n            writer.uint32(37).float(message.w);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseReadOnlyQuaternion();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                case 3:\n                    message.z = reader.float();\n                    break;\n                case 4:\n                    message.w = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            x: isSet(object.x) ? Number(object.x) : 0,\n            y: isSet(object.y) ? Number(object.y) : 0,\n            z: isSet(object.z) ? Number(object.z) : 0,\n            w: isSet(object.w) ? Number(object.w) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        message.z !== undefined && (obj.z = message.z);\n        message.w !== undefined && (obj.w = message.w);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseReadOnlyQuaternion();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : 0;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;\n        message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;\n        message.w = (_d = object.w) !== null && _d !== void 0 ? _d : 0;\n        return message;\n    },\n};\nfunction createBasePositionChangedPayload() {\n    return { position: undefined, cameraPosition: undefined, playerHeight: 0 };\n}\nconst PositionChangedPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.position !== undefined) {\n            ReadOnlyVector3.encode(message.position, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.cameraPosition !== undefined) {\n            ReadOnlyVector3.encode(message.cameraPosition, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.playerHeight !== 0) {\n            writer.uint32(29).float(message.playerHeight);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePositionChangedPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.position = ReadOnlyVector3.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.cameraPosition = ReadOnlyVector3.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.playerHeight = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            position: isSet(object.position) ? ReadOnlyVector3.fromJSON(object.position) : undefined,\n            cameraPosition: isSet(object.cameraPosition) ? ReadOnlyVector3.fromJSON(object.cameraPosition) : undefined,\n            playerHeight: isSet(object.playerHeight) ? Number(object.playerHeight) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.position !== undefined &&\n            (obj.position = message.position ? ReadOnlyVector3.toJSON(message.position) : undefined);\n        message.cameraPosition !== undefined &&\n            (obj.cameraPosition = message.cameraPosition ? ReadOnlyVector3.toJSON(message.cameraPosition) : undefined);\n        message.playerHeight !== undefined && (obj.playerHeight = message.playerHeight);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePositionChangedPayload();\n        message.position = (object.position !== undefined && object.position !== null)\n            ? ReadOnlyVector3.fromPartial(object.position)\n            : undefined;\n        message.cameraPosition = (object.cameraPosition !== undefined && object.cameraPosition !== null)\n            ? ReadOnlyVector3.fromPartial(object.cameraPosition)\n            : undefined;\n        message.playerHeight = (_a = object.playerHeight) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseRotationChangedPayload() {\n    return { rotation: undefined, quaternion: undefined };\n}\nconst RotationChangedPayload = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.rotation !== undefined) {\n            ReadOnlyVector3.encode(message.rotation, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.quaternion !== undefined) {\n            ReadOnlyQuaternion.encode(message.quaternion, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRotationChangedPayload();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.rotation = ReadOnlyVector3.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.quaternion = ReadOnlyQuaternion.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            rotation: isSet(object.rotation) ? ReadOnlyVector3.fromJSON(object.rotation) : undefined,\n            quaternion: isSet(object.quaternion) ? ReadOnlyQuaternion.fromJSON(object.quaternion) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.rotation !== undefined &&\n            (obj.rotation = message.rotation ? ReadOnlyVector3.toJSON(message.rotation) : undefined);\n        message.quaternion !== undefined &&\n            (obj.quaternion = message.quaternion ? ReadOnlyQuaternion.toJSON(message.quaternion) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseRotationChangedPayload();\n        message.rotation = (object.rotation !== undefined && object.rotation !== null)\n            ? ReadOnlyVector3.fromPartial(object.rotation)\n            : undefined;\n        message.quaternion = (object.quaternion !== undefined && object.quaternion !== null)\n            ? ReadOnlyQuaternion.fromPartial(object.quaternion)\n            : undefined;\n        return message;\n    },\n};\nfunction createBaseEventData() {\n    return { type: 0, generic: undefined, positionChanged: undefined, rotationChanged: undefined };\n}\nconst EventData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.type !== 0) {\n            writer.uint32(8).int32(message.type);\n        }\n        if (message.generic !== undefined) {\n            GenericPayload.encode(message.generic, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.positionChanged !== undefined) {\n            PositionChangedPayload.encode(message.positionChanged, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.rotationChanged !== undefined) {\n            RotationChangedPayload.encode(message.rotationChanged, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEventData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.int32();\n                    break;\n                case 2:\n                    message.generic = GenericPayload.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.positionChanged = PositionChangedPayload.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.rotationChanged = RotationChangedPayload.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            type: isSet(object.type) ? eventDataTypeFromJSON(object.type) : 0,\n            generic: isSet(object.generic) ? GenericPayload.fromJSON(object.generic) : undefined,\n            positionChanged: isSet(object.positionChanged)\n                ? PositionChangedPayload.fromJSON(object.positionChanged)\n                : undefined,\n            rotationChanged: isSet(object.rotationChanged)\n                ? RotationChangedPayload.fromJSON(object.rotationChanged)\n                : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = eventDataTypeToJSON(message.type));\n        message.generic !== undefined &&\n            (obj.generic = message.generic ? GenericPayload.toJSON(message.generic) : undefined);\n        message.positionChanged !== undefined && (obj.positionChanged = message.positionChanged\n            ? PositionChangedPayload.toJSON(message.positionChanged)\n            : undefined);\n        message.rotationChanged !== undefined && (obj.rotationChanged = message.rotationChanged\n            ? RotationChangedPayload.toJSON(message.rotationChanged)\n            : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseEventData();\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : 0;\n        message.generic = (object.generic !== undefined && object.generic !== null)\n            ? GenericPayload.fromPartial(object.generic)\n            : undefined;\n        message.positionChanged = (object.positionChanged !== undefined && object.positionChanged !== null)\n            ? PositionChangedPayload.fromPartial(object.positionChanged)\n            : undefined;\n        message.rotationChanged = (object.rotationChanged !== undefined && object.rotationChanged !== null)\n            ? RotationChangedPayload.fromPartial(object.rotationChanged)\n            : undefined;\n        return message;\n    },\n};\nconst EngineAPIServiceDefinition = {\n    name: \"EngineAPIService\",\n    fullName: \"EngineAPIService\",\n    methods: {\n        sendBatch: {\n            name: \"SendBatch\",\n            requestType: ManyEntityAction,\n            requestStream: false,\n            responseType: SendBatchResponse,\n            responseStream: false,\n            options: {},\n        },\n        subscribe: {\n            name: \"Subscribe\",\n            requestType: SubscribeRequest,\n            requestStream: false,\n            responseType: SubscribeResponse,\n            responseStream: false,\n            options: {},\n        },\n        unsubscribe: {\n            name: \"Unsubscribe\",\n            requestType: UnsubscribeRequest,\n            requestStream: false,\n            responseType: UnsubscribeResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/EngineAPI.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/EnvironmentAPI.gen.ts":
/*!********************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/EnvironmentAPI.gen.ts ***!
  \********************************************************************/
/*! exports provided: protobufPackage, MinimalRunnableEntity, BootstrapDataResponse, PreviewModeResponse, AreUnsafeRequestAllowedResponse, GetPlatformResponse, EnvironmentRealm, GetCurrentRealmResponse, GetExplorerConfigurationResponse, GetExplorerConfigurationResponse_ConfigurationsEntry, GetDecentralandTimeResponse, GetBootstrapDataRequest, IsPreviewModeRequest, GetPlatformRequest, AreUnsafeRequestAllowedRequest, GetCurrentRealmRequest, GetExplorerConfigurationRequest, GetDecentralandTimeRequest, EnvironmentAPIServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MinimalRunnableEntity\", function() { return MinimalRunnableEntity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"BootstrapDataResponse\", function() { return BootstrapDataResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PreviewModeResponse\", function() { return PreviewModeResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AreUnsafeRequestAllowedResponse\", function() { return AreUnsafeRequestAllowedResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetPlatformResponse\", function() { return GetPlatformResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EnvironmentRealm\", function() { return EnvironmentRealm; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetCurrentRealmResponse\", function() { return GetCurrentRealmResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetExplorerConfigurationResponse\", function() { return GetExplorerConfigurationResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetExplorerConfigurationResponse_ConfigurationsEntry\", function() { return GetExplorerConfigurationResponse_ConfigurationsEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetDecentralandTimeResponse\", function() { return GetDecentralandTimeResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetBootstrapDataRequest\", function() { return GetBootstrapDataRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"IsPreviewModeRequest\", function() { return IsPreviewModeRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetPlatformRequest\", function() { return GetPlatformRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AreUnsafeRequestAllowedRequest\", function() { return AreUnsafeRequestAllowedRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetCurrentRealmRequest\", function() { return GetCurrentRealmRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetExplorerConfigurationRequest\", function() { return GetExplorerConfigurationRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetDecentralandTimeRequest\", function() { return GetDecentralandTimeRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EnvironmentAPIServiceDefinition\", function() { return EnvironmentAPIServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/ContentMapping.gen */ \"./packages/shared/protocol/common/ContentMapping.gen.ts\");\n\n\nconst protobufPackage = \"\";\nfunction createBaseMinimalRunnableEntity() {\n    return { content: [], metadataJson: \"\" };\n}\nconst MinimalRunnableEntity = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        for (const v of message.content) {\n            _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.metadataJson !== \"\") {\n            writer.uint32(18).string(message.metadataJson);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMinimalRunnableEntity();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.content.push(_common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].decode(reader, reader.uint32()));\n                    break;\n                case 2:\n                    message.metadataJson = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            content: Array.isArray(object === null || object === void 0 ? void 0 : object.content) ? object.content.map((e) => _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].fromJSON(e)) : [],\n            metadataJson: isSet(object.metadataJson) ? String(object.metadataJson) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.content) {\n            obj.content = message.content.map((e) => e ? _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].toJSON(e) : undefined);\n        }\n        else {\n            obj.content = [];\n        }\n        message.metadataJson !== undefined && (obj.metadataJson = message.metadataJson);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseMinimalRunnableEntity();\n        message.content = ((_a = object.content) === null || _a === void 0 ? void 0 : _a.map((e) => _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].fromPartial(e))) || [];\n        message.metadataJson = (_b = object.metadataJson) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseBootstrapDataResponse() {\n    return { id: \"\", baseUrl: \"\", entity: undefined, useFPSThrottling: false };\n}\nconst BootstrapDataResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.baseUrl !== \"\") {\n            writer.uint32(34).string(message.baseUrl);\n        }\n        if (message.entity !== undefined) {\n            MinimalRunnableEntity.encode(message.entity, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.useFPSThrottling === true) {\n            writer.uint32(40).bool(message.useFPSThrottling);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseBootstrapDataResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 4:\n                    message.baseUrl = reader.string();\n                    break;\n                case 2:\n                    message.entity = MinimalRunnableEntity.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.useFPSThrottling = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            baseUrl: isSet(object.baseUrl) ? String(object.baseUrl) : \"\",\n            entity: isSet(object.entity) ? MinimalRunnableEntity.fromJSON(object.entity) : undefined,\n            useFPSThrottling: isSet(object.useFPSThrottling) ? Boolean(object.useFPSThrottling) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.baseUrl !== undefined && (obj.baseUrl = message.baseUrl);\n        message.entity !== undefined &&\n            (obj.entity = message.entity ? MinimalRunnableEntity.toJSON(message.entity) : undefined);\n        message.useFPSThrottling !== undefined && (obj.useFPSThrottling = message.useFPSThrottling);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseBootstrapDataResponse();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.baseUrl = (_b = object.baseUrl) !== null && _b !== void 0 ? _b : \"\";\n        message.entity = (object.entity !== undefined && object.entity !== null)\n            ? MinimalRunnableEntity.fromPartial(object.entity)\n            : undefined;\n        message.useFPSThrottling = (_c = object.useFPSThrottling) !== null && _c !== void 0 ? _c : false;\n        return message;\n    },\n};\nfunction createBasePreviewModeResponse() {\n    return { isPreview: false };\n}\nconst PreviewModeResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.isPreview === true) {\n            writer.uint32(8).bool(message.isPreview);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePreviewModeResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isPreview = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { isPreview: isSet(object.isPreview) ? Boolean(object.isPreview) : false };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isPreview !== undefined && (obj.isPreview = message.isPreview);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePreviewModeResponse();\n        message.isPreview = (_a = object.isPreview) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nfunction createBaseAreUnsafeRequestAllowedResponse() {\n    return { status: false };\n}\nconst AreUnsafeRequestAllowedResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.status === true) {\n            writer.uint32(8).bool(message.status);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAreUnsafeRequestAllowedResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.status = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { status: isSet(object.status) ? Boolean(object.status) : false };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.status !== undefined && (obj.status = message.status);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseAreUnsafeRequestAllowedResponse();\n        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nfunction createBaseGetPlatformResponse() {\n    return { platform: \"\" };\n}\nconst GetPlatformResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.platform !== \"\") {\n            writer.uint32(10).string(message.platform);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPlatformResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.platform = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { platform: isSet(object.platform) ? String(object.platform) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.platform !== undefined && (obj.platform = message.platform);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetPlatformResponse();\n        message.platform = (_a = object.platform) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseEnvironmentRealm() {\n    return { domain: \"\", layer: \"\", room: \"\", serverName: \"\", displayName: \"\", protocol: \"\" };\n}\nconst EnvironmentRealm = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.domain !== \"\") {\n            writer.uint32(10).string(message.domain);\n        }\n        if (message.layer !== \"\") {\n            writer.uint32(18).string(message.layer);\n        }\n        if (message.room !== \"\") {\n            writer.uint32(26).string(message.room);\n        }\n        if (message.serverName !== \"\") {\n            writer.uint32(34).string(message.serverName);\n        }\n        if (message.displayName !== \"\") {\n            writer.uint32(42).string(message.displayName);\n        }\n        if (message.protocol !== \"\") {\n            writer.uint32(50).string(message.protocol);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseEnvironmentRealm();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.domain = reader.string();\n                    break;\n                case 2:\n                    message.layer = reader.string();\n                    break;\n                case 3:\n                    message.room = reader.string();\n                    break;\n                case 4:\n                    message.serverName = reader.string();\n                    break;\n                case 5:\n                    message.displayName = reader.string();\n                    break;\n                case 6:\n                    message.protocol = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            domain: isSet(object.domain) ? String(object.domain) : \"\",\n            layer: isSet(object.layer) ? String(object.layer) : \"\",\n            room: isSet(object.room) ? String(object.room) : \"\",\n            serverName: isSet(object.serverName) ? String(object.serverName) : \"\",\n            displayName: isSet(object.displayName) ? String(object.displayName) : \"\",\n            protocol: isSet(object.protocol) ? String(object.protocol) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.domain !== undefined && (obj.domain = message.domain);\n        message.layer !== undefined && (obj.layer = message.layer);\n        message.room !== undefined && (obj.room = message.room);\n        message.serverName !== undefined && (obj.serverName = message.serverName);\n        message.displayName !== undefined && (obj.displayName = message.displayName);\n        message.protocol !== undefined && (obj.protocol = message.protocol);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBaseEnvironmentRealm();\n        message.domain = (_a = object.domain) !== null && _a !== void 0 ? _a : \"\";\n        message.layer = (_b = object.layer) !== null && _b !== void 0 ? _b : \"\";\n        message.room = (_c = object.room) !== null && _c !== void 0 ? _c : \"\";\n        message.serverName = (_d = object.serverName) !== null && _d !== void 0 ? _d : \"\";\n        message.displayName = (_e = object.displayName) !== null && _e !== void 0 ? _e : \"\";\n        message.protocol = (_f = object.protocol) !== null && _f !== void 0 ? _f : \"\";\n        return message;\n    },\n};\nfunction createBaseGetCurrentRealmResponse() {\n    return { currentRealm: undefined };\n}\nconst GetCurrentRealmResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.currentRealm !== undefined) {\n            EnvironmentRealm.encode(message.currentRealm, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetCurrentRealmResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.currentRealm = EnvironmentRealm.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { currentRealm: isSet(object.currentRealm) ? EnvironmentRealm.fromJSON(object.currentRealm) : undefined };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.currentRealm !== undefined &&\n            (obj.currentRealm = message.currentRealm ? EnvironmentRealm.toJSON(message.currentRealm) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGetCurrentRealmResponse();\n        message.currentRealm = (object.currentRealm !== undefined && object.currentRealm !== null)\n            ? EnvironmentRealm.fromPartial(object.currentRealm)\n            : undefined;\n        return message;\n    },\n};\nfunction createBaseGetExplorerConfigurationResponse() {\n    return { clientUri: \"\", configurations: {} };\n}\nconst GetExplorerConfigurationResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.clientUri !== \"\") {\n            writer.uint32(10).string(message.clientUri);\n        }\n        Object.entries(message.configurations).forEach(([key, value]) => {\n            GetExplorerConfigurationResponse_ConfigurationsEntry.encode({ key: key, value }, writer.uint32(18).fork())\n                .ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetExplorerConfigurationResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clientUri = reader.string();\n                    break;\n                case 2:\n                    const entry2 = GetExplorerConfigurationResponse_ConfigurationsEntry.decode(reader, reader.uint32());\n                    if (entry2.value !== undefined) {\n                        message.configurations[entry2.key] = entry2.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            clientUri: isSet(object.clientUri) ? String(object.clientUri) : \"\",\n            configurations: isObject(object.configurations)\n                ? Object.entries(object.configurations).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clientUri !== undefined && (obj.clientUri = message.clientUri);\n        obj.configurations = {};\n        if (message.configurations) {\n            Object.entries(message.configurations).forEach(([k, v]) => {\n                obj.configurations[k] = v;\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetExplorerConfigurationResponse();\n        message.clientUri = (_a = object.clientUri) !== null && _a !== void 0 ? _a : \"\";\n        message.configurations = Object.entries((_b = object.configurations) !== null && _b !== void 0 ? _b : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseGetExplorerConfigurationResponse_ConfigurationsEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst GetExplorerConfigurationResponse_ConfigurationsEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetExplorerConfigurationResponse_ConfigurationsEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseGetExplorerConfigurationResponse_ConfigurationsEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseGetDecentralandTimeResponse() {\n    return { seconds: 0 };\n}\nconst GetDecentralandTimeResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.seconds !== 0) {\n            writer.uint32(8).int32(message.seconds);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetDecentralandTimeResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.seconds = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { seconds: isSet(object.seconds) ? Number(object.seconds) : 0 };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.seconds !== undefined && (obj.seconds = Math.round(message.seconds));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetDecentralandTimeResponse();\n        message.seconds = (_a = object.seconds) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseGetBootstrapDataRequest() {\n    return {};\n}\nconst GetBootstrapDataRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetBootstrapDataRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetBootstrapDataRequest();\n        return message;\n    },\n};\nfunction createBaseIsPreviewModeRequest() {\n    return {};\n}\nconst IsPreviewModeRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseIsPreviewModeRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseIsPreviewModeRequest();\n        return message;\n    },\n};\nfunction createBaseGetPlatformRequest() {\n    return {};\n}\nconst GetPlatformRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPlatformRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetPlatformRequest();\n        return message;\n    },\n};\nfunction createBaseAreUnsafeRequestAllowedRequest() {\n    return {};\n}\nconst AreUnsafeRequestAllowedRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAreUnsafeRequestAllowedRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseAreUnsafeRequestAllowedRequest();\n        return message;\n    },\n};\nfunction createBaseGetCurrentRealmRequest() {\n    return {};\n}\nconst GetCurrentRealmRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetCurrentRealmRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetCurrentRealmRequest();\n        return message;\n    },\n};\nfunction createBaseGetExplorerConfigurationRequest() {\n    return {};\n}\nconst GetExplorerConfigurationRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetExplorerConfigurationRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetExplorerConfigurationRequest();\n        return message;\n    },\n};\nfunction createBaseGetDecentralandTimeRequest() {\n    return {};\n}\nconst GetDecentralandTimeRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetDecentralandTimeRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetDecentralandTimeRequest();\n        return message;\n    },\n};\nconst EnvironmentAPIServiceDefinition = {\n    name: \"EnvironmentAPIService\",\n    fullName: \"EnvironmentAPIService\",\n    methods: {\n        getBootstrapData: {\n            name: \"GetBootstrapData\",\n            requestType: GetBootstrapDataRequest,\n            requestStream: false,\n            responseType: BootstrapDataResponse,\n            responseStream: false,\n            options: {},\n        },\n        isPreviewMode: {\n            name: \"IsPreviewMode\",\n            requestType: IsPreviewModeRequest,\n            requestStream: false,\n            responseType: PreviewModeResponse,\n            responseStream: false,\n            options: {},\n        },\n        getPlatform: {\n            name: \"GetPlatform\",\n            requestType: GetPlatformRequest,\n            requestStream: false,\n            responseType: GetPlatformResponse,\n            responseStream: false,\n            options: {},\n        },\n        areUnsafeRequestAllowed: {\n            name: \"AreUnsafeRequestAllowed\",\n            requestType: AreUnsafeRequestAllowedRequest,\n            requestStream: false,\n            responseType: AreUnsafeRequestAllowedResponse,\n            responseStream: false,\n            options: {},\n        },\n        getCurrentRealm: {\n            name: \"GetCurrentRealm\",\n            requestType: GetCurrentRealmRequest,\n            requestStream: false,\n            responseType: GetCurrentRealmResponse,\n            responseStream: false,\n            options: {},\n        },\n        getExplorerConfiguration: {\n            name: \"GetExplorerConfiguration\",\n            requestType: GetExplorerConfigurationRequest,\n            requestStream: false,\n            responseType: GetExplorerConfigurationResponse,\n            responseStream: false,\n            options: {},\n        },\n        getDecentralandTime: {\n            name: \"GetDecentralandTime\",\n            requestType: GetDecentralandTimeRequest,\n            requestStream: false,\n            responseType: GetDecentralandTimeResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/EnvironmentAPI.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/EthereumController.gen.ts":
/*!************************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/EthereumController.gen.ts ***!
  \************************************************************************/
/*! exports provided: protobufPackage, RequirePaymentRequest, RequirePaymentResponse, SignMessageRequest, SignMessageRequest_MessageEntry, SignMessageResponse, ConvertMessageToObjectRequest, ConvertMessageToObjectResponse, ConvertMessageToObjectResponse_DictEntry, SendAsyncRequest, SendAsyncResponse, GetUserAccountRequest, GetUserAccountResponse, EthereumControllerServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RequirePaymentRequest\", function() { return RequirePaymentRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RequirePaymentResponse\", function() { return RequirePaymentResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignMessageRequest\", function() { return SignMessageRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignMessageRequest_MessageEntry\", function() { return SignMessageRequest_MessageEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignMessageResponse\", function() { return SignMessageResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConvertMessageToObjectRequest\", function() { return ConvertMessageToObjectRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConvertMessageToObjectResponse\", function() { return ConvertMessageToObjectResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ConvertMessageToObjectResponse_DictEntry\", function() { return ConvertMessageToObjectResponse_DictEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SendAsyncRequest\", function() { return SendAsyncRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SendAsyncResponse\", function() { return SendAsyncResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetUserAccountRequest\", function() { return GetUserAccountRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetUserAccountResponse\", function() { return GetUserAccountResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"EthereumControllerServiceDefinition\", function() { return EthereumControllerServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseRequirePaymentRequest() {\n    return { toAddress: \"\", amount: 0, currency: \"\" };\n}\nconst RequirePaymentRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.toAddress !== \"\") {\n            writer.uint32(10).string(message.toAddress);\n        }\n        if (message.amount !== 0) {\n            writer.uint32(21).float(message.amount);\n        }\n        if (message.currency !== \"\") {\n            writer.uint32(26).string(message.currency);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRequirePaymentRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.toAddress = reader.string();\n                    break;\n                case 2:\n                    message.amount = reader.float();\n                    break;\n                case 3:\n                    message.currency = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            toAddress: isSet(object.toAddress) ? String(object.toAddress) : \"\",\n            amount: isSet(object.amount) ? Number(object.amount) : 0,\n            currency: isSet(object.currency) ? String(object.currency) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.toAddress !== undefined && (obj.toAddress = message.toAddress);\n        message.amount !== undefined && (obj.amount = message.amount);\n        message.currency !== undefined && (obj.currency = message.currency);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseRequirePaymentRequest();\n        message.toAddress = (_a = object.toAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.amount = (_b = object.amount) !== null && _b !== void 0 ? _b : 0;\n        message.currency = (_c = object.currency) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseRequirePaymentResponse() {\n    return { jsonAnyResponse: \"\" };\n}\nconst RequirePaymentResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.jsonAnyResponse !== \"\") {\n            writer.uint32(10).string(message.jsonAnyResponse);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRequirePaymentResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.jsonAnyResponse = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { jsonAnyResponse: isSet(object.jsonAnyResponse) ? String(object.jsonAnyResponse) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.jsonAnyResponse !== undefined && (obj.jsonAnyResponse = message.jsonAnyResponse);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRequirePaymentResponse();\n        message.jsonAnyResponse = (_a = object.jsonAnyResponse) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseSignMessageRequest() {\n    return { message: {} };\n}\nconst SignMessageRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        Object.entries(message.message).forEach(([key, value]) => {\n            SignMessageRequest_MessageEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignMessageRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = SignMessageRequest_MessageEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.message[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            message: isObject(object.message)\n                ? Object.entries(object.message).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.message = {};\n        if (message.message) {\n            Object.entries(message.message).forEach(([k, v]) => {\n                obj.message[k] = v;\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignMessageRequest();\n        message.message = Object.entries((_a = object.message) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseSignMessageRequest_MessageEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst SignMessageRequest_MessageEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignMessageRequest_MessageEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSignMessageRequest_MessageEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSignMessageResponse() {\n    return { message: \"\", hexEncodedMessage: \"\", signature: \"\" };\n}\nconst SignMessageResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.message !== \"\") {\n            writer.uint32(10).string(message.message);\n        }\n        if (message.hexEncodedMessage !== \"\") {\n            writer.uint32(18).string(message.hexEncodedMessage);\n        }\n        if (message.signature !== \"\") {\n            writer.uint32(26).string(message.signature);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignMessageResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                case 2:\n                    message.hexEncodedMessage = reader.string();\n                    break;\n                case 3:\n                    message.signature = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            message: isSet(object.message) ? String(object.message) : \"\",\n            hexEncodedMessage: isSet(object.hexEncodedMessage) ? String(object.hexEncodedMessage) : \"\",\n            signature: isSet(object.signature) ? String(object.signature) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.message !== undefined && (obj.message = message.message);\n        message.hexEncodedMessage !== undefined && (obj.hexEncodedMessage = message.hexEncodedMessage);\n        message.signature !== undefined && (obj.signature = message.signature);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseSignMessageResponse();\n        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : \"\";\n        message.hexEncodedMessage = (_b = object.hexEncodedMessage) !== null && _b !== void 0 ? _b : \"\";\n        message.signature = (_c = object.signature) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseConvertMessageToObjectRequest() {\n    return { message: \"\" };\n}\nconst ConvertMessageToObjectRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.message !== \"\") {\n            writer.uint32(10).string(message.message);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConvertMessageToObjectRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.message = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { message: isSet(object.message) ? String(object.message) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.message !== undefined && (obj.message = message.message);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseConvertMessageToObjectRequest();\n        message.message = (_a = object.message) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseConvertMessageToObjectResponse() {\n    return { dict: {} };\n}\nconst ConvertMessageToObjectResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        Object.entries(message.dict).forEach(([key, value]) => {\n            ConvertMessageToObjectResponse_DictEntry.encode({ key: key, value }, writer.uint32(10).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConvertMessageToObjectResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    const entry1 = ConvertMessageToObjectResponse_DictEntry.decode(reader, reader.uint32());\n                    if (entry1.value !== undefined) {\n                        message.dict[entry1.key] = entry1.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            dict: isObject(object.dict)\n                ? Object.entries(object.dict).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        obj.dict = {};\n        if (message.dict) {\n            Object.entries(message.dict).forEach(([k, v]) => {\n                obj.dict[k] = v;\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseConvertMessageToObjectResponse();\n        message.dict = Object.entries((_a = object.dict) !== null && _a !== void 0 ? _a : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseConvertMessageToObjectResponse_DictEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst ConvertMessageToObjectResponse_DictEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseConvertMessageToObjectResponse_DictEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseConvertMessageToObjectResponse_DictEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSendAsyncRequest() {\n    return { id: 0, method: \"\", jsonParams: \"\" };\n}\nconst SendAsyncRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.id !== 0) {\n            writer.uint32(8).int32(message.id);\n        }\n        if (message.method !== \"\") {\n            writer.uint32(18).string(message.method);\n        }\n        if (message.jsonParams !== \"\") {\n            writer.uint32(26).string(message.jsonParams);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendAsyncRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.int32();\n                    break;\n                case 2:\n                    message.method = reader.string();\n                    break;\n                case 3:\n                    message.jsonParams = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? Number(object.id) : 0,\n            method: isSet(object.method) ? String(object.method) : \"\",\n            jsonParams: isSet(object.jsonParams) ? String(object.jsonParams) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = Math.round(message.id));\n        message.method !== undefined && (obj.method = message.method);\n        message.jsonParams !== undefined && (obj.jsonParams = message.jsonParams);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseSendAsyncRequest();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : 0;\n        message.method = (_b = object.method) !== null && _b !== void 0 ? _b : \"\";\n        message.jsonParams = (_c = object.jsonParams) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBaseSendAsyncResponse() {\n    return { jsonAnyResponse: \"\" };\n}\nconst SendAsyncResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.jsonAnyResponse !== \"\") {\n            writer.uint32(10).string(message.jsonAnyResponse);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendAsyncResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.jsonAnyResponse = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { jsonAnyResponse: isSet(object.jsonAnyResponse) ? String(object.jsonAnyResponse) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.jsonAnyResponse !== undefined && (obj.jsonAnyResponse = message.jsonAnyResponse);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSendAsyncResponse();\n        message.jsonAnyResponse = (_a = object.jsonAnyResponse) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetUserAccountRequest() {\n    return {};\n}\nconst GetUserAccountRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetUserAccountRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetUserAccountRequest();\n        return message;\n    },\n};\nfunction createBaseGetUserAccountResponse() {\n    return { address: undefined };\n}\nconst GetUserAccountResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.address !== undefined) {\n            writer.uint32(10).string(message.address);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetUserAccountResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { address: isSet(object.address) ? String(object.address) : undefined };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetUserAccountResponse();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nconst EthereumControllerServiceDefinition = {\n    name: \"EthereumControllerService\",\n    fullName: \"EthereumControllerService\",\n    methods: {\n        requirePayment: {\n            name: \"RequirePayment\",\n            requestType: RequirePaymentRequest,\n            requestStream: false,\n            responseType: RequirePaymentResponse,\n            responseStream: false,\n            options: {},\n        },\n        signMessage: {\n            name: \"SignMessage\",\n            requestType: SignMessageRequest,\n            requestStream: false,\n            responseType: SignMessageResponse,\n            responseStream: false,\n            options: {},\n        },\n        convertMessageToObject: {\n            name: \"ConvertMessageToObject\",\n            requestType: ConvertMessageToObjectRequest,\n            requestStream: false,\n            responseType: ConvertMessageToObjectResponse,\n            responseStream: false,\n            options: {},\n        },\n        sendAsync: {\n            name: \"SendAsync\",\n            requestType: SendAsyncRequest,\n            requestStream: false,\n            responseType: SendAsyncResponse,\n            responseStream: false,\n            options: {},\n        },\n        getUserAccount: {\n            name: \"GetUserAccount\",\n            requestType: GetUserAccountRequest,\n            requestStream: false,\n            responseType: GetUserAccountResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/EthereumController.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/ExperimentalAPI.gen.ts":
/*!*********************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/ExperimentalAPI.gen.ts ***!
  \*********************************************************************/
/*! exports provided: protobufPackage, SendToRendererRequest, SendToResponse, MessageFromRendererRequest, MessageFromRendererResponse, ExperimentalAPIServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SendToRendererRequest\", function() { return SendToRendererRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SendToResponse\", function() { return SendToResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageFromRendererRequest\", function() { return MessageFromRendererRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MessageFromRendererResponse\", function() { return MessageFromRendererResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExperimentalAPIServiceDefinition\", function() { return ExperimentalAPIServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseSendToRendererRequest() {\n    return { data: new Uint8Array() };\n}\nconst SendToRendererRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.data.length !== 0) {\n            writer.uint32(10).bytes(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendToRendererRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = reader.bytes();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { data: isSet(object.data) ? bytesFromBase64(object.data) : new Uint8Array() };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.data !== undefined &&\n            (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSendToRendererRequest();\n        message.data = (_a = object.data) !== null && _a !== void 0 ? _a : new Uint8Array();\n        return message;\n    },\n};\nfunction createBaseSendToResponse() {\n    return {};\n}\nconst SendToResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSendToResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseSendToResponse();\n        return message;\n    },\n};\nfunction createBaseMessageFromRendererRequest() {\n    return {};\n}\nconst MessageFromRendererRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageFromRendererRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMessageFromRendererRequest();\n        return message;\n    },\n};\nfunction createBaseMessageFromRendererResponse() {\n    return { data: [] };\n}\nconst MessageFromRendererResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        for (const v of message.data) {\n            writer.uint32(10).bytes(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMessageFromRendererResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data.push(reader.bytes());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { data: Array.isArray(object === null || object === void 0 ? void 0 : object.data) ? object.data.map((e) => bytesFromBase64(e)) : [] };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.data) {\n            obj.data = message.data.map((e) => base64FromBytes(e !== undefined ? e : new Uint8Array()));\n        }\n        else {\n            obj.data = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseMessageFromRendererResponse();\n        message.data = ((_a = object.data) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nconst ExperimentalAPIServiceDefinition = {\n    name: \"ExperimentalAPIService\",\n    fullName: \"ExperimentalAPIService\",\n    methods: {\n        sendToRenderer: {\n            name: \"SendToRenderer\",\n            requestType: SendToRendererRequest,\n            requestStream: false,\n            responseType: SendToResponse,\n            responseStream: false,\n            options: {},\n        },\n        messageFromRenderer: {\n            name: \"MessageFromRenderer\",\n            requestType: MessageFromRendererRequest,\n            requestStream: false,\n            responseType: MessageFromRendererResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw \"Unable to locate global object\";\n})();\nfunction bytesFromBase64(b64) {\n    if (globalThis.Buffer) {\n        return Uint8Array.from(globalThis.Buffer.from(b64, \"base64\"));\n    }\n    else {\n        const bin = globalThis.atob(b64);\n        const arr = new Uint8Array(bin.length);\n        for (let i = 0; i < bin.length; ++i) {\n            arr[i] = bin.charCodeAt(i);\n        }\n        return arr;\n    }\n}\nfunction base64FromBytes(arr) {\n    if (globalThis.Buffer) {\n        return globalThis.Buffer.from(arr).toString(\"base64\");\n    }\n    else {\n        const bin = [];\n        arr.forEach((byte) => {\n            bin.push(String.fromCharCode(byte));\n        });\n        return globalThis.btoa(bin.join(\"\"));\n    }\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/ExperimentalAPI.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/ParcelIdentity.gen.ts":
/*!********************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/ParcelIdentity.gen.ts ***!
  \********************************************************************/
/*! exports provided: protobufPackage, MappingsResponse, Land, GetParcelRequest, GetParcelResponse, GetSceneIdRequest, GetSceneIdResponse, GetIsEmptyRequest, GetIsEmptyResponse, ParcelIdentityServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MappingsResponse\", function() { return MappingsResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Land\", function() { return Land; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetParcelRequest\", function() { return GetParcelRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetParcelResponse\", function() { return GetParcelResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetSceneIdRequest\", function() { return GetSceneIdRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetSceneIdResponse\", function() { return GetSceneIdResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetIsEmptyRequest\", function() { return GetIsEmptyRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetIsEmptyResponse\", function() { return GetIsEmptyResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ParcelIdentityServiceDefinition\", function() { return ParcelIdentityServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../common/ContentMapping.gen */ \"./packages/shared/protocol/common/ContentMapping.gen.ts\");\n\n\nconst protobufPackage = \"\";\nfunction createBaseMappingsResponse() {\n    return { parcelId: \"\", rootCid: \"\", contents: [] };\n}\nconst MappingsResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.parcelId !== \"\") {\n            writer.uint32(10).string(message.parcelId);\n        }\n        if (message.rootCid !== \"\") {\n            writer.uint32(18).string(message.rootCid);\n        }\n        for (const v of message.contents) {\n            _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMappingsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.parcelId = reader.string();\n                    break;\n                case 2:\n                    message.rootCid = reader.string();\n                    break;\n                case 3:\n                    message.contents.push(_common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            parcelId: isSet(object.parcelId) ? String(object.parcelId) : \"\",\n            rootCid: isSet(object.rootCid) ? String(object.rootCid) : \"\",\n            contents: Array.isArray(object === null || object === void 0 ? void 0 : object.contents) ? object.contents.map((e) => _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].fromJSON(e)) : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.parcelId !== undefined && (obj.parcelId = message.parcelId);\n        message.rootCid !== undefined && (obj.rootCid = message.rootCid);\n        if (message.contents) {\n            obj.contents = message.contents.map((e) => e ? _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].toJSON(e) : undefined);\n        }\n        else {\n            obj.contents = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseMappingsResponse();\n        message.parcelId = (_a = object.parcelId) !== null && _a !== void 0 ? _a : \"\";\n        message.rootCid = (_b = object.rootCid) !== null && _b !== void 0 ? _b : \"\";\n        message.contents = ((_c = object.contents) === null || _c === void 0 ? void 0 : _c.map((e) => _common_ContentMapping_gen__WEBPACK_IMPORTED_MODULE_1__[\"ContentMapping\"].fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseLand() {\n    return { sceneId: \"\", sceneJsonData: \"\", baseUrl: \"\", baseUrlBundles: \"\", mappingsResponse: undefined };\n}\nconst Land = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.sceneId !== \"\") {\n            writer.uint32(10).string(message.sceneId);\n        }\n        if (message.sceneJsonData !== \"\") {\n            writer.uint32(18).string(message.sceneJsonData);\n        }\n        if (message.baseUrl !== \"\") {\n            writer.uint32(26).string(message.baseUrl);\n        }\n        if (message.baseUrlBundles !== \"\") {\n            writer.uint32(34).string(message.baseUrlBundles);\n        }\n        if (message.mappingsResponse !== undefined) {\n            MappingsResponse.encode(message.mappingsResponse, writer.uint32(42).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseLand();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sceneId = reader.string();\n                    break;\n                case 2:\n                    message.sceneJsonData = reader.string();\n                    break;\n                case 3:\n                    message.baseUrl = reader.string();\n                    break;\n                case 4:\n                    message.baseUrlBundles = reader.string();\n                    break;\n                case 5:\n                    message.mappingsResponse = MappingsResponse.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sceneId: isSet(object.sceneId) ? String(object.sceneId) : \"\",\n            sceneJsonData: isSet(object.sceneJsonData) ? String(object.sceneJsonData) : \"\",\n            baseUrl: isSet(object.baseUrl) ? String(object.baseUrl) : \"\",\n            baseUrlBundles: isSet(object.baseUrlBundles) ? String(object.baseUrlBundles) : \"\",\n            mappingsResponse: isSet(object.mappingsResponse) ? MappingsResponse.fromJSON(object.mappingsResponse) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sceneId !== undefined && (obj.sceneId = message.sceneId);\n        message.sceneJsonData !== undefined && (obj.sceneJsonData = message.sceneJsonData);\n        message.baseUrl !== undefined && (obj.baseUrl = message.baseUrl);\n        message.baseUrlBundles !== undefined && (obj.baseUrlBundles = message.baseUrlBundles);\n        message.mappingsResponse !== undefined &&\n            (obj.mappingsResponse = message.mappingsResponse ? MappingsResponse.toJSON(message.mappingsResponse) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBaseLand();\n        message.sceneId = (_a = object.sceneId) !== null && _a !== void 0 ? _a : \"\";\n        message.sceneJsonData = (_b = object.sceneJsonData) !== null && _b !== void 0 ? _b : \"\";\n        message.baseUrl = (_c = object.baseUrl) !== null && _c !== void 0 ? _c : \"\";\n        message.baseUrlBundles = (_d = object.baseUrlBundles) !== null && _d !== void 0 ? _d : \"\";\n        message.mappingsResponse = (object.mappingsResponse !== undefined && object.mappingsResponse !== null)\n            ? MappingsResponse.fromPartial(object.mappingsResponse)\n            : undefined;\n        return message;\n    },\n};\nfunction createBaseGetParcelRequest() {\n    return {};\n}\nconst GetParcelRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetParcelRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetParcelRequest();\n        return message;\n    },\n};\nfunction createBaseGetParcelResponse() {\n    return { land: undefined, cid: \"\" };\n}\nconst GetParcelResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.land !== undefined) {\n            Land.encode(message.land, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.cid !== \"\") {\n            writer.uint32(18).string(message.cid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetParcelResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.land = Land.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.cid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            land: isSet(object.land) ? Land.fromJSON(object.land) : undefined,\n            cid: isSet(object.cid) ? String(object.cid) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.land !== undefined && (obj.land = message.land ? Land.toJSON(message.land) : undefined);\n        message.cid !== undefined && (obj.cid = message.cid);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetParcelResponse();\n        message.land = (object.land !== undefined && object.land !== null) ? Land.fromPartial(object.land) : undefined;\n        message.cid = (_a = object.cid) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetSceneIdRequest() {\n    return {};\n}\nconst GetSceneIdRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetSceneIdRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetSceneIdRequest();\n        return message;\n    },\n};\nfunction createBaseGetSceneIdResponse() {\n    return { sceneId: \"\" };\n}\nconst GetSceneIdResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.sceneId !== \"\") {\n            writer.uint32(10).string(message.sceneId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetSceneIdResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sceneId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { sceneId: isSet(object.sceneId) ? String(object.sceneId) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sceneId !== undefined && (obj.sceneId = message.sceneId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetSceneIdResponse();\n        message.sceneId = (_a = object.sceneId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetIsEmptyRequest() {\n    return {};\n}\nconst GetIsEmptyRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIsEmptyRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetIsEmptyRequest();\n        return message;\n    },\n};\nfunction createBaseGetIsEmptyResponse() {\n    return { isEmpty: false };\n}\nconst GetIsEmptyResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.isEmpty === true) {\n            writer.uint32(8).bool(message.isEmpty);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetIsEmptyResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.isEmpty = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { isEmpty: isSet(object.isEmpty) ? Boolean(object.isEmpty) : false };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.isEmpty !== undefined && (obj.isEmpty = message.isEmpty);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetIsEmptyResponse();\n        message.isEmpty = (_a = object.isEmpty) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nconst ParcelIdentityServiceDefinition = {\n    name: \"ParcelIdentityService\",\n    fullName: \"ParcelIdentityService\",\n    methods: {\n        getParcel: {\n            name: \"GetParcel\",\n            requestType: GetParcelRequest,\n            requestStream: false,\n            responseType: GetParcelResponse,\n            responseStream: false,\n            options: {},\n        },\n        getSceneId: {\n            name: \"GetSceneId\",\n            requestType: GetSceneIdRequest,\n            requestStream: false,\n            responseType: GetSceneIdResponse,\n            responseStream: false,\n            options: {},\n        },\n        getIsEmpty: {\n            name: \"GetIsEmpty\",\n            requestType: GetIsEmptyRequest,\n            requestStream: false,\n            responseType: GetIsEmptyResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/ParcelIdentity.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/Permissions.gen.ts":
/*!*****************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/Permissions.gen.ts ***!
  \*****************************************************************/
/*! exports provided: protobufPackage, PermissionItem, permissionItemFromJSON, permissionItemToJSON, PermissionResponse, HasPermissionRequest, HasManyPermissionRequest, HasManyPermissionResponse, PermissionsServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PermissionItem\", function() { return PermissionItem; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"permissionItemFromJSON\", function() { return permissionItemFromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"permissionItemToJSON\", function() { return permissionItemToJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PermissionResponse\", function() { return PermissionResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HasPermissionRequest\", function() { return HasPermissionRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HasManyPermissionRequest\", function() { return HasManyPermissionRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"HasManyPermissionResponse\", function() { return HasManyPermissionResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PermissionsServiceDefinition\", function() { return PermissionsServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nvar PermissionItem;\n(function (PermissionItem) {\n    PermissionItem[PermissionItem[\"ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE\"] = 0] = \"ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE\";\n    PermissionItem[PermissionItem[\"ALLOW_TO_TRIGGER_AVATAR_EMOTE\"] = 1] = \"ALLOW_TO_TRIGGER_AVATAR_EMOTE\";\n    PermissionItem[PermissionItem[\"USE_WEB3_API\"] = 2] = \"USE_WEB3_API\";\n    PermissionItem[PermissionItem[\"USE_WEBSOCKET\"] = 3] = \"USE_WEBSOCKET\";\n    PermissionItem[PermissionItem[\"USE_FETCH\"] = 4] = \"USE_FETCH\";\n    PermissionItem[PermissionItem[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(PermissionItem || (PermissionItem = {}));\nfunction permissionItemFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE\":\n            return PermissionItem.ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE;\n        case 1:\n        case \"ALLOW_TO_TRIGGER_AVATAR_EMOTE\":\n            return PermissionItem.ALLOW_TO_TRIGGER_AVATAR_EMOTE;\n        case 2:\n        case \"USE_WEB3_API\":\n            return PermissionItem.USE_WEB3_API;\n        case 3:\n        case \"USE_WEBSOCKET\":\n            return PermissionItem.USE_WEBSOCKET;\n        case 4:\n        case \"USE_FETCH\":\n            return PermissionItem.USE_FETCH;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return PermissionItem.UNRECOGNIZED;\n    }\n}\nfunction permissionItemToJSON(object) {\n    switch (object) {\n        case PermissionItem.ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE:\n            return \"ALLOW_TO_MOVE_PLAYER_INSIDE_SCENE\";\n        case PermissionItem.ALLOW_TO_TRIGGER_AVATAR_EMOTE:\n            return \"ALLOW_TO_TRIGGER_AVATAR_EMOTE\";\n        case PermissionItem.USE_WEB3_API:\n            return \"USE_WEB3_API\";\n        case PermissionItem.USE_WEBSOCKET:\n            return \"USE_WEBSOCKET\";\n        case PermissionItem.USE_FETCH:\n            return \"USE_FETCH\";\n        case PermissionItem.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBasePermissionResponse() {\n    return { hasPermission: false };\n}\nconst PermissionResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.hasPermission === true) {\n            writer.uint32(8).bool(message.hasPermission);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePermissionResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.hasPermission = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { hasPermission: isSet(object.hasPermission) ? Boolean(object.hasPermission) : false };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.hasPermission !== undefined && (obj.hasPermission = message.hasPermission);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePermissionResponse();\n        message.hasPermission = (_a = object.hasPermission) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nfunction createBaseHasPermissionRequest() {\n    return { permission: 0 };\n}\nconst HasPermissionRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.permission !== 0) {\n            writer.uint32(8).int32(message.permission);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHasPermissionRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.permission = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { permission: isSet(object.permission) ? permissionItemFromJSON(object.permission) : 0 };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.permission !== undefined && (obj.permission = permissionItemToJSON(message.permission));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseHasPermissionRequest();\n        message.permission = (_a = object.permission) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBaseHasManyPermissionRequest() {\n    return { permissions: [] };\n}\nconst HasManyPermissionRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        writer.uint32(10).fork();\n        for (const v of message.permissions) {\n            writer.int32(v);\n        }\n        writer.ldelim();\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHasManyPermissionRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.permissions.push(reader.int32());\n                        }\n                    }\n                    else {\n                        message.permissions.push(reader.int32());\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            permissions: Array.isArray(object === null || object === void 0 ? void 0 : object.permissions)\n                ? object.permissions.map((e) => permissionItemFromJSON(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.permissions) {\n            obj.permissions = message.permissions.map((e) => permissionItemToJSON(e));\n        }\n        else {\n            obj.permissions = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseHasManyPermissionRequest();\n        message.permissions = ((_a = object.permissions) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBaseHasManyPermissionResponse() {\n    return { hasManyPermission: [] };\n}\nconst HasManyPermissionResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        writer.uint32(10).fork();\n        for (const v of message.hasManyPermission) {\n            writer.bool(v);\n        }\n        writer.ldelim();\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseHasManyPermissionResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.hasManyPermission.push(reader.bool());\n                        }\n                    }\n                    else {\n                        message.hasManyPermission.push(reader.bool());\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            hasManyPermission: Array.isArray(object === null || object === void 0 ? void 0 : object.hasManyPermission)\n                ? object.hasManyPermission.map((e) => Boolean(e))\n                : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.hasManyPermission) {\n            obj.hasManyPermission = message.hasManyPermission.map((e) => e);\n        }\n        else {\n            obj.hasManyPermission = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseHasManyPermissionResponse();\n        message.hasManyPermission = ((_a = object.hasManyPermission) === null || _a === void 0 ? void 0 : _a.map((e) => e)) || [];\n        return message;\n    },\n};\nconst PermissionsServiceDefinition = {\n    name: \"PermissionsService\",\n    fullName: \"PermissionsService\",\n    methods: {\n        hasPermission: {\n            name: \"HasPermission\",\n            requestType: HasPermissionRequest,\n            requestStream: false,\n            responseType: PermissionResponse,\n            responseStream: false,\n            options: {},\n        },\n        hasManyPermissions: {\n            name: \"HasManyPermissions\",\n            requestType: HasManyPermissionRequest,\n            requestStream: false,\n            responseType: HasManyPermissionResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/Permissions.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/Players.gen.ts":
/*!*************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/Players.gen.ts ***!
  \*************************************************************/
/*! exports provided: protobufPackage, Player, PlayersGetUserDataResponse, PlayerListResponse, GetPlayerDataRequest, GetPlayersInSceneRequest, GetConnectedPlayersRequest, PlayersServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Player\", function() { return Player; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlayersGetUserDataResponse\", function() { return PlayersGetUserDataResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlayerListResponse\", function() { return PlayerListResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetPlayerDataRequest\", function() { return GetPlayerDataRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetPlayersInSceneRequest\", function() { return GetPlayersInSceneRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetConnectedPlayersRequest\", function() { return GetConnectedPlayersRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PlayersServiceDefinition\", function() { return PlayersServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common-sdk/UserData.gen */ \"./packages/shared/protocol/kernel/apis/common-sdk/UserData.gen.ts\");\n\n\nconst protobufPackage = \"\";\nfunction createBasePlayer() {\n    return { userId: \"\" };\n}\nconst Player = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.userId !== \"\") {\n            writer.uint32(10).string(message.userId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePlayer();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { userId: isSet(object.userId) ? String(object.userId) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.userId !== undefined && (obj.userId = message.userId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePlayer();\n        message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBasePlayersGetUserDataResponse() {\n    return { data: undefined };\n}\nconst PlayersGetUserDataResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.data !== undefined) {\n            _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].encode(message.data, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePlayersGetUserDataResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { data: isSet(object.data) ? _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].fromJSON(object.data) : undefined };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.data !== undefined && (obj.data = message.data ? _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].toJSON(message.data) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePlayersGetUserDataResponse();\n        message.data = (object.data !== undefined && object.data !== null) ? _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].fromPartial(object.data) : undefined;\n        return message;\n    },\n};\nfunction createBasePlayerListResponse() {\n    return { players: [] };\n}\nconst PlayerListResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        for (const v of message.players) {\n            Player.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePlayerListResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.players.push(Player.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { players: Array.isArray(object === null || object === void 0 ? void 0 : object.players) ? object.players.map((e) => Player.fromJSON(e)) : [] };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.players) {\n            obj.players = message.players.map((e) => e ? Player.toJSON(e) : undefined);\n        }\n        else {\n            obj.players = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePlayerListResponse();\n        message.players = ((_a = object.players) === null || _a === void 0 ? void 0 : _a.map((e) => Player.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseGetPlayerDataRequest() {\n    return { userId: \"\" };\n}\nconst GetPlayerDataRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.userId !== \"\") {\n            writer.uint32(10).string(message.userId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPlayerDataRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.userId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { userId: isSet(object.userId) ? String(object.userId) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.userId !== undefined && (obj.userId = message.userId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetPlayerDataRequest();\n        message.userId = (_a = object.userId) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetPlayersInSceneRequest() {\n    return {};\n}\nconst GetPlayersInSceneRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPlayersInSceneRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetPlayersInSceneRequest();\n        return message;\n    },\n};\nfunction createBaseGetConnectedPlayersRequest() {\n    return {};\n}\nconst GetConnectedPlayersRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetConnectedPlayersRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetConnectedPlayersRequest();\n        return message;\n    },\n};\nconst PlayersServiceDefinition = {\n    name: \"PlayersService\",\n    fullName: \"PlayersService\",\n    methods: {\n        getPlayerData: {\n            name: \"GetPlayerData\",\n            requestType: GetPlayerDataRequest,\n            requestStream: false,\n            responseType: PlayersGetUserDataResponse,\n            responseStream: false,\n            options: {},\n        },\n        getPlayersInScene: {\n            name: \"GetPlayersInScene\",\n            requestType: GetPlayersInSceneRequest,\n            requestStream: false,\n            responseType: PlayerListResponse,\n            responseStream: false,\n            options: {},\n        },\n        getConnectedPlayers: {\n            name: \"GetConnectedPlayers\",\n            requestType: GetConnectedPlayersRequest,\n            requestStream: false,\n            responseType: PlayerListResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/Players.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/PortableExperiences.gen.ts":
/*!*************************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/PortableExperiences.gen.ts ***!
  \*************************************************************************/
/*! exports provided: protobufPackage, KillRequest, KillResponse, SpawnRequest, SpawnResponse, PxRequest, GetPortableExperiencesLoadedRequest, GetPortableExperiencesLoadedResponse, ExitRequest, ExitResponse, PortableExperiencesServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KillRequest\", function() { return KillRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"KillResponse\", function() { return KillResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpawnRequest\", function() { return SpawnRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SpawnResponse\", function() { return SpawnResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PxRequest\", function() { return PxRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetPortableExperiencesLoadedRequest\", function() { return GetPortableExperiencesLoadedRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetPortableExperiencesLoadedResponse\", function() { return GetPortableExperiencesLoadedResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExitRequest\", function() { return ExitRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"ExitResponse\", function() { return ExitResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PortableExperiencesServiceDefinition\", function() { return PortableExperiencesServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseKillRequest() {\n    return { pid: \"\" };\n}\nconst KillRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.pid !== \"\") {\n            writer.uint32(10).string(message.pid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseKillRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { pid: isSet(object.pid) ? String(object.pid) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pid !== undefined && (obj.pid = message.pid);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseKillRequest();\n        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseKillResponse() {\n    return { status: false };\n}\nconst KillResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.status === true) {\n            writer.uint32(8).bool(message.status);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseKillResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.status = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { status: isSet(object.status) ? Boolean(object.status) : false };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.status !== undefined && (obj.status = message.status);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseKillResponse();\n        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nfunction createBaseSpawnRequest() {\n    return { pid: \"\" };\n}\nconst SpawnRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.pid !== \"\") {\n            writer.uint32(10).string(message.pid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSpawnRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { pid: isSet(object.pid) ? String(object.pid) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pid !== undefined && (obj.pid = message.pid);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSpawnRequest();\n        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseSpawnResponse() {\n    return { pid: \"\", parentCid: \"\" };\n}\nconst SpawnResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.pid !== \"\") {\n            writer.uint32(10).string(message.pid);\n        }\n        if (message.parentCid !== \"\") {\n            writer.uint32(18).string(message.parentCid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSpawnResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pid = reader.string();\n                    break;\n                case 2:\n                    message.parentCid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            pid: isSet(object.pid) ? String(object.pid) : \"\",\n            parentCid: isSet(object.parentCid) ? String(object.parentCid) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pid !== undefined && (obj.pid = message.pid);\n        message.parentCid !== undefined && (obj.parentCid = message.parentCid);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSpawnResponse();\n        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : \"\";\n        message.parentCid = (_b = object.parentCid) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePxRequest() {\n    return { pid: \"\" };\n}\nconst PxRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.pid !== \"\") {\n            writer.uint32(10).string(message.pid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePxRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.pid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { pid: isSet(object.pid) ? String(object.pid) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.pid !== undefined && (obj.pid = message.pid);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePxRequest();\n        message.pid = (_a = object.pid) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseGetPortableExperiencesLoadedRequest() {\n    return {};\n}\nconst GetPortableExperiencesLoadedRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPortableExperiencesLoadedRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetPortableExperiencesLoadedRequest();\n        return message;\n    },\n};\nfunction createBaseGetPortableExperiencesLoadedResponse() {\n    return { loaded: [] };\n}\nconst GetPortableExperiencesLoadedResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        for (const v of message.loaded) {\n            SpawnResponse.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetPortableExperiencesLoadedResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.loaded.push(SpawnResponse.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { loaded: Array.isArray(object === null || object === void 0 ? void 0 : object.loaded) ? object.loaded.map((e) => SpawnResponse.fromJSON(e)) : [] };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.loaded) {\n            obj.loaded = message.loaded.map((e) => e ? SpawnResponse.toJSON(e) : undefined);\n        }\n        else {\n            obj.loaded = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetPortableExperiencesLoadedResponse();\n        message.loaded = ((_a = object.loaded) === null || _a === void 0 ? void 0 : _a.map((e) => SpawnResponse.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBaseExitRequest() {\n    return {};\n}\nconst ExitRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseExitRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseExitRequest();\n        return message;\n    },\n};\nfunction createBaseExitResponse() {\n    return { status: false };\n}\nconst ExitResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.status === true) {\n            writer.uint32(8).bool(message.status);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseExitResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.status = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { status: isSet(object.status) ? Boolean(object.status) : false };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.status !== undefined && (obj.status = message.status);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseExitResponse();\n        message.status = (_a = object.status) !== null && _a !== void 0 ? _a : false;\n        return message;\n    },\n};\nconst PortableExperiencesServiceDefinition = {\n    name: \"PortableExperiencesService\",\n    fullName: \"PortableExperiencesService\",\n    methods: {\n        spawn: {\n            name: \"Spawn\",\n            requestType: SpawnRequest,\n            requestStream: false,\n            responseType: SpawnResponse,\n            responseStream: false,\n            options: {},\n        },\n        kill: {\n            name: \"Kill\",\n            requestType: KillRequest,\n            requestStream: false,\n            responseType: KillResponse,\n            responseStream: false,\n            options: {},\n        },\n        exit: {\n            name: \"Exit\",\n            requestType: ExitRequest,\n            requestStream: false,\n            responseType: ExitResponse,\n            responseStream: false,\n            options: {},\n        },\n        getPortableExperiencesLoaded: {\n            name: \"GetPortableExperiencesLoaded\",\n            requestType: GetPortableExperiencesLoadedRequest,\n            requestStream: false,\n            responseType: GetPortableExperiencesLoadedResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/PortableExperiences.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/RestrictedActions.gen.ts":
/*!***********************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/RestrictedActions.gen.ts ***!
  \***********************************************************************/
/*! exports provided: protobufPackage, Vector3, MovePlayerToResponse, MovePlayerToRequest, TriggerEmoteResponse, TriggerEmoteRequest, RestrictedActionsServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Vector3\", function() { return Vector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MovePlayerToResponse\", function() { return MovePlayerToResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"MovePlayerToRequest\", function() { return MovePlayerToRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriggerEmoteResponse\", function() { return TriggerEmoteResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"TriggerEmoteRequest\", function() { return TriggerEmoteRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RestrictedActionsServiceDefinition\", function() { return RestrictedActionsServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseVector3() {\n    return { x: 0, y: 0, z: 0 };\n}\nconst Vector3 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.x !== 0) {\n            writer.uint32(13).float(message.x);\n        }\n        if (message.y !== 0) {\n            writer.uint32(21).float(message.y);\n        }\n        if (message.z !== 0) {\n            writer.uint32(29).float(message.z);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseVector3();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                case 3:\n                    message.z = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            x: isSet(object.x) ? Number(object.x) : 0,\n            y: isSet(object.y) ? Number(object.y) : 0,\n            z: isSet(object.z) ? Number(object.z) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        message.z !== undefined && (obj.z = message.z);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseVector3();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : 0;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;\n        message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBaseMovePlayerToResponse() {\n    return {};\n}\nconst MovePlayerToResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMovePlayerToResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseMovePlayerToResponse();\n        return message;\n    },\n};\nfunction createBaseMovePlayerToRequest() {\n    return { newRelativePosition: undefined, cameraTarget: undefined };\n}\nconst MovePlayerToRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.newRelativePosition !== undefined) {\n            Vector3.encode(message.newRelativePosition, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.cameraTarget !== undefined) {\n            Vector3.encode(message.cameraTarget, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseMovePlayerToRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.newRelativePosition = Vector3.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.cameraTarget = Vector3.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            newRelativePosition: isSet(object.newRelativePosition) ? Vector3.fromJSON(object.newRelativePosition) : undefined,\n            cameraTarget: isSet(object.cameraTarget) ? Vector3.fromJSON(object.cameraTarget) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.newRelativePosition !== undefined &&\n            (obj.newRelativePosition = message.newRelativePosition ? Vector3.toJSON(message.newRelativePosition) : undefined);\n        message.cameraTarget !== undefined &&\n            (obj.cameraTarget = message.cameraTarget ? Vector3.toJSON(message.cameraTarget) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseMovePlayerToRequest();\n        message.newRelativePosition = (object.newRelativePosition !== undefined && object.newRelativePosition !== null)\n            ? Vector3.fromPartial(object.newRelativePosition)\n            : undefined;\n        message.cameraTarget = (object.cameraTarget !== undefined && object.cameraTarget !== null)\n            ? Vector3.fromPartial(object.cameraTarget)\n            : undefined;\n        return message;\n    },\n};\nfunction createBaseTriggerEmoteResponse() {\n    return {};\n}\nconst TriggerEmoteResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTriggerEmoteResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseTriggerEmoteResponse();\n        return message;\n    },\n};\nfunction createBaseTriggerEmoteRequest() {\n    return { predefinedEmote: \"\" };\n}\nconst TriggerEmoteRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.predefinedEmote !== \"\") {\n            writer.uint32(10).string(message.predefinedEmote);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseTriggerEmoteRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.predefinedEmote = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { predefinedEmote: isSet(object.predefinedEmote) ? String(object.predefinedEmote) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.predefinedEmote !== undefined && (obj.predefinedEmote = message.predefinedEmote);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseTriggerEmoteRequest();\n        message.predefinedEmote = (_a = object.predefinedEmote) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nconst RestrictedActionsServiceDefinition = {\n    name: \"RestrictedActionsService\",\n    fullName: \"RestrictedActionsService\",\n    methods: {\n        movePlayerTo: {\n            name: \"MovePlayerTo\",\n            requestType: MovePlayerToRequest,\n            requestStream: false,\n            responseType: MovePlayerToResponse,\n            responseStream: false,\n            options: {},\n        },\n        triggerEmote: {\n            name: \"TriggerEmote\",\n            requestType: TriggerEmoteRequest,\n            requestStream: false,\n            responseType: TriggerEmoteResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/RestrictedActions.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/SignedFetch.gen.ts":
/*!*****************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/SignedFetch.gen.ts ***!
  \*****************************************************************/
/*! exports provided: protobufPackage, FlatFetchInit, FlatFetchInit_HeadersEntry, FlatFetchResponse, FlatFetchResponse_HeadersEntry, SignedFetchRequest, SignedFetchServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlatFetchInit\", function() { return FlatFetchInit; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlatFetchInit_HeadersEntry\", function() { return FlatFetchInit_HeadersEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlatFetchResponse\", function() { return FlatFetchResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"FlatFetchResponse_HeadersEntry\", function() { return FlatFetchResponse_HeadersEntry; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignedFetchRequest\", function() { return SignedFetchRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SignedFetchServiceDefinition\", function() { return SignedFetchServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseFlatFetchInit() {\n    return { method: undefined, body: undefined, headers: {} };\n}\nconst FlatFetchInit = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.method !== undefined) {\n            writer.uint32(10).string(message.method);\n        }\n        if (message.body !== undefined) {\n            writer.uint32(18).string(message.body);\n        }\n        Object.entries(message.headers).forEach(([key, value]) => {\n            FlatFetchInit_HeadersEntry.encode({ key: key, value }, writer.uint32(26).fork()).ldelim();\n        });\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFlatFetchInit();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.method = reader.string();\n                    break;\n                case 2:\n                    message.body = reader.string();\n                    break;\n                case 3:\n                    const entry3 = FlatFetchInit_HeadersEntry.decode(reader, reader.uint32());\n                    if (entry3.value !== undefined) {\n                        message.headers[entry3.key] = entry3.value;\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            method: isSet(object.method) ? String(object.method) : undefined,\n            body: isSet(object.body) ? String(object.body) : undefined,\n            headers: isObject(object.headers)\n                ? Object.entries(object.headers).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.method !== undefined && (obj.method = message.method);\n        message.body !== undefined && (obj.body = message.body);\n        obj.headers = {};\n        if (message.headers) {\n            Object.entries(message.headers).forEach(([k, v]) => {\n                obj.headers[k] = v;\n            });\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBaseFlatFetchInit();\n        message.method = (_a = object.method) !== null && _a !== void 0 ? _a : undefined;\n        message.body = (_b = object.body) !== null && _b !== void 0 ? _b : undefined;\n        message.headers = Object.entries((_c = object.headers) !== null && _c !== void 0 ? _c : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        return message;\n    },\n};\nfunction createBaseFlatFetchInit_HeadersEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst FlatFetchInit_HeadersEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFlatFetchInit_HeadersEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseFlatFetchInit_HeadersEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseFlatFetchResponse() {\n    return { ok: false, status: 0, statusText: \"\", headers: {}, body: \"\" };\n}\nconst FlatFetchResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.ok === true) {\n            writer.uint32(8).bool(message.ok);\n        }\n        if (message.status !== 0) {\n            writer.uint32(16).int32(message.status);\n        }\n        if (message.statusText !== \"\") {\n            writer.uint32(26).string(message.statusText);\n        }\n        Object.entries(message.headers).forEach(([key, value]) => {\n            FlatFetchResponse_HeadersEntry.encode({ key: key, value }, writer.uint32(34).fork()).ldelim();\n        });\n        if (message.body !== \"\") {\n            writer.uint32(42).string(message.body);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFlatFetchResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.ok = reader.bool();\n                    break;\n                case 2:\n                    message.status = reader.int32();\n                    break;\n                case 3:\n                    message.statusText = reader.string();\n                    break;\n                case 4:\n                    const entry4 = FlatFetchResponse_HeadersEntry.decode(reader, reader.uint32());\n                    if (entry4.value !== undefined) {\n                        message.headers[entry4.key] = entry4.value;\n                    }\n                    break;\n                case 5:\n                    message.body = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            ok: isSet(object.ok) ? Boolean(object.ok) : false,\n            status: isSet(object.status) ? Number(object.status) : 0,\n            statusText: isSet(object.statusText) ? String(object.statusText) : \"\",\n            headers: isObject(object.headers)\n                ? Object.entries(object.headers).reduce((acc, [key, value]) => {\n                    acc[key] = String(value);\n                    return acc;\n                }, {})\n                : {},\n            body: isSet(object.body) ? String(object.body) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.ok !== undefined && (obj.ok = message.ok);\n        message.status !== undefined && (obj.status = Math.round(message.status));\n        message.statusText !== undefined && (obj.statusText = message.statusText);\n        obj.headers = {};\n        if (message.headers) {\n            Object.entries(message.headers).forEach(([k, v]) => {\n                obj.headers[k] = v;\n            });\n        }\n        message.body !== undefined && (obj.body = message.body);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBaseFlatFetchResponse();\n        message.ok = (_a = object.ok) !== null && _a !== void 0 ? _a : false;\n        message.status = (_b = object.status) !== null && _b !== void 0 ? _b : 0;\n        message.statusText = (_c = object.statusText) !== null && _c !== void 0 ? _c : \"\";\n        message.headers = Object.entries((_d = object.headers) !== null && _d !== void 0 ? _d : {}).reduce((acc, [key, value]) => {\n            if (value !== undefined) {\n                acc[key] = String(value);\n            }\n            return acc;\n        }, {});\n        message.body = (_e = object.body) !== null && _e !== void 0 ? _e : \"\";\n        return message;\n    },\n};\nfunction createBaseFlatFetchResponse_HeadersEntry() {\n    return { key: \"\", value: \"\" };\n}\nconst FlatFetchResponse_HeadersEntry = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.key !== \"\") {\n            writer.uint32(10).string(message.key);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseFlatFetchResponse_HeadersEntry();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.key = reader.string();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { key: isSet(object.key) ? String(object.key) : \"\", value: isSet(object.value) ? String(object.value) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.key !== undefined && (obj.key = message.key);\n        message.value !== undefined && (obj.value = message.value);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseFlatFetchResponse_HeadersEntry();\n        message.key = (_a = object.key) !== null && _a !== void 0 ? _a : \"\";\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseSignedFetchRequest() {\n    return { url: \"\", init: undefined };\n}\nconst SignedFetchRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.url !== \"\") {\n            writer.uint32(10).string(message.url);\n        }\n        if (message.init !== undefined) {\n            FlatFetchInit.encode(message.init, writer.uint32(18).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSignedFetchRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.url = reader.string();\n                    break;\n                case 2:\n                    message.init = FlatFetchInit.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            url: isSet(object.url) ? String(object.url) : \"\",\n            init: isSet(object.init) ? FlatFetchInit.fromJSON(object.init) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.url !== undefined && (obj.url = message.url);\n        message.init !== undefined && (obj.init = message.init ? FlatFetchInit.toJSON(message.init) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseSignedFetchRequest();\n        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : \"\";\n        message.init = (object.init !== undefined && object.init !== null)\n            ? FlatFetchInit.fromPartial(object.init)\n            : undefined;\n        return message;\n    },\n};\nconst SignedFetchServiceDefinition = {\n    name: \"SignedFetchService\",\n    fullName: \"SignedFetchService\",\n    methods: {\n        signedFetch: {\n            name: \"SignedFetch\",\n            requestType: SignedFetchRequest,\n            requestStream: false,\n            responseType: FlatFetchResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isObject(value) {\n    return typeof value === \"object\" && value !== null;\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/SignedFetch.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/SocialController.gen.ts":
/*!**********************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/SocialController.gen.ts ***!
  \**********************************************************************/
/*! exports provided: protobufPackage, InitRequest, SocialEvent, GetAvatarEventsResponse, SocialControllerServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"InitRequest\", function() { return InitRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SocialEvent\", function() { return SocialEvent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetAvatarEventsResponse\", function() { return GetAvatarEventsResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"SocialControllerServiceDefinition\", function() { return SocialControllerServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseInitRequest() {\n    return {};\n}\nconst InitRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseInitRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseInitRequest();\n        return message;\n    },\n};\nfunction createBaseSocialEvent() {\n    return { event: \"\", payload: \"\" };\n}\nconst SocialEvent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.event !== \"\") {\n            writer.uint32(10).string(message.event);\n        }\n        if (message.payload !== \"\") {\n            writer.uint32(18).string(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSocialEvent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.event = reader.string();\n                    break;\n                case 2:\n                    message.payload = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            event: isSet(object.event) ? String(object.event) : \"\",\n            payload: isSet(object.payload) ? String(object.payload) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.event !== undefined && (obj.event = message.event);\n        message.payload !== undefined && (obj.payload = message.payload);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSocialEvent();\n        message.event = (_a = object.event) !== null && _a !== void 0 ? _a : \"\";\n        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseGetAvatarEventsResponse() {\n    return { events: [] };\n}\nconst GetAvatarEventsResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        for (const v of message.events) {\n            SocialEvent.encode(v, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetAvatarEventsResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.events.push(SocialEvent.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { events: Array.isArray(object === null || object === void 0 ? void 0 : object.events) ? object.events.map((e) => SocialEvent.fromJSON(e)) : [] };\n    },\n    toJSON(message) {\n        const obj = {};\n        if (message.events) {\n            obj.events = message.events.map((e) => e ? SocialEvent.toJSON(e) : undefined);\n        }\n        else {\n            obj.events = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetAvatarEventsResponse();\n        message.events = ((_a = object.events) === null || _a === void 0 ? void 0 : _a.map((e) => SocialEvent.fromPartial(e))) || [];\n        return message;\n    },\n};\nconst SocialControllerServiceDefinition = {\n    name: \"SocialControllerService\",\n    fullName: \"SocialControllerService\",\n    methods: {\n        pullAvatarEvents: {\n            name: \"PullAvatarEvents\",\n            requestType: InitRequest,\n            requestStream: false,\n            responseType: GetAvatarEventsResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/SocialController.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/UserActionModule.gen.ts":
/*!**********************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/UserActionModule.gen.ts ***!
  \**********************************************************************/
/*! exports provided: protobufPackage, RequestTeleportRequest, RequestTeleportResponse, UserActionModuleServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RequestTeleportRequest\", function() { return RequestTeleportRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"RequestTeleportResponse\", function() { return RequestTeleportResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserActionModuleServiceDefinition\", function() { return UserActionModuleServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseRequestTeleportRequest() {\n    return { destination: \"\" };\n}\nconst RequestTeleportRequest = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.destination !== \"\") {\n            writer.uint32(10).string(message.destination);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRequestTeleportRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.destination = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { destination: isSet(object.destination) ? String(object.destination) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.destination !== undefined && (obj.destination = message.destination);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseRequestTeleportRequest();\n        message.destination = (_a = object.destination) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBaseRequestTeleportResponse() {\n    return {};\n}\nconst RequestTeleportResponse = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseRequestTeleportResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseRequestTeleportResponse();\n        return message;\n    },\n};\nconst UserActionModuleServiceDefinition = {\n    name: \"UserActionModuleService\",\n    fullName: \"UserActionModuleService\",\n    methods: {\n        requestTeleport: {\n            name: \"RequestTeleport\",\n            requestType: RequestTeleportRequest,\n            requestStream: false,\n            responseType: RequestTeleportResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/UserActionModule.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/UserIdentity.gen.ts":
/*!******************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/UserIdentity.gen.ts ***!
  \******************************************************************/
/*! exports provided: protobufPackage, GetUserDataRequest, GetUserDataResponse, GetUserPublicKeyRequest, GetUserPublicKeyResponse, UserIdentityServiceDefinition */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetUserDataRequest\", function() { return GetUserDataRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetUserDataResponse\", function() { return GetUserDataResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetUserPublicKeyRequest\", function() { return GetUserPublicKeyRequest; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"GetUserPublicKeyResponse\", function() { return GetUserPublicKeyResponse; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserIdentityServiceDefinition\", function() { return UserIdentityServiceDefinition; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./common-sdk/UserData.gen */ \"./packages/shared/protocol/kernel/apis/common-sdk/UserData.gen.ts\");\n\n\nconst protobufPackage = \"\";\nfunction createBaseGetUserDataRequest() {\n    return {};\n}\nconst GetUserDataRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetUserDataRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetUserDataRequest();\n        return message;\n    },\n};\nfunction createBaseGetUserDataResponse() {\n    return { data: undefined };\n}\nconst GetUserDataResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.data !== undefined) {\n            _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].encode(message.data, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetUserDataResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.data = _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { data: isSet(object.data) ? _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].fromJSON(object.data) : undefined };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.data !== undefined && (obj.data = message.data ? _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].toJSON(message.data) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBaseGetUserDataResponse();\n        message.data = (object.data !== undefined && object.data !== null) ? _common_sdk_UserData_gen__WEBPACK_IMPORTED_MODULE_1__[\"UserData\"].fromPartial(object.data) : undefined;\n        return message;\n    },\n};\nfunction createBaseGetUserPublicKeyRequest() {\n    return {};\n}\nconst GetUserPublicKeyRequest = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetUserPublicKeyRequest();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBaseGetUserPublicKeyRequest();\n        return message;\n    },\n};\nfunction createBaseGetUserPublicKeyResponse() {\n    return { address: undefined };\n}\nconst GetUserPublicKeyResponse = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.address !== undefined) {\n            writer.uint32(10).string(message.address);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseGetUserPublicKeyResponse();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.address = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { address: isSet(object.address) ? String(object.address) : undefined };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.address !== undefined && (obj.address = message.address);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBaseGetUserPublicKeyResponse();\n        message.address = (_a = object.address) !== null && _a !== void 0 ? _a : undefined;\n        return message;\n    },\n};\nconst UserIdentityServiceDefinition = {\n    name: \"UserIdentityService\",\n    fullName: \"UserIdentityService\",\n    methods: {\n        getUserPublicKey: {\n            name: \"GetUserPublicKey\",\n            requestType: GetUserPublicKeyRequest,\n            requestStream: false,\n            responseType: GetUserPublicKeyResponse,\n            responseStream: false,\n            options: {},\n        },\n        getUserData: {\n            name: \"GetUserData\",\n            requestType: GetUserDataRequest,\n            requestStream: false,\n            responseType: GetUserDataResponse,\n            responseStream: false,\n            options: {},\n        },\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/UserIdentity.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/kernel/apis/common-sdk/UserData.gen.ts":
/*!*************************************************************************!*\
  !*** ./packages/shared/protocol/kernel/apis/common-sdk/UserData.gen.ts ***!
  \*************************************************************************/
/*! exports provided: protobufPackage, Snapshots, AvatarForUserData, UserData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"Snapshots\", function() { return Snapshots; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"AvatarForUserData\", function() { return AvatarForUserData; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"UserData\", function() { return UserData; });\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0__);\n\nconst protobufPackage = \"\";\nfunction createBaseSnapshots() {\n    return { face256: \"\", body: \"\" };\n}\nconst Snapshots = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.face256 !== \"\") {\n            writer.uint32(10).string(message.face256);\n        }\n        if (message.body !== \"\") {\n            writer.uint32(18).string(message.body);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseSnapshots();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.face256 = reader.string();\n                    break;\n                case 2:\n                    message.body = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            face256: isSet(object.face256) ? String(object.face256) : \"\",\n            body: isSet(object.body) ? String(object.body) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.face256 !== undefined && (obj.face256 = message.face256);\n        message.body !== undefined && (obj.body = message.body);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBaseSnapshots();\n        message.face256 = (_a = object.face256) !== null && _a !== void 0 ? _a : \"\";\n        message.body = (_b = object.body) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBaseAvatarForUserData() {\n    return { bodyShape: \"\", skinColor: \"\", hairColor: \"\", eyeColor: \"\", wearables: [], snapshots: undefined };\n}\nconst AvatarForUserData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.bodyShape !== \"\") {\n            writer.uint32(10).string(message.bodyShape);\n        }\n        if (message.skinColor !== \"\") {\n            writer.uint32(18).string(message.skinColor);\n        }\n        if (message.hairColor !== \"\") {\n            writer.uint32(26).string(message.hairColor);\n        }\n        if (message.eyeColor !== \"\") {\n            writer.uint32(34).string(message.eyeColor);\n        }\n        for (const v of message.wearables) {\n            writer.uint32(42).string(v);\n        }\n        if (message.snapshots !== undefined) {\n            Snapshots.encode(message.snapshots, writer.uint32(50).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseAvatarForUserData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.bodyShape = reader.string();\n                    break;\n                case 2:\n                    message.skinColor = reader.string();\n                    break;\n                case 3:\n                    message.hairColor = reader.string();\n                    break;\n                case 4:\n                    message.eyeColor = reader.string();\n                    break;\n                case 5:\n                    message.wearables.push(reader.string());\n                    break;\n                case 6:\n                    message.snapshots = Snapshots.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            bodyShape: isSet(object.bodyShape) ? String(object.bodyShape) : \"\",\n            skinColor: isSet(object.skinColor) ? String(object.skinColor) : \"\",\n            hairColor: isSet(object.hairColor) ? String(object.hairColor) : \"\",\n            eyeColor: isSet(object.eyeColor) ? String(object.eyeColor) : \"\",\n            wearables: Array.isArray(object === null || object === void 0 ? void 0 : object.wearables) ? object.wearables.map((e) => String(e)) : [],\n            snapshots: isSet(object.snapshots) ? Snapshots.fromJSON(object.snapshots) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.bodyShape !== undefined && (obj.bodyShape = message.bodyShape);\n        message.skinColor !== undefined && (obj.skinColor = message.skinColor);\n        message.hairColor !== undefined && (obj.hairColor = message.hairColor);\n        message.eyeColor !== undefined && (obj.eyeColor = message.eyeColor);\n        if (message.wearables) {\n            obj.wearables = message.wearables.map((e) => e);\n        }\n        else {\n            obj.wearables = [];\n        }\n        message.snapshots !== undefined &&\n            (obj.snapshots = message.snapshots ? Snapshots.toJSON(message.snapshots) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBaseAvatarForUserData();\n        message.bodyShape = (_a = object.bodyShape) !== null && _a !== void 0 ? _a : \"\";\n        message.skinColor = (_b = object.skinColor) !== null && _b !== void 0 ? _b : \"\";\n        message.hairColor = (_c = object.hairColor) !== null && _c !== void 0 ? _c : \"\";\n        message.eyeColor = (_d = object.eyeColor) !== null && _d !== void 0 ? _d : \"\";\n        message.wearables = ((_e = object.wearables) === null || _e === void 0 ? void 0 : _e.map((e) => e)) || [];\n        message.snapshots = (object.snapshots !== undefined && object.snapshots !== null)\n            ? Snapshots.fromPartial(object.snapshots)\n            : undefined;\n        return message;\n    },\n};\nfunction createBaseUserData() {\n    return { displayName: \"\", publicKey: undefined, hasConnectedWeb3: false, userId: \"\", version: 0, avatar: undefined };\n}\nconst UserData = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Writer.create()) {\n        if (message.displayName !== \"\") {\n            writer.uint32(10).string(message.displayName);\n        }\n        if (message.publicKey !== undefined) {\n            writer.uint32(18).string(message.publicKey);\n        }\n        if (message.hasConnectedWeb3 === true) {\n            writer.uint32(24).bool(message.hasConnectedWeb3);\n        }\n        if (message.userId !== \"\") {\n            writer.uint32(34).string(message.userId);\n        }\n        if (message.version !== 0) {\n            writer.uint32(40).int32(message.version);\n        }\n        if (message.avatar !== undefined) {\n            AvatarForUserData.encode(message.avatar, writer.uint32(50).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_0___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBaseUserData();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.displayName = reader.string();\n                    break;\n                case 2:\n                    message.publicKey = reader.string();\n                    break;\n                case 3:\n                    message.hasConnectedWeb3 = reader.bool();\n                    break;\n                case 4:\n                    message.userId = reader.string();\n                    break;\n                case 5:\n                    message.version = reader.int32();\n                    break;\n                case 6:\n                    message.avatar = AvatarForUserData.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            displayName: isSet(object.displayName) ? String(object.displayName) : \"\",\n            publicKey: isSet(object.publicKey) ? String(object.publicKey) : undefined,\n            hasConnectedWeb3: isSet(object.hasConnectedWeb3) ? Boolean(object.hasConnectedWeb3) : false,\n            userId: isSet(object.userId) ? String(object.userId) : \"\",\n            version: isSet(object.version) ? Number(object.version) : 0,\n            avatar: isSet(object.avatar) ? AvatarForUserData.fromJSON(object.avatar) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.displayName !== undefined && (obj.displayName = message.displayName);\n        message.publicKey !== undefined && (obj.publicKey = message.publicKey);\n        message.hasConnectedWeb3 !== undefined && (obj.hasConnectedWeb3 = message.hasConnectedWeb3);\n        message.userId !== undefined && (obj.userId = message.userId);\n        message.version !== undefined && (obj.version = Math.round(message.version));\n        message.avatar !== undefined &&\n            (obj.avatar = message.avatar ? AvatarForUserData.toJSON(message.avatar) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBaseUserData();\n        message.displayName = (_a = object.displayName) !== null && _a !== void 0 ? _a : \"\";\n        message.publicKey = (_b = object.publicKey) !== null && _b !== void 0 ? _b : undefined;\n        message.hasConnectedWeb3 = (_c = object.hasConnectedWeb3) !== null && _c !== void 0 ? _c : false;\n        message.userId = (_d = object.userId) !== null && _d !== void 0 ? _d : \"\";\n        message.version = (_e = object.version) !== null && _e !== void 0 ? _e : 0;\n        message.avatar = (object.avatar !== undefined && object.avatar !== null)\n            ? AvatarForUserData.fromPartial(object.avatar)\n            : undefined;\n        return message;\n    },\n};\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/protocol/kernel/apis/common-sdk/UserData.gen.ts?");

/***/ }),

/***/ "./packages/shared/protocol/renderer-protocol/EngineInterface.gen.ts":
/*!***************************************************************************!*\
  !*** ./packages/shared/protocol/renderer-protocol/EngineInterface.gen.ts ***!
  \***************************************************************************/
/*! exports provided: protobufPackage, PBUIStackOrientation, pBUIStackOrientationFromJSON, pBUIStackOrientationToJSON, PBCreateEntity, PBRemoveEntity, PBSetEntityParent, PBComponentRemoved, PBComponent, PBColor4, PBColor3, PBTextShapeModel, PBVector3, PBQuaternion, PBTransform, PBUpdateEntityComponent, PBComponentCreated, PBAttachEntityComponent, PBComponentDisposed, PBComponentUpdated, PBRay, PBRayQuery, PBQuery, PBSendSceneMessage, PBSetPosition, PBContentMapping, PBPosition, PBLoadParcelScenes, PBCreateUIScene, PBUnloadScene, PBDclMessage, PBAnimationState, PBAnimator, PBAudioClip, PBAudioSource, PBAvatarShape, PBWearable, PBFace, PBEyes, PBHair, PBSkin, PBBasicMaterial, PBBillboard, PBBoxShape, PBCircleShape, PBConeShape, PBCylinderShape, PBGlobalPointerDown, PBGlobalPointerUp, PBGLTFShape, PBMaterial, PBNFTShape, PBOBJShape, PBPlaneShape, PBShape, PBSphereShape, PBTextShape, PBTexture, PBUIButton, PBUICanvas, PBUIContainerRect, PBUIContainerStack, PBUIImage, PBUUIDCallback, PBUIInputText, PBUIScrollRect, PBUIShape, PBUITextShape, PBOpenExternalUrl, PBOpenNFTDialog */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"protobufPackage\", function() { return protobufPackage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIStackOrientation\", function() { return PBUIStackOrientation; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pBUIStackOrientationFromJSON\", function() { return pBUIStackOrientationFromJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"pBUIStackOrientationToJSON\", function() { return pBUIStackOrientationToJSON; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBCreateEntity\", function() { return PBCreateEntity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBRemoveEntity\", function() { return PBRemoveEntity; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBSetEntityParent\", function() { return PBSetEntityParent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBComponentRemoved\", function() { return PBComponentRemoved; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBComponent\", function() { return PBComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBColor4\", function() { return PBColor4; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBColor3\", function() { return PBColor3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBTextShapeModel\", function() { return PBTextShapeModel; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBVector3\", function() { return PBVector3; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBQuaternion\", function() { return PBQuaternion; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBTransform\", function() { return PBTransform; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUpdateEntityComponent\", function() { return PBUpdateEntityComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBComponentCreated\", function() { return PBComponentCreated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBAttachEntityComponent\", function() { return PBAttachEntityComponent; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBComponentDisposed\", function() { return PBComponentDisposed; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBComponentUpdated\", function() { return PBComponentUpdated; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBRay\", function() { return PBRay; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBRayQuery\", function() { return PBRayQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBQuery\", function() { return PBQuery; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBSendSceneMessage\", function() { return PBSendSceneMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBSetPosition\", function() { return PBSetPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBContentMapping\", function() { return PBContentMapping; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBPosition\", function() { return PBPosition; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBLoadParcelScenes\", function() { return PBLoadParcelScenes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBCreateUIScene\", function() { return PBCreateUIScene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUnloadScene\", function() { return PBUnloadScene; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBDclMessage\", function() { return PBDclMessage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBAnimationState\", function() { return PBAnimationState; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBAnimator\", function() { return PBAnimator; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBAudioClip\", function() { return PBAudioClip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBAudioSource\", function() { return PBAudioSource; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBAvatarShape\", function() { return PBAvatarShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBWearable\", function() { return PBWearable; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBFace\", function() { return PBFace; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBEyes\", function() { return PBEyes; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBHair\", function() { return PBHair; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBSkin\", function() { return PBSkin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBBasicMaterial\", function() { return PBBasicMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBBillboard\", function() { return PBBillboard; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBBoxShape\", function() { return PBBoxShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBCircleShape\", function() { return PBCircleShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBConeShape\", function() { return PBConeShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBCylinderShape\", function() { return PBCylinderShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBGlobalPointerDown\", function() { return PBGlobalPointerDown; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBGlobalPointerUp\", function() { return PBGlobalPointerUp; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBGLTFShape\", function() { return PBGLTFShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBMaterial\", function() { return PBMaterial; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBNFTShape\", function() { return PBNFTShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBOBJShape\", function() { return PBOBJShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBPlaneShape\", function() { return PBPlaneShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBShape\", function() { return PBShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBSphereShape\", function() { return PBSphereShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBTextShape\", function() { return PBTextShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBTexture\", function() { return PBTexture; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIButton\", function() { return PBUIButton; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUICanvas\", function() { return PBUICanvas; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIContainerRect\", function() { return PBUIContainerRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIContainerStack\", function() { return PBUIContainerStack; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIImage\", function() { return PBUIImage; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUUIDCallback\", function() { return PBUUIDCallback; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIInputText\", function() { return PBUIInputText; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIScrollRect\", function() { return PBUIScrollRect; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUIShape\", function() { return PBUIShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBUITextShape\", function() { return PBUITextShape; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBOpenExternalUrl\", function() { return PBOpenExternalUrl; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"PBOpenNFTDialog\", function() { return PBOpenNFTDialog; });\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! long */ \"./node_modules/long/src/long.js\");\n/* harmony import */ var long__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(long__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! protobufjs/minimal */ \"./node_modules/protobufjs/minimal.js\");\n/* harmony import */ var protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../google/protobuf/empty.gen */ \"./packages/shared/protocol/google/protobuf/empty.gen.ts\");\n\n\n\nconst protobufPackage = \"engineinterface\";\nvar PBUIStackOrientation;\n(function (PBUIStackOrientation) {\n    PBUIStackOrientation[PBUIStackOrientation[\"VERTICAL\"] = 0] = \"VERTICAL\";\n    PBUIStackOrientation[PBUIStackOrientation[\"HORIZONTAL\"] = 1] = \"HORIZONTAL\";\n    PBUIStackOrientation[PBUIStackOrientation[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(PBUIStackOrientation || (PBUIStackOrientation = {}));\nfunction pBUIStackOrientationFromJSON(object) {\n    switch (object) {\n        case 0:\n        case \"VERTICAL\":\n            return PBUIStackOrientation.VERTICAL;\n        case 1:\n        case \"HORIZONTAL\":\n            return PBUIStackOrientation.HORIZONTAL;\n        case -1:\n        case \"UNRECOGNIZED\":\n        default:\n            return PBUIStackOrientation.UNRECOGNIZED;\n    }\n}\nfunction pBUIStackOrientationToJSON(object) {\n    switch (object) {\n        case PBUIStackOrientation.VERTICAL:\n            return \"VERTICAL\";\n        case PBUIStackOrientation.HORIZONTAL:\n            return \"HORIZONTAL\";\n        case PBUIStackOrientation.UNRECOGNIZED:\n        default:\n            return \"UNRECOGNIZED\";\n    }\n}\nfunction createBasePBCreateEntity() {\n    return { id: \"\" };\n}\nconst PBCreateEntity = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBCreateEntity();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePBCreateEntity();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBasePBRemoveEntity() {\n    return { id: \"\" };\n}\nconst PBRemoveEntity = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBRemoveEntity();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePBRemoveEntity();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBasePBSetEntityParent() {\n    return { entityId: \"\", parentId: \"\" };\n}\nconst PBSetEntityParent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.parentId !== \"\") {\n            writer.uint32(18).string(message.parentId);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBSetEntityParent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.parentId = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            parentId: isSet(object.parentId) ? String(object.parentId) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.parentId !== undefined && (obj.parentId = message.parentId);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBSetEntityParent();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.parentId = (_b = object.parentId) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePBComponentRemoved() {\n    return { entityId: \"\", name: \"\" };\n}\nconst PBComponentRemoved = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(18).string(message.name);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBComponentRemoved();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            name: isSet(object.name) ? String(object.name) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.name !== undefined && (obj.name = message.name);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBComponentRemoved();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePBComponent() {\n    return {\n        transform: undefined,\n        uuidCallback: undefined,\n        box: undefined,\n        sphere: undefined,\n        plane: undefined,\n        cone: undefined,\n        cylinder: undefined,\n        text: undefined,\n        nft: undefined,\n        containerRect: undefined,\n        containerStack: undefined,\n        uiTextShape: undefined,\n        uiInputTextShape: undefined,\n        uiImageShape: undefined,\n        circle: undefined,\n        billboard: undefined,\n        gltf: undefined,\n        obj: undefined,\n        avatar: undefined,\n        basicMaterial: undefined,\n        texture: undefined,\n        audioClip: undefined,\n        audioSource: undefined,\n    };\n}\nconst PBComponent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.transform !== undefined) {\n            PBTransform.encode(message.transform, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.uuidCallback !== undefined) {\n            PBUUIDCallback.encode(message.uuidCallback, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.box !== undefined) {\n            PBBoxShape.encode(message.box, writer.uint32(130).fork()).ldelim();\n        }\n        if (message.sphere !== undefined) {\n            PBSphereShape.encode(message.sphere, writer.uint32(138).fork()).ldelim();\n        }\n        if (message.plane !== undefined) {\n            PBPlaneShape.encode(message.plane, writer.uint32(146).fork()).ldelim();\n        }\n        if (message.cone !== undefined) {\n            PBConeShape.encode(message.cone, writer.uint32(154).fork()).ldelim();\n        }\n        if (message.cylinder !== undefined) {\n            PBCylinderShape.encode(message.cylinder, writer.uint32(162).fork()).ldelim();\n        }\n        if (message.text !== undefined) {\n            PBTextShape.encode(message.text, writer.uint32(170).fork()).ldelim();\n        }\n        if (message.nft !== undefined) {\n            PBNFTShape.encode(message.nft, writer.uint32(178).fork()).ldelim();\n        }\n        if (message.containerRect !== undefined) {\n            PBUIContainerRect.encode(message.containerRect, writer.uint32(202).fork()).ldelim();\n        }\n        if (message.containerStack !== undefined) {\n            PBUIContainerStack.encode(message.containerStack, writer.uint32(210).fork()).ldelim();\n        }\n        if (message.uiTextShape !== undefined) {\n            PBUITextShape.encode(message.uiTextShape, writer.uint32(218).fork()).ldelim();\n        }\n        if (message.uiInputTextShape !== undefined) {\n            PBUIInputText.encode(message.uiInputTextShape, writer.uint32(226).fork()).ldelim();\n        }\n        if (message.uiImageShape !== undefined) {\n            PBUIImage.encode(message.uiImageShape, writer.uint32(234).fork()).ldelim();\n        }\n        if (message.circle !== undefined) {\n            PBCircleShape.encode(message.circle, writer.uint32(250).fork()).ldelim();\n        }\n        if (message.billboard !== undefined) {\n            PBBillboard.encode(message.billboard, writer.uint32(258).fork()).ldelim();\n        }\n        if (message.gltf !== undefined) {\n            PBGLTFShape.encode(message.gltf, writer.uint32(434).fork()).ldelim();\n        }\n        if (message.obj !== undefined) {\n            PBOBJShape.encode(message.obj, writer.uint32(442).fork()).ldelim();\n        }\n        if (message.avatar !== undefined) {\n            PBAvatarShape.encode(message.avatar, writer.uint32(450).fork()).ldelim();\n        }\n        if (message.basicMaterial !== undefined) {\n            PBBasicMaterial.encode(message.basicMaterial, writer.uint32(514).fork()).ldelim();\n        }\n        if (message.texture !== undefined) {\n            PBTexture.encode(message.texture, writer.uint32(546).fork()).ldelim();\n        }\n        if (message.audioClip !== undefined) {\n            PBAudioClip.encode(message.audioClip, writer.uint32(1602).fork()).ldelim();\n        }\n        if (message.audioSource !== undefined) {\n            PBAudioSource.encode(message.audioSource, writer.uint32(1610).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBComponent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.transform = PBTransform.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.uuidCallback = PBUUIDCallback.decode(reader, reader.uint32());\n                    break;\n                case 16:\n                    message.box = PBBoxShape.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.sphere = PBSphereShape.decode(reader, reader.uint32());\n                    break;\n                case 18:\n                    message.plane = PBPlaneShape.decode(reader, reader.uint32());\n                    break;\n                case 19:\n                    message.cone = PBConeShape.decode(reader, reader.uint32());\n                    break;\n                case 20:\n                    message.cylinder = PBCylinderShape.decode(reader, reader.uint32());\n                    break;\n                case 21:\n                    message.text = PBTextShape.decode(reader, reader.uint32());\n                    break;\n                case 22:\n                    message.nft = PBNFTShape.decode(reader, reader.uint32());\n                    break;\n                case 25:\n                    message.containerRect = PBUIContainerRect.decode(reader, reader.uint32());\n                    break;\n                case 26:\n                    message.containerStack = PBUIContainerStack.decode(reader, reader.uint32());\n                    break;\n                case 27:\n                    message.uiTextShape = PBUITextShape.decode(reader, reader.uint32());\n                    break;\n                case 28:\n                    message.uiInputTextShape = PBUIInputText.decode(reader, reader.uint32());\n                    break;\n                case 29:\n                    message.uiImageShape = PBUIImage.decode(reader, reader.uint32());\n                    break;\n                case 31:\n                    message.circle = PBCircleShape.decode(reader, reader.uint32());\n                    break;\n                case 32:\n                    message.billboard = PBBillboard.decode(reader, reader.uint32());\n                    break;\n                case 54:\n                    message.gltf = PBGLTFShape.decode(reader, reader.uint32());\n                    break;\n                case 55:\n                    message.obj = PBOBJShape.decode(reader, reader.uint32());\n                    break;\n                case 56:\n                    message.avatar = PBAvatarShape.decode(reader, reader.uint32());\n                    break;\n                case 64:\n                    message.basicMaterial = PBBasicMaterial.decode(reader, reader.uint32());\n                    break;\n                case 68:\n                    message.texture = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 200:\n                    message.audioClip = PBAudioClip.decode(reader, reader.uint32());\n                    break;\n                case 201:\n                    message.audioSource = PBAudioSource.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            transform: isSet(object.transform) ? PBTransform.fromJSON(object.transform) : undefined,\n            uuidCallback: isSet(object.uuidCallback) ? PBUUIDCallback.fromJSON(object.uuidCallback) : undefined,\n            box: isSet(object.box) ? PBBoxShape.fromJSON(object.box) : undefined,\n            sphere: isSet(object.sphere) ? PBSphereShape.fromJSON(object.sphere) : undefined,\n            plane: isSet(object.plane) ? PBPlaneShape.fromJSON(object.plane) : undefined,\n            cone: isSet(object.cone) ? PBConeShape.fromJSON(object.cone) : undefined,\n            cylinder: isSet(object.cylinder) ? PBCylinderShape.fromJSON(object.cylinder) : undefined,\n            text: isSet(object.text) ? PBTextShape.fromJSON(object.text) : undefined,\n            nft: isSet(object.nft) ? PBNFTShape.fromJSON(object.nft) : undefined,\n            containerRect: isSet(object.containerRect) ? PBUIContainerRect.fromJSON(object.containerRect) : undefined,\n            containerStack: isSet(object.containerStack) ? PBUIContainerStack.fromJSON(object.containerStack) : undefined,\n            uiTextShape: isSet(object.uiTextShape) ? PBUITextShape.fromJSON(object.uiTextShape) : undefined,\n            uiInputTextShape: isSet(object.uiInputTextShape) ? PBUIInputText.fromJSON(object.uiInputTextShape) : undefined,\n            uiImageShape: isSet(object.uiImageShape) ? PBUIImage.fromJSON(object.uiImageShape) : undefined,\n            circle: isSet(object.circle) ? PBCircleShape.fromJSON(object.circle) : undefined,\n            billboard: isSet(object.billboard) ? PBBillboard.fromJSON(object.billboard) : undefined,\n            gltf: isSet(object.gltf) ? PBGLTFShape.fromJSON(object.gltf) : undefined,\n            obj: isSet(object.obj) ? PBOBJShape.fromJSON(object.obj) : undefined,\n            avatar: isSet(object.avatar) ? PBAvatarShape.fromJSON(object.avatar) : undefined,\n            basicMaterial: isSet(object.basicMaterial) ? PBBasicMaterial.fromJSON(object.basicMaterial) : undefined,\n            texture: isSet(object.texture) ? PBTexture.fromJSON(object.texture) : undefined,\n            audioClip: isSet(object.audioClip) ? PBAudioClip.fromJSON(object.audioClip) : undefined,\n            audioSource: isSet(object.audioSource) ? PBAudioSource.fromJSON(object.audioSource) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.transform !== undefined &&\n            (obj.transform = message.transform ? PBTransform.toJSON(message.transform) : undefined);\n        message.uuidCallback !== undefined &&\n            (obj.uuidCallback = message.uuidCallback ? PBUUIDCallback.toJSON(message.uuidCallback) : undefined);\n        message.box !== undefined && (obj.box = message.box ? PBBoxShape.toJSON(message.box) : undefined);\n        message.sphere !== undefined && (obj.sphere = message.sphere ? PBSphereShape.toJSON(message.sphere) : undefined);\n        message.plane !== undefined && (obj.plane = message.plane ? PBPlaneShape.toJSON(message.plane) : undefined);\n        message.cone !== undefined && (obj.cone = message.cone ? PBConeShape.toJSON(message.cone) : undefined);\n        message.cylinder !== undefined &&\n            (obj.cylinder = message.cylinder ? PBCylinderShape.toJSON(message.cylinder) : undefined);\n        message.text !== undefined && (obj.text = message.text ? PBTextShape.toJSON(message.text) : undefined);\n        message.nft !== undefined && (obj.nft = message.nft ? PBNFTShape.toJSON(message.nft) : undefined);\n        message.containerRect !== undefined &&\n            (obj.containerRect = message.containerRect ? PBUIContainerRect.toJSON(message.containerRect) : undefined);\n        message.containerStack !== undefined &&\n            (obj.containerStack = message.containerStack ? PBUIContainerStack.toJSON(message.containerStack) : undefined);\n        message.uiTextShape !== undefined &&\n            (obj.uiTextShape = message.uiTextShape ? PBUITextShape.toJSON(message.uiTextShape) : undefined);\n        message.uiInputTextShape !== undefined &&\n            (obj.uiInputTextShape = message.uiInputTextShape ? PBUIInputText.toJSON(message.uiInputTextShape) : undefined);\n        message.uiImageShape !== undefined &&\n            (obj.uiImageShape = message.uiImageShape ? PBUIImage.toJSON(message.uiImageShape) : undefined);\n        message.circle !== undefined && (obj.circle = message.circle ? PBCircleShape.toJSON(message.circle) : undefined);\n        message.billboard !== undefined &&\n            (obj.billboard = message.billboard ? PBBillboard.toJSON(message.billboard) : undefined);\n        message.gltf !== undefined && (obj.gltf = message.gltf ? PBGLTFShape.toJSON(message.gltf) : undefined);\n        message.obj !== undefined && (obj.obj = message.obj ? PBOBJShape.toJSON(message.obj) : undefined);\n        message.avatar !== undefined && (obj.avatar = message.avatar ? PBAvatarShape.toJSON(message.avatar) : undefined);\n        message.basicMaterial !== undefined &&\n            (obj.basicMaterial = message.basicMaterial ? PBBasicMaterial.toJSON(message.basicMaterial) : undefined);\n        message.texture !== undefined && (obj.texture = message.texture ? PBTexture.toJSON(message.texture) : undefined);\n        message.audioClip !== undefined &&\n            (obj.audioClip = message.audioClip ? PBAudioClip.toJSON(message.audioClip) : undefined);\n        message.audioSource !== undefined &&\n            (obj.audioSource = message.audioSource ? PBAudioSource.toJSON(message.audioSource) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePBComponent();\n        message.transform = (object.transform !== undefined && object.transform !== null)\n            ? PBTransform.fromPartial(object.transform)\n            : undefined;\n        message.uuidCallback = (object.uuidCallback !== undefined && object.uuidCallback !== null)\n            ? PBUUIDCallback.fromPartial(object.uuidCallback)\n            : undefined;\n        message.box = (object.box !== undefined && object.box !== null) ? PBBoxShape.fromPartial(object.box) : undefined;\n        message.sphere = (object.sphere !== undefined && object.sphere !== null)\n            ? PBSphereShape.fromPartial(object.sphere)\n            : undefined;\n        message.plane = (object.plane !== undefined && object.plane !== null)\n            ? PBPlaneShape.fromPartial(object.plane)\n            : undefined;\n        message.cone = (object.cone !== undefined && object.cone !== null)\n            ? PBConeShape.fromPartial(object.cone)\n            : undefined;\n        message.cylinder = (object.cylinder !== undefined && object.cylinder !== null)\n            ? PBCylinderShape.fromPartial(object.cylinder)\n            : undefined;\n        message.text = (object.text !== undefined && object.text !== null)\n            ? PBTextShape.fromPartial(object.text)\n            : undefined;\n        message.nft = (object.nft !== undefined && object.nft !== null) ? PBNFTShape.fromPartial(object.nft) : undefined;\n        message.containerRect = (object.containerRect !== undefined && object.containerRect !== null)\n            ? PBUIContainerRect.fromPartial(object.containerRect)\n            : undefined;\n        message.containerStack = (object.containerStack !== undefined && object.containerStack !== null)\n            ? PBUIContainerStack.fromPartial(object.containerStack)\n            : undefined;\n        message.uiTextShape = (object.uiTextShape !== undefined && object.uiTextShape !== null)\n            ? PBUITextShape.fromPartial(object.uiTextShape)\n            : undefined;\n        message.uiInputTextShape = (object.uiInputTextShape !== undefined && object.uiInputTextShape !== null)\n            ? PBUIInputText.fromPartial(object.uiInputTextShape)\n            : undefined;\n        message.uiImageShape = (object.uiImageShape !== undefined && object.uiImageShape !== null)\n            ? PBUIImage.fromPartial(object.uiImageShape)\n            : undefined;\n        message.circle = (object.circle !== undefined && object.circle !== null)\n            ? PBCircleShape.fromPartial(object.circle)\n            : undefined;\n        message.billboard = (object.billboard !== undefined && object.billboard !== null)\n            ? PBBillboard.fromPartial(object.billboard)\n            : undefined;\n        message.gltf = (object.gltf !== undefined && object.gltf !== null)\n            ? PBGLTFShape.fromPartial(object.gltf)\n            : undefined;\n        message.obj = (object.obj !== undefined && object.obj !== null) ? PBOBJShape.fromPartial(object.obj) : undefined;\n        message.avatar = (object.avatar !== undefined && object.avatar !== null)\n            ? PBAvatarShape.fromPartial(object.avatar)\n            : undefined;\n        message.basicMaterial = (object.basicMaterial !== undefined && object.basicMaterial !== null)\n            ? PBBasicMaterial.fromPartial(object.basicMaterial)\n            : undefined;\n        message.texture = (object.texture !== undefined && object.texture !== null)\n            ? PBTexture.fromPartial(object.texture)\n            : undefined;\n        message.audioClip = (object.audioClip !== undefined && object.audioClip !== null)\n            ? PBAudioClip.fromPartial(object.audioClip)\n            : undefined;\n        message.audioSource = (object.audioSource !== undefined && object.audioSource !== null)\n            ? PBAudioSource.fromPartial(object.audioSource)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBColor4() {\n    return { r: 0, g: 0, b: 0, a: 0 };\n}\nconst PBColor4 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.r !== 0) {\n            writer.uint32(13).float(message.r);\n        }\n        if (message.g !== 0) {\n            writer.uint32(21).float(message.g);\n        }\n        if (message.b !== 0) {\n            writer.uint32(29).float(message.b);\n        }\n        if (message.a !== 0) {\n            writer.uint32(37).float(message.a);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBColor4();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.r = reader.float();\n                    break;\n                case 2:\n                    message.g = reader.float();\n                    break;\n                case 3:\n                    message.b = reader.float();\n                    break;\n                case 4:\n                    message.a = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            r: isSet(object.r) ? Number(object.r) : 0,\n            g: isSet(object.g) ? Number(object.g) : 0,\n            b: isSet(object.b) ? Number(object.b) : 0,\n            a: isSet(object.a) ? Number(object.a) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.r !== undefined && (obj.r = message.r);\n        message.g !== undefined && (obj.g = message.g);\n        message.b !== undefined && (obj.b = message.b);\n        message.a !== undefined && (obj.a = message.a);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBasePBColor4();\n        message.r = (_a = object.r) !== null && _a !== void 0 ? _a : 0;\n        message.g = (_b = object.g) !== null && _b !== void 0 ? _b : 0;\n        message.b = (_c = object.b) !== null && _c !== void 0 ? _c : 0;\n        message.a = (_d = object.a) !== null && _d !== void 0 ? _d : 0;\n        return message;\n    },\n};\nfunction createBasePBColor3() {\n    return { r: 0, g: 0, b: 0 };\n}\nconst PBColor3 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.r !== 0) {\n            writer.uint32(13).float(message.r);\n        }\n        if (message.g !== 0) {\n            writer.uint32(21).float(message.g);\n        }\n        if (message.b !== 0) {\n            writer.uint32(29).float(message.b);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBColor3();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.r = reader.float();\n                    break;\n                case 2:\n                    message.g = reader.float();\n                    break;\n                case 3:\n                    message.b = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            r: isSet(object.r) ? Number(object.r) : 0,\n            g: isSet(object.g) ? Number(object.g) : 0,\n            b: isSet(object.b) ? Number(object.b) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.r !== undefined && (obj.r = message.r);\n        message.g !== undefined && (obj.g = message.g);\n        message.b !== undefined && (obj.b = message.b);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBColor3();\n        message.r = (_a = object.r) !== null && _a !== void 0 ? _a : 0;\n        message.g = (_b = object.g) !== null && _b !== void 0 ? _b : 0;\n        message.b = (_c = object.b) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBasePBTextShapeModel() {\n    return {\n        billboard: false,\n        value: \"\",\n        color: undefined,\n        opacity: 0,\n        fontSize: 0,\n        fontAutoSize: false,\n        fontWeight: \"\",\n        hTextAlign: \"\",\n        vTextAlign: \"\",\n        width: 0,\n        height: 0,\n        adaptWidth: false,\n        adaptHeight: false,\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        lineSpacing: 0,\n        lineCount: 0,\n        textWrapping: false,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        shadowColor: undefined,\n        outlineWidth: 0,\n        outlineColor: undefined,\n    };\n}\nconst PBTextShapeModel = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.billboard === true) {\n            writer.uint32(8).bool(message.billboard);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(18).string(message.value);\n        }\n        if (message.color !== undefined) {\n            PBColor3.encode(message.color, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(37).float(message.opacity);\n        }\n        if (message.fontSize !== 0) {\n            writer.uint32(45).float(message.fontSize);\n        }\n        if (message.fontAutoSize === true) {\n            writer.uint32(48).bool(message.fontAutoSize);\n        }\n        if (message.fontWeight !== \"\") {\n            writer.uint32(58).string(message.fontWeight);\n        }\n        if (message.hTextAlign !== \"\") {\n            writer.uint32(66).string(message.hTextAlign);\n        }\n        if (message.vTextAlign !== \"\") {\n            writer.uint32(74).string(message.vTextAlign);\n        }\n        if (message.width !== 0) {\n            writer.uint32(85).float(message.width);\n        }\n        if (message.height !== 0) {\n            writer.uint32(93).float(message.height);\n        }\n        if (message.adaptWidth === true) {\n            writer.uint32(96).bool(message.adaptWidth);\n        }\n        if (message.adaptHeight === true) {\n            writer.uint32(104).bool(message.adaptHeight);\n        }\n        if (message.paddingTop !== 0) {\n            writer.uint32(117).float(message.paddingTop);\n        }\n        if (message.paddingRight !== 0) {\n            writer.uint32(125).float(message.paddingRight);\n        }\n        if (message.paddingBottom !== 0) {\n            writer.uint32(133).float(message.paddingBottom);\n        }\n        if (message.paddingLeft !== 0) {\n            writer.uint32(141).float(message.paddingLeft);\n        }\n        if (message.lineSpacing !== 0) {\n            writer.uint32(149).float(message.lineSpacing);\n        }\n        if (message.lineCount !== 0) {\n            writer.uint32(152).int32(message.lineCount);\n        }\n        if (message.textWrapping === true) {\n            writer.uint32(160).bool(message.textWrapping);\n        }\n        if (message.shadowBlur !== 0) {\n            writer.uint32(173).float(message.shadowBlur);\n        }\n        if (message.shadowOffsetX !== 0) {\n            writer.uint32(181).float(message.shadowOffsetX);\n        }\n        if (message.shadowOffsetY !== 0) {\n            writer.uint32(189).float(message.shadowOffsetY);\n        }\n        if (message.shadowColor !== undefined) {\n            PBColor3.encode(message.shadowColor, writer.uint32(194).fork()).ldelim();\n        }\n        if (message.outlineWidth !== 0) {\n            writer.uint32(205).float(message.outlineWidth);\n        }\n        if (message.outlineColor !== undefined) {\n            PBColor3.encode(message.outlineColor, writer.uint32(210).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBTextShapeModel();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.billboard = reader.bool();\n                    break;\n                case 2:\n                    message.value = reader.string();\n                    break;\n                case 3:\n                    message.color = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.opacity = reader.float();\n                    break;\n                case 5:\n                    message.fontSize = reader.float();\n                    break;\n                case 6:\n                    message.fontAutoSize = reader.bool();\n                    break;\n                case 7:\n                    message.fontWeight = reader.string();\n                    break;\n                case 8:\n                    message.hTextAlign = reader.string();\n                    break;\n                case 9:\n                    message.vTextAlign = reader.string();\n                    break;\n                case 10:\n                    message.width = reader.float();\n                    break;\n                case 11:\n                    message.height = reader.float();\n                    break;\n                case 12:\n                    message.adaptWidth = reader.bool();\n                    break;\n                case 13:\n                    message.adaptHeight = reader.bool();\n                    break;\n                case 14:\n                    message.paddingTop = reader.float();\n                    break;\n                case 15:\n                    message.paddingRight = reader.float();\n                    break;\n                case 16:\n                    message.paddingBottom = reader.float();\n                    break;\n                case 17:\n                    message.paddingLeft = reader.float();\n                    break;\n                case 18:\n                    message.lineSpacing = reader.float();\n                    break;\n                case 19:\n                    message.lineCount = reader.int32();\n                    break;\n                case 20:\n                    message.textWrapping = reader.bool();\n                    break;\n                case 21:\n                    message.shadowBlur = reader.float();\n                    break;\n                case 22:\n                    message.shadowOffsetX = reader.float();\n                    break;\n                case 23:\n                    message.shadowOffsetY = reader.float();\n                    break;\n                case 24:\n                    message.shadowColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 25:\n                    message.outlineWidth = reader.float();\n                    break;\n                case 26:\n                    message.outlineColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            billboard: isSet(object.billboard) ? Boolean(object.billboard) : false,\n            value: isSet(object.value) ? String(object.value) : \"\",\n            color: isSet(object.color) ? PBColor3.fromJSON(object.color) : undefined,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            fontSize: isSet(object.fontSize) ? Number(object.fontSize) : 0,\n            fontAutoSize: isSet(object.fontAutoSize) ? Boolean(object.fontAutoSize) : false,\n            fontWeight: isSet(object.fontWeight) ? String(object.fontWeight) : \"\",\n            hTextAlign: isSet(object.hTextAlign) ? String(object.hTextAlign) : \"\",\n            vTextAlign: isSet(object.vTextAlign) ? String(object.vTextAlign) : \"\",\n            width: isSet(object.width) ? Number(object.width) : 0,\n            height: isSet(object.height) ? Number(object.height) : 0,\n            adaptWidth: isSet(object.adaptWidth) ? Boolean(object.adaptWidth) : false,\n            adaptHeight: isSet(object.adaptHeight) ? Boolean(object.adaptHeight) : false,\n            paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : 0,\n            paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : 0,\n            paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : 0,\n            paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : 0,\n            lineSpacing: isSet(object.lineSpacing) ? Number(object.lineSpacing) : 0,\n            lineCount: isSet(object.lineCount) ? Number(object.lineCount) : 0,\n            textWrapping: isSet(object.textWrapping) ? Boolean(object.textWrapping) : false,\n            shadowBlur: isSet(object.shadowBlur) ? Number(object.shadowBlur) : 0,\n            shadowOffsetX: isSet(object.shadowOffsetX) ? Number(object.shadowOffsetX) : 0,\n            shadowOffsetY: isSet(object.shadowOffsetY) ? Number(object.shadowOffsetY) : 0,\n            shadowColor: isSet(object.shadowColor) ? PBColor3.fromJSON(object.shadowColor) : undefined,\n            outlineWidth: isSet(object.outlineWidth) ? Number(object.outlineWidth) : 0,\n            outlineColor: isSet(object.outlineColor) ? PBColor3.fromJSON(object.outlineColor) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.billboard !== undefined && (obj.billboard = message.billboard);\n        message.value !== undefined && (obj.value = message.value);\n        message.color !== undefined && (obj.color = message.color ? PBColor3.toJSON(message.color) : undefined);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.fontSize !== undefined && (obj.fontSize = message.fontSize);\n        message.fontAutoSize !== undefined && (obj.fontAutoSize = message.fontAutoSize);\n        message.fontWeight !== undefined && (obj.fontWeight = message.fontWeight);\n        message.hTextAlign !== undefined && (obj.hTextAlign = message.hTextAlign);\n        message.vTextAlign !== undefined && (obj.vTextAlign = message.vTextAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.adaptWidth !== undefined && (obj.adaptWidth = message.adaptWidth);\n        message.adaptHeight !== undefined && (obj.adaptHeight = message.adaptHeight);\n        message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);\n        message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);\n        message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);\n        message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);\n        message.lineSpacing !== undefined && (obj.lineSpacing = message.lineSpacing);\n        message.lineCount !== undefined && (obj.lineCount = Math.round(message.lineCount));\n        message.textWrapping !== undefined && (obj.textWrapping = message.textWrapping);\n        message.shadowBlur !== undefined && (obj.shadowBlur = message.shadowBlur);\n        message.shadowOffsetX !== undefined && (obj.shadowOffsetX = message.shadowOffsetX);\n        message.shadowOffsetY !== undefined && (obj.shadowOffsetY = message.shadowOffsetY);\n        message.shadowColor !== undefined &&\n            (obj.shadowColor = message.shadowColor ? PBColor3.toJSON(message.shadowColor) : undefined);\n        message.outlineWidth !== undefined && (obj.outlineWidth = message.outlineWidth);\n        message.outlineColor !== undefined &&\n            (obj.outlineColor = message.outlineColor ? PBColor3.toJSON(message.outlineColor) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y;\n        const message = createBasePBTextShapeModel();\n        message.billboard = (_a = object.billboard) !== null && _a !== void 0 ? _a : false;\n        message.value = (_b = object.value) !== null && _b !== void 0 ? _b : \"\";\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor3.fromPartial(object.color)\n            : undefined;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.fontSize = (_d = object.fontSize) !== null && _d !== void 0 ? _d : 0;\n        message.fontAutoSize = (_e = object.fontAutoSize) !== null && _e !== void 0 ? _e : false;\n        message.fontWeight = (_f = object.fontWeight) !== null && _f !== void 0 ? _f : \"\";\n        message.hTextAlign = (_g = object.hTextAlign) !== null && _g !== void 0 ? _g : \"\";\n        message.vTextAlign = (_h = object.vTextAlign) !== null && _h !== void 0 ? _h : \"\";\n        message.width = (_j = object.width) !== null && _j !== void 0 ? _j : 0;\n        message.height = (_k = object.height) !== null && _k !== void 0 ? _k : 0;\n        message.adaptWidth = (_l = object.adaptWidth) !== null && _l !== void 0 ? _l : false;\n        message.adaptHeight = (_m = object.adaptHeight) !== null && _m !== void 0 ? _m : false;\n        message.paddingTop = (_o = object.paddingTop) !== null && _o !== void 0 ? _o : 0;\n        message.paddingRight = (_p = object.paddingRight) !== null && _p !== void 0 ? _p : 0;\n        message.paddingBottom = (_q = object.paddingBottom) !== null && _q !== void 0 ? _q : 0;\n        message.paddingLeft = (_r = object.paddingLeft) !== null && _r !== void 0 ? _r : 0;\n        message.lineSpacing = (_s = object.lineSpacing) !== null && _s !== void 0 ? _s : 0;\n        message.lineCount = (_t = object.lineCount) !== null && _t !== void 0 ? _t : 0;\n        message.textWrapping = (_u = object.textWrapping) !== null && _u !== void 0 ? _u : false;\n        message.shadowBlur = (_v = object.shadowBlur) !== null && _v !== void 0 ? _v : 0;\n        message.shadowOffsetX = (_w = object.shadowOffsetX) !== null && _w !== void 0 ? _w : 0;\n        message.shadowOffsetY = (_x = object.shadowOffsetY) !== null && _x !== void 0 ? _x : 0;\n        message.shadowColor = (object.shadowColor !== undefined && object.shadowColor !== null)\n            ? PBColor3.fromPartial(object.shadowColor)\n            : undefined;\n        message.outlineWidth = (_y = object.outlineWidth) !== null && _y !== void 0 ? _y : 0;\n        message.outlineColor = (object.outlineColor !== undefined && object.outlineColor !== null)\n            ? PBColor3.fromPartial(object.outlineColor)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBVector3() {\n    return { x: 0, y: 0, z: 0 };\n}\nconst PBVector3 = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.x !== 0) {\n            writer.uint32(13).float(message.x);\n        }\n        if (message.y !== 0) {\n            writer.uint32(21).float(message.y);\n        }\n        if (message.z !== 0) {\n            writer.uint32(29).float(message.z);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBVector3();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                case 3:\n                    message.z = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            x: isSet(object.x) ? Number(object.x) : 0,\n            y: isSet(object.y) ? Number(object.y) : 0,\n            z: isSet(object.z) ? Number(object.z) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        message.z !== undefined && (obj.z = message.z);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBVector3();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : 0;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;\n        message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBasePBQuaternion() {\n    return { x: 0, y: 0, z: 0, w: 0 };\n}\nconst PBQuaternion = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.x !== 0) {\n            writer.uint32(9).double(message.x);\n        }\n        if (message.y !== 0) {\n            writer.uint32(17).double(message.y);\n        }\n        if (message.z !== 0) {\n            writer.uint32(25).double(message.z);\n        }\n        if (message.w !== 0) {\n            writer.uint32(33).double(message.w);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBQuaternion();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.double();\n                    break;\n                case 2:\n                    message.y = reader.double();\n                    break;\n                case 3:\n                    message.z = reader.double();\n                    break;\n                case 4:\n                    message.w = reader.double();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            x: isSet(object.x) ? Number(object.x) : 0,\n            y: isSet(object.y) ? Number(object.y) : 0,\n            z: isSet(object.z) ? Number(object.z) : 0,\n            w: isSet(object.w) ? Number(object.w) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        message.z !== undefined && (obj.z = message.z);\n        message.w !== undefined && (obj.w = message.w);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBasePBQuaternion();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : 0;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;\n        message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;\n        message.w = (_d = object.w) !== null && _d !== void 0 ? _d : 0;\n        return message;\n    },\n};\nfunction createBasePBTransform() {\n    return { position: undefined, rotation: undefined, scale: undefined };\n}\nconst PBTransform = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.position !== undefined) {\n            PBVector3.encode(message.position, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.rotation !== undefined) {\n            PBQuaternion.encode(message.rotation, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.scale !== undefined) {\n            PBVector3.encode(message.scale, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBTransform();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.position = PBVector3.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.rotation = PBQuaternion.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.scale = PBVector3.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            position: isSet(object.position) ? PBVector3.fromJSON(object.position) : undefined,\n            rotation: isSet(object.rotation) ? PBQuaternion.fromJSON(object.rotation) : undefined,\n            scale: isSet(object.scale) ? PBVector3.fromJSON(object.scale) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.position !== undefined &&\n            (obj.position = message.position ? PBVector3.toJSON(message.position) : undefined);\n        message.rotation !== undefined &&\n            (obj.rotation = message.rotation ? PBQuaternion.toJSON(message.rotation) : undefined);\n        message.scale !== undefined && (obj.scale = message.scale ? PBVector3.toJSON(message.scale) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePBTransform();\n        message.position = (object.position !== undefined && object.position !== null)\n            ? PBVector3.fromPartial(object.position)\n            : undefined;\n        message.rotation = (object.rotation !== undefined && object.rotation !== null)\n            ? PBQuaternion.fromPartial(object.rotation)\n            : undefined;\n        message.scale = (object.scale !== undefined && object.scale !== null)\n            ? PBVector3.fromPartial(object.scale)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBUpdateEntityComponent() {\n    return { entityId: \"\", classId: 0, name: \"\", data: \"\" };\n}\nconst PBUpdateEntityComponent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.classId !== 0) {\n            writer.uint32(16).int32(message.classId);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(26).string(message.name);\n        }\n        if (message.data !== \"\") {\n            writer.uint32(34).string(message.data);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUpdateEntityComponent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.classId = reader.int32();\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                case 4:\n                    message.data = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            classId: isSet(object.classId) ? Number(object.classId) : 0,\n            name: isSet(object.name) ? String(object.name) : \"\",\n            data: isSet(object.data) ? String(object.data) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.classId !== undefined && (obj.classId = Math.round(message.classId));\n        message.name !== undefined && (obj.name = message.name);\n        message.data !== undefined && (obj.data = message.data);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBasePBUpdateEntityComponent();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.classId = (_b = object.classId) !== null && _b !== void 0 ? _b : 0;\n        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : \"\";\n        message.data = (_d = object.data) !== null && _d !== void 0 ? _d : \"\";\n        return message;\n    },\n};\nfunction createBasePBComponentCreated() {\n    return { id: \"\", classid: 0, name: \"\" };\n}\nconst PBComponentCreated = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.classid !== 0) {\n            writer.uint32(16).int32(message.classid);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(26).string(message.name);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBComponentCreated();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.classid = reader.int32();\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            classid: isSet(object.classid) ? Number(object.classid) : 0,\n            name: isSet(object.name) ? String(object.name) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.classid !== undefined && (obj.classid = Math.round(message.classid));\n        message.name !== undefined && (obj.name = message.name);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBComponentCreated();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.classid = (_b = object.classid) !== null && _b !== void 0 ? _b : 0;\n        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBasePBAttachEntityComponent() {\n    return { entityId: \"\", name: \"\", id: \"\" };\n}\nconst PBAttachEntityComponent = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.entityId !== \"\") {\n            writer.uint32(10).string(message.entityId);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(18).string(message.name);\n        }\n        if (message.id !== \"\") {\n            writer.uint32(26).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBAttachEntityComponent();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.entityId = reader.string();\n                    break;\n                case 2:\n                    message.name = reader.string();\n                    break;\n                case 3:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            entityId: isSet(object.entityId) ? String(object.entityId) : \"\",\n            name: isSet(object.name) ? String(object.name) : \"\",\n            id: isSet(object.id) ? String(object.id) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.entityId !== undefined && (obj.entityId = message.entityId);\n        message.name !== undefined && (obj.name = message.name);\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBAttachEntityComponent();\n        message.entityId = (_a = object.entityId) !== null && _a !== void 0 ? _a : \"\";\n        message.name = (_b = object.name) !== null && _b !== void 0 ? _b : \"\";\n        message.id = (_c = object.id) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBasePBComponentDisposed() {\n    return { id: \"\" };\n}\nconst PBComponentDisposed = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBComponentDisposed();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePBComponentDisposed();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBasePBComponentUpdated() {\n    return { id: \"\", json: \"\" };\n}\nconst PBComponentUpdated = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.json !== \"\") {\n            writer.uint32(18).string(message.json);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBComponentUpdated();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.json = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { id: isSet(object.id) ? String(object.id) : \"\", json: isSet(object.json) ? String(object.json) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.json !== undefined && (obj.json = message.json);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBComponentUpdated();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.json = (_b = object.json) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePBRay() {\n    return { origin: undefined, direction: undefined, distance: 0 };\n}\nconst PBRay = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.origin !== undefined) {\n            PBVector3.encode(message.origin, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.direction !== undefined) {\n            PBVector3.encode(message.direction, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.distance !== 0) {\n            writer.uint32(29).float(message.distance);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBRay();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.origin = PBVector3.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.direction = PBVector3.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.distance = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            origin: isSet(object.origin) ? PBVector3.fromJSON(object.origin) : undefined,\n            direction: isSet(object.direction) ? PBVector3.fromJSON(object.direction) : undefined,\n            distance: isSet(object.distance) ? Number(object.distance) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.origin !== undefined && (obj.origin = message.origin ? PBVector3.toJSON(message.origin) : undefined);\n        message.direction !== undefined &&\n            (obj.direction = message.direction ? PBVector3.toJSON(message.direction) : undefined);\n        message.distance !== undefined && (obj.distance = message.distance);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePBRay();\n        message.origin = (object.origin !== undefined && object.origin !== null)\n            ? PBVector3.fromPartial(object.origin)\n            : undefined;\n        message.direction = (object.direction !== undefined && object.direction !== null)\n            ? PBVector3.fromPartial(object.direction)\n            : undefined;\n        message.distance = (_a = object.distance) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBasePBRayQuery() {\n    return { queryId: \"\", queryType: \"\", ray: undefined };\n}\nconst PBRayQuery = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.queryId !== \"\") {\n            writer.uint32(10).string(message.queryId);\n        }\n        if (message.queryType !== \"\") {\n            writer.uint32(18).string(message.queryType);\n        }\n        if (message.ray !== undefined) {\n            PBRay.encode(message.ray, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBRayQuery();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.queryId = reader.string();\n                    break;\n                case 2:\n                    message.queryType = reader.string();\n                    break;\n                case 3:\n                    message.ray = PBRay.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            queryId: isSet(object.queryId) ? String(object.queryId) : \"\",\n            queryType: isSet(object.queryType) ? String(object.queryType) : \"\",\n            ray: isSet(object.ray) ? PBRay.fromJSON(object.ray) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.queryId !== undefined && (obj.queryId = message.queryId);\n        message.queryType !== undefined && (obj.queryType = message.queryType);\n        message.ray !== undefined && (obj.ray = message.ray ? PBRay.toJSON(message.ray) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBRayQuery();\n        message.queryId = (_a = object.queryId) !== null && _a !== void 0 ? _a : \"\";\n        message.queryType = (_b = object.queryType) !== null && _b !== void 0 ? _b : \"\";\n        message.ray = (object.ray !== undefined && object.ray !== null) ? PBRay.fromPartial(object.ray) : undefined;\n        return message;\n    },\n};\nfunction createBasePBQuery() {\n    return { queryId: \"\", payload: \"\" };\n}\nconst PBQuery = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.queryId !== \"\") {\n            writer.uint32(10).string(message.queryId);\n        }\n        if (message.payload !== \"\") {\n            writer.uint32(18).string(message.payload);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBQuery();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.queryId = reader.string();\n                    break;\n                case 2:\n                    message.payload = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            queryId: isSet(object.queryId) ? String(object.queryId) : \"\",\n            payload: isSet(object.payload) ? String(object.payload) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.queryId !== undefined && (obj.queryId = message.queryId);\n        message.payload !== undefined && (obj.payload = message.payload);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBQuery();\n        message.queryId = (_a = object.queryId) !== null && _a !== void 0 ? _a : \"\";\n        message.payload = (_b = object.payload) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePBSendSceneMessage() {\n    return {\n        sceneId: \"\",\n        tag: \"\",\n        createEntity: undefined,\n        removeEntity: undefined,\n        setEntityParent: undefined,\n        updateEntityComponent: undefined,\n        attachEntityComponent: undefined,\n        componentCreated: undefined,\n        componentDisposed: undefined,\n        componentRemoved: undefined,\n        componentUpdated: undefined,\n        query: undefined,\n        sceneStarted: undefined,\n        openExternalUrl: undefined,\n        openNFTDialog: undefined,\n        sceneNumber: 0,\n    };\n}\nconst PBSendSceneMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.sceneId !== \"\") {\n            writer.uint32(10).string(message.sceneId);\n        }\n        if (message.tag !== \"\") {\n            writer.uint32(18).string(message.tag);\n        }\n        if (message.createEntity !== undefined) {\n            PBCreateEntity.encode(message.createEntity, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.removeEntity !== undefined) {\n            PBRemoveEntity.encode(message.removeEntity, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.setEntityParent !== undefined) {\n            PBSetEntityParent.encode(message.setEntityParent, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.updateEntityComponent !== undefined) {\n            PBUpdateEntityComponent.encode(message.updateEntityComponent, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.attachEntityComponent !== undefined) {\n            PBAttachEntityComponent.encode(message.attachEntityComponent, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.componentCreated !== undefined) {\n            PBComponentCreated.encode(message.componentCreated, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.componentDisposed !== undefined) {\n            PBComponentDisposed.encode(message.componentDisposed, writer.uint32(74).fork()).ldelim();\n        }\n        if (message.componentRemoved !== undefined) {\n            PBComponentRemoved.encode(message.componentRemoved, writer.uint32(82).fork()).ldelim();\n        }\n        if (message.componentUpdated !== undefined) {\n            PBComponentUpdated.encode(message.componentUpdated, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.query !== undefined) {\n            PBQuery.encode(message.query, writer.uint32(98).fork()).ldelim();\n        }\n        if (message.sceneStarted !== undefined) {\n            _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].encode(message.sceneStarted, writer.uint32(106).fork()).ldelim();\n        }\n        if (message.openExternalUrl !== undefined) {\n            PBOpenExternalUrl.encode(message.openExternalUrl, writer.uint32(114).fork()).ldelim();\n        }\n        if (message.openNFTDialog !== undefined) {\n            PBOpenNFTDialog.encode(message.openNFTDialog, writer.uint32(122).fork()).ldelim();\n        }\n        if (message.sceneNumber !== 0) {\n            writer.uint32(792).int32(message.sceneNumber);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBSendSceneMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sceneId = reader.string();\n                    break;\n                case 2:\n                    message.tag = reader.string();\n                    break;\n                case 3:\n                    message.createEntity = PBCreateEntity.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.removeEntity = PBRemoveEntity.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.setEntityParent = PBSetEntityParent.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.updateEntityComponent = PBUpdateEntityComponent.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.attachEntityComponent = PBAttachEntityComponent.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.componentCreated = PBComponentCreated.decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.componentDisposed = PBComponentDisposed.decode(reader, reader.uint32());\n                    break;\n                case 10:\n                    message.componentRemoved = PBComponentRemoved.decode(reader, reader.uint32());\n                    break;\n                case 11:\n                    message.componentUpdated = PBComponentUpdated.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.query = PBQuery.decode(reader, reader.uint32());\n                    break;\n                case 13:\n                    message.sceneStarted = _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    message.openExternalUrl = PBOpenExternalUrl.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.openNFTDialog = PBOpenNFTDialog.decode(reader, reader.uint32());\n                    break;\n                case 99:\n                    message.sceneNumber = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sceneId: isSet(object.sceneId) ? String(object.sceneId) : \"\",\n            tag: isSet(object.tag) ? String(object.tag) : \"\",\n            createEntity: isSet(object.createEntity) ? PBCreateEntity.fromJSON(object.createEntity) : undefined,\n            removeEntity: isSet(object.removeEntity) ? PBRemoveEntity.fromJSON(object.removeEntity) : undefined,\n            setEntityParent: isSet(object.setEntityParent) ? PBSetEntityParent.fromJSON(object.setEntityParent) : undefined,\n            updateEntityComponent: isSet(object.updateEntityComponent)\n                ? PBUpdateEntityComponent.fromJSON(object.updateEntityComponent)\n                : undefined,\n            attachEntityComponent: isSet(object.attachEntityComponent)\n                ? PBAttachEntityComponent.fromJSON(object.attachEntityComponent)\n                : undefined,\n            componentCreated: isSet(object.componentCreated)\n                ? PBComponentCreated.fromJSON(object.componentCreated)\n                : undefined,\n            componentDisposed: isSet(object.componentDisposed)\n                ? PBComponentDisposed.fromJSON(object.componentDisposed)\n                : undefined,\n            componentRemoved: isSet(object.componentRemoved)\n                ? PBComponentRemoved.fromJSON(object.componentRemoved)\n                : undefined,\n            componentUpdated: isSet(object.componentUpdated)\n                ? PBComponentUpdated.fromJSON(object.componentUpdated)\n                : undefined,\n            query: isSet(object.query) ? PBQuery.fromJSON(object.query) : undefined,\n            sceneStarted: isSet(object.sceneStarted) ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromJSON(object.sceneStarted) : undefined,\n            openExternalUrl: isSet(object.openExternalUrl) ? PBOpenExternalUrl.fromJSON(object.openExternalUrl) : undefined,\n            openNFTDialog: isSet(object.openNFTDialog) ? PBOpenNFTDialog.fromJSON(object.openNFTDialog) : undefined,\n            sceneNumber: isSet(object.sceneNumber) ? Number(object.sceneNumber) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sceneId !== undefined && (obj.sceneId = message.sceneId);\n        message.tag !== undefined && (obj.tag = message.tag);\n        message.createEntity !== undefined &&\n            (obj.createEntity = message.createEntity ? PBCreateEntity.toJSON(message.createEntity) : undefined);\n        message.removeEntity !== undefined &&\n            (obj.removeEntity = message.removeEntity ? PBRemoveEntity.toJSON(message.removeEntity) : undefined);\n        message.setEntityParent !== undefined &&\n            (obj.setEntityParent = message.setEntityParent ? PBSetEntityParent.toJSON(message.setEntityParent) : undefined);\n        message.updateEntityComponent !== undefined && (obj.updateEntityComponent = message.updateEntityComponent\n            ? PBUpdateEntityComponent.toJSON(message.updateEntityComponent)\n            : undefined);\n        message.attachEntityComponent !== undefined && (obj.attachEntityComponent = message.attachEntityComponent\n            ? PBAttachEntityComponent.toJSON(message.attachEntityComponent)\n            : undefined);\n        message.componentCreated !== undefined &&\n            (obj.componentCreated = message.componentCreated\n                ? PBComponentCreated.toJSON(message.componentCreated)\n                : undefined);\n        message.componentDisposed !== undefined && (obj.componentDisposed = message.componentDisposed\n            ? PBComponentDisposed.toJSON(message.componentDisposed)\n            : undefined);\n        message.componentRemoved !== undefined &&\n            (obj.componentRemoved = message.componentRemoved\n                ? PBComponentRemoved.toJSON(message.componentRemoved)\n                : undefined);\n        message.componentUpdated !== undefined &&\n            (obj.componentUpdated = message.componentUpdated\n                ? PBComponentUpdated.toJSON(message.componentUpdated)\n                : undefined);\n        message.query !== undefined && (obj.query = message.query ? PBQuery.toJSON(message.query) : undefined);\n        message.sceneStarted !== undefined &&\n            (obj.sceneStarted = message.sceneStarted ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].toJSON(message.sceneStarted) : undefined);\n        message.openExternalUrl !== undefined &&\n            (obj.openExternalUrl = message.openExternalUrl ? PBOpenExternalUrl.toJSON(message.openExternalUrl) : undefined);\n        message.openNFTDialog !== undefined &&\n            (obj.openNFTDialog = message.openNFTDialog ? PBOpenNFTDialog.toJSON(message.openNFTDialog) : undefined);\n        message.sceneNumber !== undefined && (obj.sceneNumber = Math.round(message.sceneNumber));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBSendSceneMessage();\n        message.sceneId = (_a = object.sceneId) !== null && _a !== void 0 ? _a : \"\";\n        message.tag = (_b = object.tag) !== null && _b !== void 0 ? _b : \"\";\n        message.createEntity = (object.createEntity !== undefined && object.createEntity !== null)\n            ? PBCreateEntity.fromPartial(object.createEntity)\n            : undefined;\n        message.removeEntity = (object.removeEntity !== undefined && object.removeEntity !== null)\n            ? PBRemoveEntity.fromPartial(object.removeEntity)\n            : undefined;\n        message.setEntityParent = (object.setEntityParent !== undefined && object.setEntityParent !== null)\n            ? PBSetEntityParent.fromPartial(object.setEntityParent)\n            : undefined;\n        message.updateEntityComponent =\n            (object.updateEntityComponent !== undefined && object.updateEntityComponent !== null)\n                ? PBUpdateEntityComponent.fromPartial(object.updateEntityComponent)\n                : undefined;\n        message.attachEntityComponent =\n            (object.attachEntityComponent !== undefined && object.attachEntityComponent !== null)\n                ? PBAttachEntityComponent.fromPartial(object.attachEntityComponent)\n                : undefined;\n        message.componentCreated = (object.componentCreated !== undefined && object.componentCreated !== null)\n            ? PBComponentCreated.fromPartial(object.componentCreated)\n            : undefined;\n        message.componentDisposed = (object.componentDisposed !== undefined && object.componentDisposed !== null)\n            ? PBComponentDisposed.fromPartial(object.componentDisposed)\n            : undefined;\n        message.componentRemoved = (object.componentRemoved !== undefined && object.componentRemoved !== null)\n            ? PBComponentRemoved.fromPartial(object.componentRemoved)\n            : undefined;\n        message.componentUpdated = (object.componentUpdated !== undefined && object.componentUpdated !== null)\n            ? PBComponentUpdated.fromPartial(object.componentUpdated)\n            : undefined;\n        message.query = (object.query !== undefined && object.query !== null)\n            ? PBQuery.fromPartial(object.query)\n            : undefined;\n        message.sceneStarted = (object.sceneStarted !== undefined && object.sceneStarted !== null)\n            ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromPartial(object.sceneStarted)\n            : undefined;\n        message.openExternalUrl = (object.openExternalUrl !== undefined && object.openExternalUrl !== null)\n            ? PBOpenExternalUrl.fromPartial(object.openExternalUrl)\n            : undefined;\n        message.openNFTDialog = (object.openNFTDialog !== undefined && object.openNFTDialog !== null)\n            ? PBOpenNFTDialog.fromPartial(object.openNFTDialog)\n            : undefined;\n        message.sceneNumber = (_c = object.sceneNumber) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBasePBSetPosition() {\n    return { x: 0, y: 0, z: 0 };\n}\nconst PBSetPosition = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.x !== 0) {\n            writer.uint32(13).float(message.x);\n        }\n        if (message.y !== 0) {\n            writer.uint32(21).float(message.y);\n        }\n        if (message.z !== 0) {\n            writer.uint32(29).float(message.z);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBSetPosition();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                case 3:\n                    message.z = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            x: isSet(object.x) ? Number(object.x) : 0,\n            y: isSet(object.y) ? Number(object.y) : 0,\n            z: isSet(object.z) ? Number(object.z) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        message.z !== undefined && (obj.z = message.z);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBSetPosition();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : 0;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;\n        message.z = (_c = object.z) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBasePBContentMapping() {\n    return { file: \"\", hash: \"\" };\n}\nconst PBContentMapping = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.file !== \"\") {\n            writer.uint32(10).string(message.file);\n        }\n        if (message.hash !== \"\") {\n            writer.uint32(18).string(message.hash);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBContentMapping();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.file = reader.string();\n                    break;\n                case 2:\n                    message.hash = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { file: isSet(object.file) ? String(object.file) : \"\", hash: isSet(object.hash) ? String(object.hash) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.file !== undefined && (obj.file = message.file);\n        message.hash !== undefined && (obj.hash = message.hash);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBContentMapping();\n        message.file = (_a = object.file) !== null && _a !== void 0 ? _a : \"\";\n        message.hash = (_b = object.hash) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePBPosition() {\n    return { x: 0, y: 0 };\n}\nconst PBPosition = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.x !== 0) {\n            writer.uint32(13).float(message.x);\n        }\n        if (message.y !== 0) {\n            writer.uint32(21).float(message.y);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBPosition();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.float();\n                    break;\n                case 2:\n                    message.y = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { x: isSet(object.x) ? Number(object.x) : 0, y: isSet(object.y) ? Number(object.y) : 0 };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBPosition();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : 0;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBasePBLoadParcelScenes() {\n    return { id: \"\", basePosition: undefined, parcels: [], contents: [], baseUrl: \"\", sceneNumber: 0 };\n}\nconst PBLoadParcelScenes = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.basePosition !== undefined) {\n            PBPosition.encode(message.basePosition, writer.uint32(18).fork()).ldelim();\n        }\n        for (const v of message.parcels) {\n            PBPosition.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        for (const v of message.contents) {\n            PBContentMapping.encode(v, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.baseUrl !== \"\") {\n            writer.uint32(42).string(message.baseUrl);\n        }\n        if (message.sceneNumber !== 0) {\n            writer.uint32(792).int32(message.sceneNumber);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBLoadParcelScenes();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.basePosition = PBPosition.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.parcels.push(PBPosition.decode(reader, reader.uint32()));\n                    break;\n                case 4:\n                    message.contents.push(PBContentMapping.decode(reader, reader.uint32()));\n                    break;\n                case 5:\n                    message.baseUrl = reader.string();\n                    break;\n                case 99:\n                    message.sceneNumber = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            basePosition: isSet(object.basePosition) ? PBPosition.fromJSON(object.basePosition) : undefined,\n            parcels: Array.isArray(object === null || object === void 0 ? void 0 : object.parcels) ? object.parcels.map((e) => PBPosition.fromJSON(e)) : [],\n            contents: Array.isArray(object === null || object === void 0 ? void 0 : object.contents) ? object.contents.map((e) => PBContentMapping.fromJSON(e)) : [],\n            baseUrl: isSet(object.baseUrl) ? String(object.baseUrl) : \"\",\n            sceneNumber: isSet(object.sceneNumber) ? Number(object.sceneNumber) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.basePosition !== undefined &&\n            (obj.basePosition = message.basePosition ? PBPosition.toJSON(message.basePosition) : undefined);\n        if (message.parcels) {\n            obj.parcels = message.parcels.map((e) => e ? PBPosition.toJSON(e) : undefined);\n        }\n        else {\n            obj.parcels = [];\n        }\n        if (message.contents) {\n            obj.contents = message.contents.map((e) => e ? PBContentMapping.toJSON(e) : undefined);\n        }\n        else {\n            obj.contents = [];\n        }\n        message.baseUrl !== undefined && (obj.baseUrl = message.baseUrl);\n        message.sceneNumber !== undefined && (obj.sceneNumber = Math.round(message.sceneNumber));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBasePBLoadParcelScenes();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.basePosition = (object.basePosition !== undefined && object.basePosition !== null)\n            ? PBPosition.fromPartial(object.basePosition)\n            : undefined;\n        message.parcels = ((_b = object.parcels) === null || _b === void 0 ? void 0 : _b.map((e) => PBPosition.fromPartial(e))) || [];\n        message.contents = ((_c = object.contents) === null || _c === void 0 ? void 0 : _c.map((e) => PBContentMapping.fromPartial(e))) || [];\n        message.baseUrl = (_d = object.baseUrl) !== null && _d !== void 0 ? _d : \"\";\n        message.sceneNumber = (_e = object.sceneNumber) !== null && _e !== void 0 ? _e : 0;\n        return message;\n    },\n};\nfunction createBasePBCreateUIScene() {\n    return { id: \"\", baseUrl: \"\", sceneNumber: 0 };\n}\nconst PBCreateUIScene = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.baseUrl !== \"\") {\n            writer.uint32(18).string(message.baseUrl);\n        }\n        if (message.sceneNumber !== 0) {\n            writer.uint32(792).int32(message.sceneNumber);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBCreateUIScene();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.baseUrl = reader.string();\n                    break;\n                case 99:\n                    message.sceneNumber = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            baseUrl: isSet(object.baseUrl) ? String(object.baseUrl) : \"\",\n            sceneNumber: isSet(object.sceneNumber) ? Number(object.sceneNumber) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.baseUrl !== undefined && (obj.baseUrl = message.baseUrl);\n        message.sceneNumber !== undefined && (obj.sceneNumber = Math.round(message.sceneNumber));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBCreateUIScene();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.baseUrl = (_b = object.baseUrl) !== null && _b !== void 0 ? _b : \"\";\n        message.sceneNumber = (_c = object.sceneNumber) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBasePBUnloadScene() {\n    return { sceneId: \"\", sceneNumber: 0 };\n}\nconst PBUnloadScene = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.sceneId !== \"\") {\n            writer.uint32(10).string(message.sceneId);\n        }\n        if (message.sceneNumber !== 0) {\n            writer.uint32(792).int32(message.sceneNumber);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUnloadScene();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.sceneId = reader.string();\n                    break;\n                case 99:\n                    message.sceneNumber = reader.int32();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            sceneId: isSet(object.sceneId) ? String(object.sceneId) : \"\",\n            sceneNumber: isSet(object.sceneNumber) ? Number(object.sceneNumber) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.sceneId !== undefined && (obj.sceneId = message.sceneId);\n        message.sceneNumber !== undefined && (obj.sceneNumber = Math.round(message.sceneNumber));\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBUnloadScene();\n        message.sceneId = (_a = object.sceneId) !== null && _a !== void 0 ? _a : \"\";\n        message.sceneNumber = (_b = object.sceneNumber) !== null && _b !== void 0 ? _b : 0;\n        return message;\n    },\n};\nfunction createBasePBDclMessage() {\n    return {\n        setDebug: undefined,\n        setSceneDebugPanel: undefined,\n        setEngineDebugPanel: undefined,\n        sendSceneMessage: undefined,\n        loadParcelScenes: undefined,\n        unloadScene: undefined,\n        setPosition: undefined,\n        reset: undefined,\n        createUIScene: undefined,\n    };\n}\nconst PBDclMessage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.setDebug !== undefined) {\n            _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].encode(message.setDebug, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.setSceneDebugPanel !== undefined) {\n            _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].encode(message.setSceneDebugPanel, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.setEngineDebugPanel !== undefined) {\n            _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].encode(message.setEngineDebugPanel, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.sendSceneMessage !== undefined) {\n            PBSendSceneMessage.encode(message.sendSceneMessage, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.loadParcelScenes !== undefined) {\n            PBLoadParcelScenes.encode(message.loadParcelScenes, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.unloadScene !== undefined) {\n            PBUnloadScene.encode(message.unloadScene, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.setPosition !== undefined) {\n            PBSetPosition.encode(message.setPosition, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.reset !== undefined) {\n            _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].encode(message.reset, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.createUIScene !== undefined) {\n            PBCreateUIScene.encode(message.createUIScene, writer.uint32(74).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBDclMessage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.setDebug = _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.setSceneDebugPanel = _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.setEngineDebugPanel = _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.sendSceneMessage = PBSendSceneMessage.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.loadParcelScenes = PBLoadParcelScenes.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.unloadScene = PBUnloadScene.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.setPosition = PBSetPosition.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.reset = _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.createUIScene = PBCreateUIScene.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            setDebug: isSet(object.setDebug) ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromJSON(object.setDebug) : undefined,\n            setSceneDebugPanel: isSet(object.setSceneDebugPanel) ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromJSON(object.setSceneDebugPanel) : undefined,\n            setEngineDebugPanel: isSet(object.setEngineDebugPanel) ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromJSON(object.setEngineDebugPanel) : undefined,\n            sendSceneMessage: isSet(object.sendSceneMessage)\n                ? PBSendSceneMessage.fromJSON(object.sendSceneMessage)\n                : undefined,\n            loadParcelScenes: isSet(object.loadParcelScenes)\n                ? PBLoadParcelScenes.fromJSON(object.loadParcelScenes)\n                : undefined,\n            unloadScene: isSet(object.unloadScene) ? PBUnloadScene.fromJSON(object.unloadScene) : undefined,\n            setPosition: isSet(object.setPosition) ? PBSetPosition.fromJSON(object.setPosition) : undefined,\n            reset: isSet(object.reset) ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromJSON(object.reset) : undefined,\n            createUIScene: isSet(object.createUIScene) ? PBCreateUIScene.fromJSON(object.createUIScene) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.setDebug !== undefined && (obj.setDebug = message.setDebug ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].toJSON(message.setDebug) : undefined);\n        message.setSceneDebugPanel !== undefined &&\n            (obj.setSceneDebugPanel = message.setSceneDebugPanel ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].toJSON(message.setSceneDebugPanel) : undefined);\n        message.setEngineDebugPanel !== undefined &&\n            (obj.setEngineDebugPanel = message.setEngineDebugPanel ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].toJSON(message.setEngineDebugPanel) : undefined);\n        message.sendSceneMessage !== undefined &&\n            (obj.sendSceneMessage = message.sendSceneMessage\n                ? PBSendSceneMessage.toJSON(message.sendSceneMessage)\n                : undefined);\n        message.loadParcelScenes !== undefined &&\n            (obj.loadParcelScenes = message.loadParcelScenes\n                ? PBLoadParcelScenes.toJSON(message.loadParcelScenes)\n                : undefined);\n        message.unloadScene !== undefined &&\n            (obj.unloadScene = message.unloadScene ? PBUnloadScene.toJSON(message.unloadScene) : undefined);\n        message.setPosition !== undefined &&\n            (obj.setPosition = message.setPosition ? PBSetPosition.toJSON(message.setPosition) : undefined);\n        message.reset !== undefined && (obj.reset = message.reset ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].toJSON(message.reset) : undefined);\n        message.createUIScene !== undefined &&\n            (obj.createUIScene = message.createUIScene ? PBCreateUIScene.toJSON(message.createUIScene) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePBDclMessage();\n        message.setDebug = (object.setDebug !== undefined && object.setDebug !== null)\n            ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromPartial(object.setDebug)\n            : undefined;\n        message.setSceneDebugPanel = (object.setSceneDebugPanel !== undefined && object.setSceneDebugPanel !== null)\n            ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromPartial(object.setSceneDebugPanel)\n            : undefined;\n        message.setEngineDebugPanel = (object.setEngineDebugPanel !== undefined && object.setEngineDebugPanel !== null)\n            ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromPartial(object.setEngineDebugPanel)\n            : undefined;\n        message.sendSceneMessage = (object.sendSceneMessage !== undefined && object.sendSceneMessage !== null)\n            ? PBSendSceneMessage.fromPartial(object.sendSceneMessage)\n            : undefined;\n        message.loadParcelScenes = (object.loadParcelScenes !== undefined && object.loadParcelScenes !== null)\n            ? PBLoadParcelScenes.fromPartial(object.loadParcelScenes)\n            : undefined;\n        message.unloadScene = (object.unloadScene !== undefined && object.unloadScene !== null)\n            ? PBUnloadScene.fromPartial(object.unloadScene)\n            : undefined;\n        message.setPosition = (object.setPosition !== undefined && object.setPosition !== null)\n            ? PBSetPosition.fromPartial(object.setPosition)\n            : undefined;\n        message.reset = (object.reset !== undefined && object.reset !== null) ? _google_protobuf_empty_gen__WEBPACK_IMPORTED_MODULE_2__[\"Empty\"].fromPartial(object.reset) : undefined;\n        message.createUIScene = (object.createUIScene !== undefined && object.createUIScene !== null)\n            ? PBCreateUIScene.fromPartial(object.createUIScene)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBAnimationState() {\n    return { clip: \"\", looping: false, weight: 0, playing: false, shouldReset: false, speed: 0 };\n}\nconst PBAnimationState = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.clip !== \"\") {\n            writer.uint32(10).string(message.clip);\n        }\n        if (message.looping === true) {\n            writer.uint32(16).bool(message.looping);\n        }\n        if (message.weight !== 0) {\n            writer.uint32(29).float(message.weight);\n        }\n        if (message.playing === true) {\n            writer.uint32(32).bool(message.playing);\n        }\n        if (message.shouldReset === true) {\n            writer.uint32(40).bool(message.shouldReset);\n        }\n        if (message.speed !== 0) {\n            writer.uint32(53).float(message.speed);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBAnimationState();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.clip = reader.string();\n                    break;\n                case 2:\n                    message.looping = reader.bool();\n                    break;\n                case 3:\n                    message.weight = reader.float();\n                    break;\n                case 4:\n                    message.playing = reader.bool();\n                    break;\n                case 5:\n                    message.shouldReset = reader.bool();\n                    break;\n                case 6:\n                    message.speed = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            clip: isSet(object.clip) ? String(object.clip) : \"\",\n            looping: isSet(object.looping) ? Boolean(object.looping) : false,\n            weight: isSet(object.weight) ? Number(object.weight) : 0,\n            playing: isSet(object.playing) ? Boolean(object.playing) : false,\n            shouldReset: isSet(object.shouldReset) ? Boolean(object.shouldReset) : false,\n            speed: isSet(object.speed) ? Number(object.speed) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.clip !== undefined && (obj.clip = message.clip);\n        message.looping !== undefined && (obj.looping = message.looping);\n        message.weight !== undefined && (obj.weight = message.weight);\n        message.playing !== undefined && (obj.playing = message.playing);\n        message.shouldReset !== undefined && (obj.shouldReset = message.shouldReset);\n        message.speed !== undefined && (obj.speed = message.speed);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f;\n        const message = createBasePBAnimationState();\n        message.clip = (_a = object.clip) !== null && _a !== void 0 ? _a : \"\";\n        message.looping = (_b = object.looping) !== null && _b !== void 0 ? _b : false;\n        message.weight = (_c = object.weight) !== null && _c !== void 0 ? _c : 0;\n        message.playing = (_d = object.playing) !== null && _d !== void 0 ? _d : false;\n        message.shouldReset = (_e = object.shouldReset) !== null && _e !== void 0 ? _e : false;\n        message.speed = (_f = object.speed) !== null && _f !== void 0 ? _f : 0;\n        return message;\n    },\n};\nfunction createBasePBAnimator() {\n    return { withCollisions: false, visible: false };\n}\nconst PBAnimator = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBAnimator();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBAnimator();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBasePBAudioClip() {\n    return { url: \"\", loop: false, volume: 0 };\n}\nconst PBAudioClip = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.url !== \"\") {\n            writer.uint32(10).string(message.url);\n        }\n        if (message.loop === true) {\n            writer.uint32(16).bool(message.loop);\n        }\n        if (message.volume !== 0) {\n            writer.uint32(29).float(message.volume);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBAudioClip();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.url = reader.string();\n                    break;\n                case 2:\n                    message.loop = reader.bool();\n                    break;\n                case 3:\n                    message.volume = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            url: isSet(object.url) ? String(object.url) : \"\",\n            loop: isSet(object.loop) ? Boolean(object.loop) : false,\n            volume: isSet(object.volume) ? Number(object.volume) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.url !== undefined && (obj.url = message.url);\n        message.loop !== undefined && (obj.loop = message.loop);\n        message.volume !== undefined && (obj.volume = message.volume);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBAudioClip();\n        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : \"\";\n        message.loop = (_b = object.loop) !== null && _b !== void 0 ? _b : false;\n        message.volume = (_c = object.volume) !== null && _c !== void 0 ? _c : 0;\n        return message;\n    },\n};\nfunction createBasePBAudioSource() {\n    return { audioClip: undefined, audioClipId: \"\", loop: false, volume: 0, playing: false, pitch: 0 };\n}\nconst PBAudioSource = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.audioClip !== undefined) {\n            PBAudioClip.encode(message.audioClip, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.audioClipId !== \"\") {\n            writer.uint32(18).string(message.audioClipId);\n        }\n        if (message.loop === true) {\n            writer.uint32(24).bool(message.loop);\n        }\n        if (message.volume !== 0) {\n            writer.uint32(37).float(message.volume);\n        }\n        if (message.playing === true) {\n            writer.uint32(40).bool(message.playing);\n        }\n        if (message.pitch !== 0) {\n            writer.uint32(53).float(message.pitch);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBAudioSource();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.audioClip = PBAudioClip.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.audioClipId = reader.string();\n                    break;\n                case 3:\n                    message.loop = reader.bool();\n                    break;\n                case 4:\n                    message.volume = reader.float();\n                    break;\n                case 5:\n                    message.playing = reader.bool();\n                    break;\n                case 6:\n                    message.pitch = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            audioClip: isSet(object.audioClip) ? PBAudioClip.fromJSON(object.audioClip) : undefined,\n            audioClipId: isSet(object.audioClipId) ? String(object.audioClipId) : \"\",\n            loop: isSet(object.loop) ? Boolean(object.loop) : false,\n            volume: isSet(object.volume) ? Number(object.volume) : 0,\n            playing: isSet(object.playing) ? Boolean(object.playing) : false,\n            pitch: isSet(object.pitch) ? Number(object.pitch) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.audioClip !== undefined &&\n            (obj.audioClip = message.audioClip ? PBAudioClip.toJSON(message.audioClip) : undefined);\n        message.audioClipId !== undefined && (obj.audioClipId = message.audioClipId);\n        message.loop !== undefined && (obj.loop = message.loop);\n        message.volume !== undefined && (obj.volume = message.volume);\n        message.playing !== undefined && (obj.playing = message.playing);\n        message.pitch !== undefined && (obj.pitch = message.pitch);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBasePBAudioSource();\n        message.audioClip = (object.audioClip !== undefined && object.audioClip !== null)\n            ? PBAudioClip.fromPartial(object.audioClip)\n            : undefined;\n        message.audioClipId = (_a = object.audioClipId) !== null && _a !== void 0 ? _a : \"\";\n        message.loop = (_b = object.loop) !== null && _b !== void 0 ? _b : false;\n        message.volume = (_c = object.volume) !== null && _c !== void 0 ? _c : 0;\n        message.playing = (_d = object.playing) !== null && _d !== void 0 ? _d : false;\n        message.pitch = (_e = object.pitch) !== null && _e !== void 0 ? _e : 0;\n        return message;\n    },\n};\nfunction createBasePBAvatarShape() {\n    return {\n        id: \"\",\n        baseUrl: \"\",\n        name: \"\",\n        bodyShape: undefined,\n        wearables: [],\n        skin: undefined,\n        hair: undefined,\n        eyes: undefined,\n        eyebrows: undefined,\n        mouth: undefined,\n        useDummyModel: false,\n        expressionTriggerId: \"\",\n        expressionTriggerTimestamp: 0,\n        emotes: [],\n    };\n}\nconst PBAvatarShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.id !== \"\") {\n            writer.uint32(10).string(message.id);\n        }\n        if (message.baseUrl !== \"\") {\n            writer.uint32(18).string(message.baseUrl);\n        }\n        if (message.name !== \"\") {\n            writer.uint32(26).string(message.name);\n        }\n        if (message.bodyShape !== undefined) {\n            PBWearable.encode(message.bodyShape, writer.uint32(34).fork()).ldelim();\n        }\n        for (const v of message.wearables) {\n            PBWearable.encode(v, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.skin !== undefined) {\n            PBSkin.encode(message.skin, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.hair !== undefined) {\n            PBHair.encode(message.hair, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.eyes !== undefined) {\n            PBEyes.encode(message.eyes, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.eyebrows !== undefined) {\n            PBFace.encode(message.eyebrows, writer.uint32(74).fork()).ldelim();\n        }\n        if (message.mouth !== undefined) {\n            PBFace.encode(message.mouth, writer.uint32(82).fork()).ldelim();\n        }\n        if (message.useDummyModel === true) {\n            writer.uint32(88).bool(message.useDummyModel);\n        }\n        if (message.expressionTriggerId !== \"\") {\n            writer.uint32(98).string(message.expressionTriggerId);\n        }\n        if (message.expressionTriggerTimestamp !== 0) {\n            writer.uint32(112).uint64(message.expressionTriggerTimestamp);\n        }\n        for (const v of message.emotes) {\n            writer.uint32(122).string(v);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBAvatarShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.id = reader.string();\n                    break;\n                case 2:\n                    message.baseUrl = reader.string();\n                    break;\n                case 3:\n                    message.name = reader.string();\n                    break;\n                case 4:\n                    message.bodyShape = PBWearable.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.wearables.push(PBWearable.decode(reader, reader.uint32()));\n                    break;\n                case 6:\n                    message.skin = PBSkin.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.hair = PBHair.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.eyes = PBEyes.decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.eyebrows = PBFace.decode(reader, reader.uint32());\n                    break;\n                case 10:\n                    message.mouth = PBFace.decode(reader, reader.uint32());\n                    break;\n                case 11:\n                    message.useDummyModel = reader.bool();\n                    break;\n                case 12:\n                    message.expressionTriggerId = reader.string();\n                    break;\n                case 14:\n                    message.expressionTriggerTimestamp = longToNumber(reader.uint64());\n                    break;\n                case 15:\n                    message.emotes.push(reader.string());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            id: isSet(object.id) ? String(object.id) : \"\",\n            baseUrl: isSet(object.baseUrl) ? String(object.baseUrl) : \"\",\n            name: isSet(object.name) ? String(object.name) : \"\",\n            bodyShape: isSet(object.bodyShape) ? PBWearable.fromJSON(object.bodyShape) : undefined,\n            wearables: Array.isArray(object === null || object === void 0 ? void 0 : object.wearables) ? object.wearables.map((e) => PBWearable.fromJSON(e)) : [],\n            skin: isSet(object.skin) ? PBSkin.fromJSON(object.skin) : undefined,\n            hair: isSet(object.hair) ? PBHair.fromJSON(object.hair) : undefined,\n            eyes: isSet(object.eyes) ? PBEyes.fromJSON(object.eyes) : undefined,\n            eyebrows: isSet(object.eyebrows) ? PBFace.fromJSON(object.eyebrows) : undefined,\n            mouth: isSet(object.mouth) ? PBFace.fromJSON(object.mouth) : undefined,\n            useDummyModel: isSet(object.useDummyModel) ? Boolean(object.useDummyModel) : false,\n            expressionTriggerId: isSet(object.expressionTriggerId) ? String(object.expressionTriggerId) : \"\",\n            expressionTriggerTimestamp: isSet(object.expressionTriggerTimestamp)\n                ? Number(object.expressionTriggerTimestamp)\n                : 0,\n            emotes: Array.isArray(object === null || object === void 0 ? void 0 : object.emotes) ? object.emotes.map((e) => String(e)) : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.id !== undefined && (obj.id = message.id);\n        message.baseUrl !== undefined && (obj.baseUrl = message.baseUrl);\n        message.name !== undefined && (obj.name = message.name);\n        message.bodyShape !== undefined &&\n            (obj.bodyShape = message.bodyShape ? PBWearable.toJSON(message.bodyShape) : undefined);\n        if (message.wearables) {\n            obj.wearables = message.wearables.map((e) => e ? PBWearable.toJSON(e) : undefined);\n        }\n        else {\n            obj.wearables = [];\n        }\n        message.skin !== undefined && (obj.skin = message.skin ? PBSkin.toJSON(message.skin) : undefined);\n        message.hair !== undefined && (obj.hair = message.hair ? PBHair.toJSON(message.hair) : undefined);\n        message.eyes !== undefined && (obj.eyes = message.eyes ? PBEyes.toJSON(message.eyes) : undefined);\n        message.eyebrows !== undefined && (obj.eyebrows = message.eyebrows ? PBFace.toJSON(message.eyebrows) : undefined);\n        message.mouth !== undefined && (obj.mouth = message.mouth ? PBFace.toJSON(message.mouth) : undefined);\n        message.useDummyModel !== undefined && (obj.useDummyModel = message.useDummyModel);\n        message.expressionTriggerId !== undefined && (obj.expressionTriggerId = message.expressionTriggerId);\n        message.expressionTriggerTimestamp !== undefined &&\n            (obj.expressionTriggerTimestamp = Math.round(message.expressionTriggerTimestamp));\n        if (message.emotes) {\n            obj.emotes = message.emotes.map((e) => e);\n        }\n        else {\n            obj.emotes = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h;\n        const message = createBasePBAvatarShape();\n        message.id = (_a = object.id) !== null && _a !== void 0 ? _a : \"\";\n        message.baseUrl = (_b = object.baseUrl) !== null && _b !== void 0 ? _b : \"\";\n        message.name = (_c = object.name) !== null && _c !== void 0 ? _c : \"\";\n        message.bodyShape = (object.bodyShape !== undefined && object.bodyShape !== null)\n            ? PBWearable.fromPartial(object.bodyShape)\n            : undefined;\n        message.wearables = ((_d = object.wearables) === null || _d === void 0 ? void 0 : _d.map((e) => PBWearable.fromPartial(e))) || [];\n        message.skin = (object.skin !== undefined && object.skin !== null) ? PBSkin.fromPartial(object.skin) : undefined;\n        message.hair = (object.hair !== undefined && object.hair !== null) ? PBHair.fromPartial(object.hair) : undefined;\n        message.eyes = (object.eyes !== undefined && object.eyes !== null) ? PBEyes.fromPartial(object.eyes) : undefined;\n        message.eyebrows = (object.eyebrows !== undefined && object.eyebrows !== null)\n            ? PBFace.fromPartial(object.eyebrows)\n            : undefined;\n        message.mouth = (object.mouth !== undefined && object.mouth !== null)\n            ? PBFace.fromPartial(object.mouth)\n            : undefined;\n        message.useDummyModel = (_e = object.useDummyModel) !== null && _e !== void 0 ? _e : false;\n        message.expressionTriggerId = (_f = object.expressionTriggerId) !== null && _f !== void 0 ? _f : \"\";\n        message.expressionTriggerTimestamp = (_g = object.expressionTriggerTimestamp) !== null && _g !== void 0 ? _g : 0;\n        message.emotes = ((_h = object.emotes) === null || _h === void 0 ? void 0 : _h.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePBWearable() {\n    return { categody: \"\", contentName: \"\", contents: [] };\n}\nconst PBWearable = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.categody !== \"\") {\n            writer.uint32(10).string(message.categody);\n        }\n        if (message.contentName !== \"\") {\n            writer.uint32(18).string(message.contentName);\n        }\n        for (const v of message.contents) {\n            PBContentMapping.encode(v, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBWearable();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.categody = reader.string();\n                    break;\n                case 2:\n                    message.contentName = reader.string();\n                    break;\n                case 3:\n                    message.contents.push(PBContentMapping.decode(reader, reader.uint32()));\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            categody: isSet(object.categody) ? String(object.categody) : \"\",\n            contentName: isSet(object.contentName) ? String(object.contentName) : \"\",\n            contents: Array.isArray(object === null || object === void 0 ? void 0 : object.contents) ? object.contents.map((e) => PBContentMapping.fromJSON(e)) : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.categody !== undefined && (obj.categody = message.categody);\n        message.contentName !== undefined && (obj.contentName = message.contentName);\n        if (message.contents) {\n            obj.contents = message.contents.map((e) => e ? PBContentMapping.toJSON(e) : undefined);\n        }\n        else {\n            obj.contents = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBWearable();\n        message.categody = (_a = object.categody) !== null && _a !== void 0 ? _a : \"\";\n        message.contentName = (_b = object.contentName) !== null && _b !== void 0 ? _b : \"\";\n        message.contents = ((_c = object.contents) === null || _c === void 0 ? void 0 : _c.map((e) => PBContentMapping.fromPartial(e))) || [];\n        return message;\n    },\n};\nfunction createBasePBFace() {\n    return { texture: \"\" };\n}\nconst PBFace = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.texture !== \"\") {\n            writer.uint32(10).string(message.texture);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBFace();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.texture = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { texture: isSet(object.texture) ? String(object.texture) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.texture !== undefined && (obj.texture = message.texture);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePBFace();\n        message.texture = (_a = object.texture) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBasePBEyes() {\n    return { texture: \"\", mask: \"\", color: undefined };\n}\nconst PBEyes = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.texture !== \"\") {\n            writer.uint32(10).string(message.texture);\n        }\n        if (message.mask !== \"\") {\n            writer.uint32(18).string(message.mask);\n        }\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(26).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBEyes();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.texture = reader.string();\n                    break;\n                case 2:\n                    message.mask = reader.string();\n                    break;\n                case 3:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            texture: isSet(object.texture) ? String(object.texture) : \"\",\n            mask: isSet(object.mask) ? String(object.mask) : \"\",\n            color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.texture !== undefined && (obj.texture = message.texture);\n        message.mask !== undefined && (obj.mask = message.mask);\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBEyes();\n        message.texture = (_a = object.texture) !== null && _a !== void 0 ? _a : \"\";\n        message.mask = (_b = object.mask) !== null && _b !== void 0 ? _b : \"\";\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBHair() {\n    return { color: undefined };\n}\nconst PBHair = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBHair();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePBHair();\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBSkin() {\n    return { color: undefined };\n}\nconst PBSkin = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(10).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBSkin();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        const message = createBasePBSkin();\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBBasicMaterial() {\n    return { texture: undefined, alphaTest: 0 };\n}\nconst PBBasicMaterial = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.texture !== undefined) {\n            PBTexture.encode(message.texture, writer.uint32(10).fork()).ldelim();\n        }\n        if (message.alphaTest !== 0) {\n            writer.uint32(21).float(message.alphaTest);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBBasicMaterial();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.texture = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 2:\n                    message.alphaTest = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            texture: isSet(object.texture) ? PBTexture.fromJSON(object.texture) : undefined,\n            alphaTest: isSet(object.alphaTest) ? Number(object.alphaTest) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.texture !== undefined && (obj.texture = message.texture ? PBTexture.toJSON(message.texture) : undefined);\n        message.alphaTest !== undefined && (obj.alphaTest = message.alphaTest);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePBBasicMaterial();\n        message.texture = (object.texture !== undefined && object.texture !== null)\n            ? PBTexture.fromPartial(object.texture)\n            : undefined;\n        message.alphaTest = (_a = object.alphaTest) !== null && _a !== void 0 ? _a : 0;\n        return message;\n    },\n};\nfunction createBasePBBillboard() {\n    return { x: false, y: false, z: false };\n}\nconst PBBillboard = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.x === true) {\n            writer.uint32(8).bool(message.x);\n        }\n        if (message.y === true) {\n            writer.uint32(16).bool(message.y);\n        }\n        if (message.z === true) {\n            writer.uint32(24).bool(message.z);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBBillboard();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.x = reader.bool();\n                    break;\n                case 2:\n                    message.y = reader.bool();\n                    break;\n                case 3:\n                    message.z = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            x: isSet(object.x) ? Boolean(object.x) : false,\n            y: isSet(object.y) ? Boolean(object.y) : false,\n            z: isSet(object.z) ? Boolean(object.z) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.x !== undefined && (obj.x = message.x);\n        message.y !== undefined && (obj.y = message.y);\n        message.z !== undefined && (obj.z = message.z);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBBillboard();\n        message.x = (_a = object.x) !== null && _a !== void 0 ? _a : false;\n        message.y = (_b = object.y) !== null && _b !== void 0 ? _b : false;\n        message.z = (_c = object.z) !== null && _c !== void 0 ? _c : false;\n        return message;\n    },\n};\nfunction createBasePBBoxShape() {\n    return { withCollisions: false, visible: false, uvs: [] };\n}\nconst PBBoxShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        writer.uint32(26).fork();\n        for (const v of message.uvs) {\n            writer.float(v);\n        }\n        writer.ldelim();\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBBoxShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.uvs.push(reader.float());\n                        }\n                    }\n                    else {\n                        message.uvs.push(reader.float());\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            uvs: Array.isArray(object === null || object === void 0 ? void 0 : object.uvs) ? object.uvs.map((e) => Number(e)) : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        if (message.uvs) {\n            obj.uvs = message.uvs.map((e) => e);\n        }\n        else {\n            obj.uvs = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBBoxShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.uvs = ((_c = object.uvs) === null || _c === void 0 ? void 0 : _c.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePBCircleShape() {\n    return { withCollisions: false, visible: false, segments: 0, arc: 0 };\n}\nconst PBCircleShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.segments !== 0) {\n            writer.uint32(29).float(message.segments);\n        }\n        if (message.arc !== 0) {\n            writer.uint32(37).float(message.arc);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBCircleShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.segments = reader.float();\n                    break;\n                case 4:\n                    message.arc = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            segments: isSet(object.segments) ? Number(object.segments) : 0,\n            arc: isSet(object.arc) ? Number(object.arc) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.segments !== undefined && (obj.segments = message.segments);\n        message.arc !== undefined && (obj.arc = message.arc);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBasePBCircleShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.segments = (_c = object.segments) !== null && _c !== void 0 ? _c : 0;\n        message.arc = (_d = object.arc) !== null && _d !== void 0 ? _d : 0;\n        return message;\n    },\n};\nfunction createBasePBConeShape() {\n    return {\n        withCollisions: false,\n        visible: false,\n        radiusTop: 0,\n        radiusBottom: 0,\n        segmentsHeight: 0,\n        segmentsRadial: 0,\n        openEnded: false,\n        radius: 0,\n        arc: 0,\n    };\n}\nconst PBConeShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.radiusTop !== 0) {\n            writer.uint32(29).float(message.radiusTop);\n        }\n        if (message.radiusBottom !== 0) {\n            writer.uint32(37).float(message.radiusBottom);\n        }\n        if (message.segmentsHeight !== 0) {\n            writer.uint32(45).float(message.segmentsHeight);\n        }\n        if (message.segmentsRadial !== 0) {\n            writer.uint32(53).float(message.segmentsRadial);\n        }\n        if (message.openEnded === true) {\n            writer.uint32(56).bool(message.openEnded);\n        }\n        if (message.radius !== 0) {\n            writer.uint32(69).float(message.radius);\n        }\n        if (message.arc !== 0) {\n            writer.uint32(77).float(message.arc);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBConeShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.radiusTop = reader.float();\n                    break;\n                case 4:\n                    message.radiusBottom = reader.float();\n                    break;\n                case 5:\n                    message.segmentsHeight = reader.float();\n                    break;\n                case 6:\n                    message.segmentsRadial = reader.float();\n                    break;\n                case 7:\n                    message.openEnded = reader.bool();\n                    break;\n                case 8:\n                    message.radius = reader.float();\n                    break;\n                case 9:\n                    message.arc = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            radiusTop: isSet(object.radiusTop) ? Number(object.radiusTop) : 0,\n            radiusBottom: isSet(object.radiusBottom) ? Number(object.radiusBottom) : 0,\n            segmentsHeight: isSet(object.segmentsHeight) ? Number(object.segmentsHeight) : 0,\n            segmentsRadial: isSet(object.segmentsRadial) ? Number(object.segmentsRadial) : 0,\n            openEnded: isSet(object.openEnded) ? Boolean(object.openEnded) : false,\n            radius: isSet(object.radius) ? Number(object.radius) : 0,\n            arc: isSet(object.arc) ? Number(object.arc) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.radiusTop !== undefined && (obj.radiusTop = message.radiusTop);\n        message.radiusBottom !== undefined && (obj.radiusBottom = message.radiusBottom);\n        message.segmentsHeight !== undefined && (obj.segmentsHeight = message.segmentsHeight);\n        message.segmentsRadial !== undefined && (obj.segmentsRadial = message.segmentsRadial);\n        message.openEnded !== undefined && (obj.openEnded = message.openEnded);\n        message.radius !== undefined && (obj.radius = message.radius);\n        message.arc !== undefined && (obj.arc = message.arc);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const message = createBasePBConeShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.radiusTop = (_c = object.radiusTop) !== null && _c !== void 0 ? _c : 0;\n        message.radiusBottom = (_d = object.radiusBottom) !== null && _d !== void 0 ? _d : 0;\n        message.segmentsHeight = (_e = object.segmentsHeight) !== null && _e !== void 0 ? _e : 0;\n        message.segmentsRadial = (_f = object.segmentsRadial) !== null && _f !== void 0 ? _f : 0;\n        message.openEnded = (_g = object.openEnded) !== null && _g !== void 0 ? _g : false;\n        message.radius = (_h = object.radius) !== null && _h !== void 0 ? _h : 0;\n        message.arc = (_j = object.arc) !== null && _j !== void 0 ? _j : 0;\n        return message;\n    },\n};\nfunction createBasePBCylinderShape() {\n    return {\n        withCollisions: false,\n        visible: false,\n        radiusTop: 0,\n        radiusBottom: 0,\n        segmentsHeight: 0,\n        segmentsRadial: 0,\n        openEnded: false,\n        radius: 0,\n        arc: 0,\n    };\n}\nconst PBCylinderShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.radiusTop !== 0) {\n            writer.uint32(29).float(message.radiusTop);\n        }\n        if (message.radiusBottom !== 0) {\n            writer.uint32(37).float(message.radiusBottom);\n        }\n        if (message.segmentsHeight !== 0) {\n            writer.uint32(45).float(message.segmentsHeight);\n        }\n        if (message.segmentsRadial !== 0) {\n            writer.uint32(53).float(message.segmentsRadial);\n        }\n        if (message.openEnded === true) {\n            writer.uint32(56).bool(message.openEnded);\n        }\n        if (message.radius !== 0) {\n            writer.uint32(69).float(message.radius);\n        }\n        if (message.arc !== 0) {\n            writer.uint32(77).float(message.arc);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBCylinderShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.radiusTop = reader.float();\n                    break;\n                case 4:\n                    message.radiusBottom = reader.float();\n                    break;\n                case 5:\n                    message.segmentsHeight = reader.float();\n                    break;\n                case 6:\n                    message.segmentsRadial = reader.float();\n                    break;\n                case 7:\n                    message.openEnded = reader.bool();\n                    break;\n                case 8:\n                    message.radius = reader.float();\n                    break;\n                case 9:\n                    message.arc = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            radiusTop: isSet(object.radiusTop) ? Number(object.radiusTop) : 0,\n            radiusBottom: isSet(object.radiusBottom) ? Number(object.radiusBottom) : 0,\n            segmentsHeight: isSet(object.segmentsHeight) ? Number(object.segmentsHeight) : 0,\n            segmentsRadial: isSet(object.segmentsRadial) ? Number(object.segmentsRadial) : 0,\n            openEnded: isSet(object.openEnded) ? Boolean(object.openEnded) : false,\n            radius: isSet(object.radius) ? Number(object.radius) : 0,\n            arc: isSet(object.arc) ? Number(object.arc) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.radiusTop !== undefined && (obj.radiusTop = message.radiusTop);\n        message.radiusBottom !== undefined && (obj.radiusBottom = message.radiusBottom);\n        message.segmentsHeight !== undefined && (obj.segmentsHeight = message.segmentsHeight);\n        message.segmentsRadial !== undefined && (obj.segmentsRadial = message.segmentsRadial);\n        message.openEnded !== undefined && (obj.openEnded = message.openEnded);\n        message.radius !== undefined && (obj.radius = message.radius);\n        message.arc !== undefined && (obj.arc = message.arc);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j;\n        const message = createBasePBCylinderShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.radiusTop = (_c = object.radiusTop) !== null && _c !== void 0 ? _c : 0;\n        message.radiusBottom = (_d = object.radiusBottom) !== null && _d !== void 0 ? _d : 0;\n        message.segmentsHeight = (_e = object.segmentsHeight) !== null && _e !== void 0 ? _e : 0;\n        message.segmentsRadial = (_f = object.segmentsRadial) !== null && _f !== void 0 ? _f : 0;\n        message.openEnded = (_g = object.openEnded) !== null && _g !== void 0 ? _g : false;\n        message.radius = (_h = object.radius) !== null && _h !== void 0 ? _h : 0;\n        message.arc = (_j = object.arc) !== null && _j !== void 0 ? _j : 0;\n        return message;\n    },\n};\nfunction createBasePBGlobalPointerDown() {\n    return {};\n}\nconst PBGlobalPointerDown = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBGlobalPointerDown();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBasePBGlobalPointerDown();\n        return message;\n    },\n};\nfunction createBasePBGlobalPointerUp() {\n    return {};\n}\nconst PBGlobalPointerUp = {\n    encode(_, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBGlobalPointerUp();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(_) {\n        return {};\n    },\n    toJSON(_) {\n        const obj = {};\n        return obj;\n    },\n    fromPartial(_) {\n        const message = createBasePBGlobalPointerUp();\n        return message;\n    },\n};\nfunction createBasePBGLTFShape() {\n    return { withCollisions: false, visible: false, src: \"\" };\n}\nconst PBGLTFShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.src !== \"\") {\n            writer.uint32(26).string(message.src);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBGLTFShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.src = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            src: isSet(object.src) ? String(object.src) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.src !== undefined && (obj.src = message.src);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBGLTFShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.src = (_c = object.src) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBasePBMaterial() {\n    return {\n        alpha: 0,\n        albedoColor: undefined,\n        emissiveColor: undefined,\n        metallic: 0,\n        roughness: 0,\n        ambientColor: undefined,\n        reflectionColor: undefined,\n        reflectivityColor: undefined,\n        directIntensity: 0,\n        microSurface: 0,\n        emissiveIntensity: 0,\n        environmentIntensity: 0,\n        specularIntensity: 0,\n        albedoTexture: undefined,\n        alphaTexture: undefined,\n        emissiveTexture: undefined,\n        bumpTexture: undefined,\n        refractionTexture: undefined,\n        disableLighting: false,\n        transparencyMode: 0,\n        hasAlpha: false,\n    };\n}\nconst PBMaterial = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.alpha !== 0) {\n            writer.uint32(13).float(message.alpha);\n        }\n        if (message.albedoColor !== undefined) {\n            PBColor3.encode(message.albedoColor, writer.uint32(18).fork()).ldelim();\n        }\n        if (message.emissiveColor !== undefined) {\n            PBColor3.encode(message.emissiveColor, writer.uint32(26).fork()).ldelim();\n        }\n        if (message.metallic !== 0) {\n            writer.uint32(37).float(message.metallic);\n        }\n        if (message.roughness !== 0) {\n            writer.uint32(45).float(message.roughness);\n        }\n        if (message.ambientColor !== undefined) {\n            PBColor3.encode(message.ambientColor, writer.uint32(50).fork()).ldelim();\n        }\n        if (message.reflectionColor !== undefined) {\n            PBColor3.encode(message.reflectionColor, writer.uint32(58).fork()).ldelim();\n        }\n        if (message.reflectivityColor !== undefined) {\n            PBColor3.encode(message.reflectivityColor, writer.uint32(66).fork()).ldelim();\n        }\n        if (message.directIntensity !== 0) {\n            writer.uint32(77).float(message.directIntensity);\n        }\n        if (message.microSurface !== 0) {\n            writer.uint32(85).float(message.microSurface);\n        }\n        if (message.emissiveIntensity !== 0) {\n            writer.uint32(93).float(message.emissiveIntensity);\n        }\n        if (message.environmentIntensity !== 0) {\n            writer.uint32(101).float(message.environmentIntensity);\n        }\n        if (message.specularIntensity !== 0) {\n            writer.uint32(109).float(message.specularIntensity);\n        }\n        if (message.albedoTexture !== undefined) {\n            PBTexture.encode(message.albedoTexture, writer.uint32(114).fork()).ldelim();\n        }\n        if (message.alphaTexture !== undefined) {\n            PBTexture.encode(message.alphaTexture, writer.uint32(122).fork()).ldelim();\n        }\n        if (message.emissiveTexture !== undefined) {\n            PBTexture.encode(message.emissiveTexture, writer.uint32(130).fork()).ldelim();\n        }\n        if (message.bumpTexture !== undefined) {\n            PBTexture.encode(message.bumpTexture, writer.uint32(138).fork()).ldelim();\n        }\n        if (message.refractionTexture !== undefined) {\n            PBTexture.encode(message.refractionTexture, writer.uint32(146).fork()).ldelim();\n        }\n        if (message.disableLighting === true) {\n            writer.uint32(152).bool(message.disableLighting);\n        }\n        if (message.transparencyMode !== 0) {\n            writer.uint32(165).float(message.transparencyMode);\n        }\n        if (message.hasAlpha === true) {\n            writer.uint32(168).bool(message.hasAlpha);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBMaterial();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.alpha = reader.float();\n                    break;\n                case 2:\n                    message.albedoColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 3:\n                    message.emissiveColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 4:\n                    message.metallic = reader.float();\n                    break;\n                case 5:\n                    message.roughness = reader.float();\n                    break;\n                case 6:\n                    message.ambientColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 7:\n                    message.reflectionColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 8:\n                    message.reflectivityColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 9:\n                    message.directIntensity = reader.float();\n                    break;\n                case 10:\n                    message.microSurface = reader.float();\n                    break;\n                case 11:\n                    message.emissiveIntensity = reader.float();\n                    break;\n                case 12:\n                    message.environmentIntensity = reader.float();\n                    break;\n                case 13:\n                    message.specularIntensity = reader.float();\n                    break;\n                case 14:\n                    message.albedoTexture = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.alphaTexture = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 16:\n                    message.emissiveTexture = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.bumpTexture = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 18:\n                    message.refractionTexture = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 19:\n                    message.disableLighting = reader.bool();\n                    break;\n                case 20:\n                    message.transparencyMode = reader.float();\n                    break;\n                case 21:\n                    message.hasAlpha = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            alpha: isSet(object.alpha) ? Number(object.alpha) : 0,\n            albedoColor: isSet(object.albedoColor) ? PBColor3.fromJSON(object.albedoColor) : undefined,\n            emissiveColor: isSet(object.emissiveColor) ? PBColor3.fromJSON(object.emissiveColor) : undefined,\n            metallic: isSet(object.metallic) ? Number(object.metallic) : 0,\n            roughness: isSet(object.roughness) ? Number(object.roughness) : 0,\n            ambientColor: isSet(object.ambientColor) ? PBColor3.fromJSON(object.ambientColor) : undefined,\n            reflectionColor: isSet(object.reflectionColor) ? PBColor3.fromJSON(object.reflectionColor) : undefined,\n            reflectivityColor: isSet(object.reflectivityColor) ? PBColor3.fromJSON(object.reflectivityColor) : undefined,\n            directIntensity: isSet(object.directIntensity) ? Number(object.directIntensity) : 0,\n            microSurface: isSet(object.microSurface) ? Number(object.microSurface) : 0,\n            emissiveIntensity: isSet(object.emissiveIntensity) ? Number(object.emissiveIntensity) : 0,\n            environmentIntensity: isSet(object.environmentIntensity) ? Number(object.environmentIntensity) : 0,\n            specularIntensity: isSet(object.specularIntensity) ? Number(object.specularIntensity) : 0,\n            albedoTexture: isSet(object.albedoTexture) ? PBTexture.fromJSON(object.albedoTexture) : undefined,\n            alphaTexture: isSet(object.alphaTexture) ? PBTexture.fromJSON(object.alphaTexture) : undefined,\n            emissiveTexture: isSet(object.emissiveTexture) ? PBTexture.fromJSON(object.emissiveTexture) : undefined,\n            bumpTexture: isSet(object.bumpTexture) ? PBTexture.fromJSON(object.bumpTexture) : undefined,\n            refractionTexture: isSet(object.refractionTexture) ? PBTexture.fromJSON(object.refractionTexture) : undefined,\n            disableLighting: isSet(object.disableLighting) ? Boolean(object.disableLighting) : false,\n            transparencyMode: isSet(object.transparencyMode) ? Number(object.transparencyMode) : 0,\n            hasAlpha: isSet(object.hasAlpha) ? Boolean(object.hasAlpha) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.alpha !== undefined && (obj.alpha = message.alpha);\n        message.albedoColor !== undefined &&\n            (obj.albedoColor = message.albedoColor ? PBColor3.toJSON(message.albedoColor) : undefined);\n        message.emissiveColor !== undefined &&\n            (obj.emissiveColor = message.emissiveColor ? PBColor3.toJSON(message.emissiveColor) : undefined);\n        message.metallic !== undefined && (obj.metallic = message.metallic);\n        message.roughness !== undefined && (obj.roughness = message.roughness);\n        message.ambientColor !== undefined &&\n            (obj.ambientColor = message.ambientColor ? PBColor3.toJSON(message.ambientColor) : undefined);\n        message.reflectionColor !== undefined &&\n            (obj.reflectionColor = message.reflectionColor ? PBColor3.toJSON(message.reflectionColor) : undefined);\n        message.reflectivityColor !== undefined &&\n            (obj.reflectivityColor = message.reflectivityColor ? PBColor3.toJSON(message.reflectivityColor) : undefined);\n        message.directIntensity !== undefined && (obj.directIntensity = message.directIntensity);\n        message.microSurface !== undefined && (obj.microSurface = message.microSurface);\n        message.emissiveIntensity !== undefined && (obj.emissiveIntensity = message.emissiveIntensity);\n        message.environmentIntensity !== undefined && (obj.environmentIntensity = message.environmentIntensity);\n        message.specularIntensity !== undefined && (obj.specularIntensity = message.specularIntensity);\n        message.albedoTexture !== undefined &&\n            (obj.albedoTexture = message.albedoTexture ? PBTexture.toJSON(message.albedoTexture) : undefined);\n        message.alphaTexture !== undefined &&\n            (obj.alphaTexture = message.alphaTexture ? PBTexture.toJSON(message.alphaTexture) : undefined);\n        message.emissiveTexture !== undefined &&\n            (obj.emissiveTexture = message.emissiveTexture ? PBTexture.toJSON(message.emissiveTexture) : undefined);\n        message.bumpTexture !== undefined &&\n            (obj.bumpTexture = message.bumpTexture ? PBTexture.toJSON(message.bumpTexture) : undefined);\n        message.refractionTexture !== undefined &&\n            (obj.refractionTexture = message.refractionTexture ? PBTexture.toJSON(message.refractionTexture) : undefined);\n        message.disableLighting !== undefined && (obj.disableLighting = message.disableLighting);\n        message.transparencyMode !== undefined && (obj.transparencyMode = message.transparencyMode);\n        message.hasAlpha !== undefined && (obj.hasAlpha = message.hasAlpha);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;\n        const message = createBasePBMaterial();\n        message.alpha = (_a = object.alpha) !== null && _a !== void 0 ? _a : 0;\n        message.albedoColor = (object.albedoColor !== undefined && object.albedoColor !== null)\n            ? PBColor3.fromPartial(object.albedoColor)\n            : undefined;\n        message.emissiveColor = (object.emissiveColor !== undefined && object.emissiveColor !== null)\n            ? PBColor3.fromPartial(object.emissiveColor)\n            : undefined;\n        message.metallic = (_b = object.metallic) !== null && _b !== void 0 ? _b : 0;\n        message.roughness = (_c = object.roughness) !== null && _c !== void 0 ? _c : 0;\n        message.ambientColor = (object.ambientColor !== undefined && object.ambientColor !== null)\n            ? PBColor3.fromPartial(object.ambientColor)\n            : undefined;\n        message.reflectionColor = (object.reflectionColor !== undefined && object.reflectionColor !== null)\n            ? PBColor3.fromPartial(object.reflectionColor)\n            : undefined;\n        message.reflectivityColor = (object.reflectivityColor !== undefined && object.reflectivityColor !== null)\n            ? PBColor3.fromPartial(object.reflectivityColor)\n            : undefined;\n        message.directIntensity = (_d = object.directIntensity) !== null && _d !== void 0 ? _d : 0;\n        message.microSurface = (_e = object.microSurface) !== null && _e !== void 0 ? _e : 0;\n        message.emissiveIntensity = (_f = object.emissiveIntensity) !== null && _f !== void 0 ? _f : 0;\n        message.environmentIntensity = (_g = object.environmentIntensity) !== null && _g !== void 0 ? _g : 0;\n        message.specularIntensity = (_h = object.specularIntensity) !== null && _h !== void 0 ? _h : 0;\n        message.albedoTexture = (object.albedoTexture !== undefined && object.albedoTexture !== null)\n            ? PBTexture.fromPartial(object.albedoTexture)\n            : undefined;\n        message.alphaTexture = (object.alphaTexture !== undefined && object.alphaTexture !== null)\n            ? PBTexture.fromPartial(object.alphaTexture)\n            : undefined;\n        message.emissiveTexture = (object.emissiveTexture !== undefined && object.emissiveTexture !== null)\n            ? PBTexture.fromPartial(object.emissiveTexture)\n            : undefined;\n        message.bumpTexture = (object.bumpTexture !== undefined && object.bumpTexture !== null)\n            ? PBTexture.fromPartial(object.bumpTexture)\n            : undefined;\n        message.refractionTexture = (object.refractionTexture !== undefined && object.refractionTexture !== null)\n            ? PBTexture.fromPartial(object.refractionTexture)\n            : undefined;\n        message.disableLighting = (_j = object.disableLighting) !== null && _j !== void 0 ? _j : false;\n        message.transparencyMode = (_k = object.transparencyMode) !== null && _k !== void 0 ? _k : 0;\n        message.hasAlpha = (_l = object.hasAlpha) !== null && _l !== void 0 ? _l : false;\n        return message;\n    },\n};\nfunction createBasePBNFTShape() {\n    return { withCollisions: false, visible: false, src: \"\", color: undefined };\n}\nconst PBNFTShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.src !== \"\") {\n            writer.uint32(26).string(message.src);\n        }\n        if (message.color !== undefined) {\n            PBColor3.encode(message.color, writer.uint32(34).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBNFTShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.src = reader.string();\n                    break;\n                case 4:\n                    message.color = PBColor3.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            src: isSet(object.src) ? String(object.src) : \"\",\n            color: isSet(object.color) ? PBColor3.fromJSON(object.color) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.src !== undefined && (obj.src = message.src);\n        message.color !== undefined && (obj.color = message.color ? PBColor3.toJSON(message.color) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBNFTShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.src = (_c = object.src) !== null && _c !== void 0 ? _c : \"\";\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor3.fromPartial(object.color)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBOBJShape() {\n    return { withCollisions: false, visible: false, src: \"\" };\n}\nconst PBOBJShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.src !== \"\") {\n            writer.uint32(26).string(message.src);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBOBJShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.src = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            src: isSet(object.src) ? String(object.src) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.src !== undefined && (obj.src = message.src);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBOBJShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.src = (_c = object.src) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nfunction createBasePBPlaneShape() {\n    return { withCollisions: false, visible: false, width: 0, height: 0, uvs: [] };\n}\nconst PBPlaneShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.width !== 0) {\n            writer.uint32(29).float(message.width);\n        }\n        if (message.height !== 0) {\n            writer.uint32(37).float(message.height);\n        }\n        writer.uint32(42).fork();\n        for (const v of message.uvs) {\n            writer.float(v);\n        }\n        writer.ldelim();\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBPlaneShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.width = reader.float();\n                    break;\n                case 4:\n                    message.height = reader.float();\n                    break;\n                case 5:\n                    if ((tag & 7) === 2) {\n                        const end2 = reader.uint32() + reader.pos;\n                        while (reader.pos < end2) {\n                            message.uvs.push(reader.float());\n                        }\n                    }\n                    else {\n                        message.uvs.push(reader.float());\n                    }\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            width: isSet(object.width) ? Number(object.width) : 0,\n            height: isSet(object.height) ? Number(object.height) : 0,\n            uvs: Array.isArray(object === null || object === void 0 ? void 0 : object.uvs) ? object.uvs.map((e) => Number(e)) : [],\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        if (message.uvs) {\n            obj.uvs = message.uvs.map((e) => e);\n        }\n        else {\n            obj.uvs = [];\n        }\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e;\n        const message = createBasePBPlaneShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.width = (_c = object.width) !== null && _c !== void 0 ? _c : 0;\n        message.height = (_d = object.height) !== null && _d !== void 0 ? _d : 0;\n        message.uvs = ((_e = object.uvs) === null || _e === void 0 ? void 0 : _e.map((e) => e)) || [];\n        return message;\n    },\n};\nfunction createBasePBShape() {\n    return { withCollisions: false, visible: false };\n}\nconst PBShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBasePBSphereShape() {\n    return { withCollisions: false, visible: false };\n}\nconst PBSphereShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBSphereShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBSphereShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        return message;\n    },\n};\nfunction createBasePBTextShape() {\n    return {\n        withCollisions: false,\n        visible: false,\n        outlineWidth: 0,\n        outlineColor: undefined,\n        color: undefined,\n        fontSize: 0,\n        fontWeight: \"\",\n        opacity: 0,\n        value: \"\",\n        lineSpacing: \"\",\n        lineCount: 0,\n        resizeToFit: false,\n        textWrapping: false,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        shadowColor: undefined,\n        zIndex: 0,\n        hTextAlign: \"\",\n        vTextAlign: \"\",\n        width: 0,\n        height: 0,\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        isPickable: false,\n        billboard: false,\n    };\n}\nconst PBTextShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.withCollisions === true) {\n            writer.uint32(8).bool(message.withCollisions);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.outlineWidth !== 0) {\n            writer.uint32(29).float(message.outlineWidth);\n        }\n        if (message.outlineColor !== undefined) {\n            PBColor3.encode(message.outlineColor, writer.uint32(34).fork()).ldelim();\n        }\n        if (message.color !== undefined) {\n            PBColor3.encode(message.color, writer.uint32(42).fork()).ldelim();\n        }\n        if (message.fontSize !== 0) {\n            writer.uint32(53).float(message.fontSize);\n        }\n        if (message.fontWeight !== \"\") {\n            writer.uint32(58).string(message.fontWeight);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(69).float(message.opacity);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(74).string(message.value);\n        }\n        if (message.lineSpacing !== \"\") {\n            writer.uint32(82).string(message.lineSpacing);\n        }\n        if (message.lineCount !== 0) {\n            writer.uint32(93).float(message.lineCount);\n        }\n        if (message.resizeToFit === true) {\n            writer.uint32(96).bool(message.resizeToFit);\n        }\n        if (message.textWrapping === true) {\n            writer.uint32(104).bool(message.textWrapping);\n        }\n        if (message.shadowBlur !== 0) {\n            writer.uint32(117).float(message.shadowBlur);\n        }\n        if (message.shadowOffsetX !== 0) {\n            writer.uint32(125).float(message.shadowOffsetX);\n        }\n        if (message.shadowOffsetY !== 0) {\n            writer.uint32(133).float(message.shadowOffsetY);\n        }\n        if (message.shadowColor !== undefined) {\n            PBColor3.encode(message.shadowColor, writer.uint32(138).fork()).ldelim();\n        }\n        if (message.zIndex !== 0) {\n            writer.uint32(149).float(message.zIndex);\n        }\n        if (message.hTextAlign !== \"\") {\n            writer.uint32(154).string(message.hTextAlign);\n        }\n        if (message.vTextAlign !== \"\") {\n            writer.uint32(162).string(message.vTextAlign);\n        }\n        if (message.width !== 0) {\n            writer.uint32(173).float(message.width);\n        }\n        if (message.height !== 0) {\n            writer.uint32(181).float(message.height);\n        }\n        if (message.paddingTop !== 0) {\n            writer.uint32(189).float(message.paddingTop);\n        }\n        if (message.paddingRight !== 0) {\n            writer.uint32(197).float(message.paddingRight);\n        }\n        if (message.paddingBottom !== 0) {\n            writer.uint32(205).float(message.paddingBottom);\n        }\n        if (message.paddingLeft !== 0) {\n            writer.uint32(213).float(message.paddingLeft);\n        }\n        if (message.isPickable === true) {\n            writer.uint32(216).bool(message.isPickable);\n        }\n        if (message.billboard === true) {\n            writer.uint32(224).bool(message.billboard);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBTextShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.withCollisions = reader.bool();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.outlineWidth = reader.float();\n                    break;\n                case 4:\n                    message.outlineColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 5:\n                    message.color = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 6:\n                    message.fontSize = reader.float();\n                    break;\n                case 7:\n                    message.fontWeight = reader.string();\n                    break;\n                case 8:\n                    message.opacity = reader.float();\n                    break;\n                case 9:\n                    message.value = reader.string();\n                    break;\n                case 10:\n                    message.lineSpacing = reader.string();\n                    break;\n                case 11:\n                    message.lineCount = reader.float();\n                    break;\n                case 12:\n                    message.resizeToFit = reader.bool();\n                    break;\n                case 13:\n                    message.textWrapping = reader.bool();\n                    break;\n                case 14:\n                    message.shadowBlur = reader.float();\n                    break;\n                case 15:\n                    message.shadowOffsetX = reader.float();\n                    break;\n                case 16:\n                    message.shadowOffsetY = reader.float();\n                    break;\n                case 17:\n                    message.shadowColor = PBColor3.decode(reader, reader.uint32());\n                    break;\n                case 18:\n                    message.zIndex = reader.float();\n                    break;\n                case 19:\n                    message.hTextAlign = reader.string();\n                    break;\n                case 20:\n                    message.vTextAlign = reader.string();\n                    break;\n                case 21:\n                    message.width = reader.float();\n                    break;\n                case 22:\n                    message.height = reader.float();\n                    break;\n                case 23:\n                    message.paddingTop = reader.float();\n                    break;\n                case 24:\n                    message.paddingRight = reader.float();\n                    break;\n                case 25:\n                    message.paddingBottom = reader.float();\n                    break;\n                case 26:\n                    message.paddingLeft = reader.float();\n                    break;\n                case 27:\n                    message.isPickable = reader.bool();\n                    break;\n                case 28:\n                    message.billboard = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            withCollisions: isSet(object.withCollisions) ? Boolean(object.withCollisions) : false,\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            outlineWidth: isSet(object.outlineWidth) ? Number(object.outlineWidth) : 0,\n            outlineColor: isSet(object.outlineColor) ? PBColor3.fromJSON(object.outlineColor) : undefined,\n            color: isSet(object.color) ? PBColor3.fromJSON(object.color) : undefined,\n            fontSize: isSet(object.fontSize) ? Number(object.fontSize) : 0,\n            fontWeight: isSet(object.fontWeight) ? String(object.fontWeight) : \"\",\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            value: isSet(object.value) ? String(object.value) : \"\",\n            lineSpacing: isSet(object.lineSpacing) ? String(object.lineSpacing) : \"\",\n            lineCount: isSet(object.lineCount) ? Number(object.lineCount) : 0,\n            resizeToFit: isSet(object.resizeToFit) ? Boolean(object.resizeToFit) : false,\n            textWrapping: isSet(object.textWrapping) ? Boolean(object.textWrapping) : false,\n            shadowBlur: isSet(object.shadowBlur) ? Number(object.shadowBlur) : 0,\n            shadowOffsetX: isSet(object.shadowOffsetX) ? Number(object.shadowOffsetX) : 0,\n            shadowOffsetY: isSet(object.shadowOffsetY) ? Number(object.shadowOffsetY) : 0,\n            shadowColor: isSet(object.shadowColor) ? PBColor3.fromJSON(object.shadowColor) : undefined,\n            zIndex: isSet(object.zIndex) ? Number(object.zIndex) : 0,\n            hTextAlign: isSet(object.hTextAlign) ? String(object.hTextAlign) : \"\",\n            vTextAlign: isSet(object.vTextAlign) ? String(object.vTextAlign) : \"\",\n            width: isSet(object.width) ? Number(object.width) : 0,\n            height: isSet(object.height) ? Number(object.height) : 0,\n            paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : 0,\n            paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : 0,\n            paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : 0,\n            paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : 0,\n            isPickable: isSet(object.isPickable) ? Boolean(object.isPickable) : false,\n            billboard: isSet(object.billboard) ? Boolean(object.billboard) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.withCollisions !== undefined && (obj.withCollisions = message.withCollisions);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.outlineWidth !== undefined && (obj.outlineWidth = message.outlineWidth);\n        message.outlineColor !== undefined &&\n            (obj.outlineColor = message.outlineColor ? PBColor3.toJSON(message.outlineColor) : undefined);\n        message.color !== undefined && (obj.color = message.color ? PBColor3.toJSON(message.color) : undefined);\n        message.fontSize !== undefined && (obj.fontSize = message.fontSize);\n        message.fontWeight !== undefined && (obj.fontWeight = message.fontWeight);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.value !== undefined && (obj.value = message.value);\n        message.lineSpacing !== undefined && (obj.lineSpacing = message.lineSpacing);\n        message.lineCount !== undefined && (obj.lineCount = message.lineCount);\n        message.resizeToFit !== undefined && (obj.resizeToFit = message.resizeToFit);\n        message.textWrapping !== undefined && (obj.textWrapping = message.textWrapping);\n        message.shadowBlur !== undefined && (obj.shadowBlur = message.shadowBlur);\n        message.shadowOffsetX !== undefined && (obj.shadowOffsetX = message.shadowOffsetX);\n        message.shadowOffsetY !== undefined && (obj.shadowOffsetY = message.shadowOffsetY);\n        message.shadowColor !== undefined &&\n            (obj.shadowColor = message.shadowColor ? PBColor3.toJSON(message.shadowColor) : undefined);\n        message.zIndex !== undefined && (obj.zIndex = message.zIndex);\n        message.hTextAlign !== undefined && (obj.hTextAlign = message.hTextAlign);\n        message.vTextAlign !== undefined && (obj.vTextAlign = message.vTextAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);\n        message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);\n        message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);\n        message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);\n        message.isPickable !== undefined && (obj.isPickable = message.isPickable);\n        message.billboard !== undefined && (obj.billboard = message.billboard);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0;\n        const message = createBasePBTextShape();\n        message.withCollisions = (_a = object.withCollisions) !== null && _a !== void 0 ? _a : false;\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.outlineWidth = (_c = object.outlineWidth) !== null && _c !== void 0 ? _c : 0;\n        message.outlineColor = (object.outlineColor !== undefined && object.outlineColor !== null)\n            ? PBColor3.fromPartial(object.outlineColor)\n            : undefined;\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor3.fromPartial(object.color)\n            : undefined;\n        message.fontSize = (_d = object.fontSize) !== null && _d !== void 0 ? _d : 0;\n        message.fontWeight = (_e = object.fontWeight) !== null && _e !== void 0 ? _e : \"\";\n        message.opacity = (_f = object.opacity) !== null && _f !== void 0 ? _f : 0;\n        message.value = (_g = object.value) !== null && _g !== void 0 ? _g : \"\";\n        message.lineSpacing = (_h = object.lineSpacing) !== null && _h !== void 0 ? _h : \"\";\n        message.lineCount = (_j = object.lineCount) !== null && _j !== void 0 ? _j : 0;\n        message.resizeToFit = (_k = object.resizeToFit) !== null && _k !== void 0 ? _k : false;\n        message.textWrapping = (_l = object.textWrapping) !== null && _l !== void 0 ? _l : false;\n        message.shadowBlur = (_m = object.shadowBlur) !== null && _m !== void 0 ? _m : 0;\n        message.shadowOffsetX = (_o = object.shadowOffsetX) !== null && _o !== void 0 ? _o : 0;\n        message.shadowOffsetY = (_p = object.shadowOffsetY) !== null && _p !== void 0 ? _p : 0;\n        message.shadowColor = (object.shadowColor !== undefined && object.shadowColor !== null)\n            ? PBColor3.fromPartial(object.shadowColor)\n            : undefined;\n        message.zIndex = (_q = object.zIndex) !== null && _q !== void 0 ? _q : 0;\n        message.hTextAlign = (_r = object.hTextAlign) !== null && _r !== void 0 ? _r : \"\";\n        message.vTextAlign = (_s = object.vTextAlign) !== null && _s !== void 0 ? _s : \"\";\n        message.width = (_t = object.width) !== null && _t !== void 0 ? _t : 0;\n        message.height = (_u = object.height) !== null && _u !== void 0 ? _u : 0;\n        message.paddingTop = (_v = object.paddingTop) !== null && _v !== void 0 ? _v : 0;\n        message.paddingRight = (_w = object.paddingRight) !== null && _w !== void 0 ? _w : 0;\n        message.paddingBottom = (_x = object.paddingBottom) !== null && _x !== void 0 ? _x : 0;\n        message.paddingLeft = (_y = object.paddingLeft) !== null && _y !== void 0 ? _y : 0;\n        message.isPickable = (_z = object.isPickable) !== null && _z !== void 0 ? _z : false;\n        message.billboard = (_0 = object.billboard) !== null && _0 !== void 0 ? _0 : false;\n        return message;\n    },\n};\nfunction createBasePBTexture() {\n    return { src: \"\", samplingMode: 0, wrap: 0, hasAlpha: false };\n}\nconst PBTexture = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.src !== \"\") {\n            writer.uint32(10).string(message.src);\n        }\n        if (message.samplingMode !== 0) {\n            writer.uint32(21).float(message.samplingMode);\n        }\n        if (message.wrap !== 0) {\n            writer.uint32(29).float(message.wrap);\n        }\n        if (message.hasAlpha === true) {\n            writer.uint32(32).bool(message.hasAlpha);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBTexture();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.src = reader.string();\n                    break;\n                case 2:\n                    message.samplingMode = reader.float();\n                    break;\n                case 3:\n                    message.wrap = reader.float();\n                    break;\n                case 4:\n                    message.hasAlpha = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            src: isSet(object.src) ? String(object.src) : \"\",\n            samplingMode: isSet(object.samplingMode) ? Number(object.samplingMode) : 0,\n            wrap: isSet(object.wrap) ? Number(object.wrap) : 0,\n            hasAlpha: isSet(object.hasAlpha) ? Boolean(object.hasAlpha) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.src !== undefined && (obj.src = message.src);\n        message.samplingMode !== undefined && (obj.samplingMode = message.samplingMode);\n        message.wrap !== undefined && (obj.wrap = message.wrap);\n        message.hasAlpha !== undefined && (obj.hasAlpha = message.hasAlpha);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d;\n        const message = createBasePBTexture();\n        message.src = (_a = object.src) !== null && _a !== void 0 ? _a : \"\";\n        message.samplingMode = (_b = object.samplingMode) !== null && _b !== void 0 ? _b : 0;\n        message.wrap = (_c = object.wrap) !== null && _c !== void 0 ? _c : 0;\n        message.hasAlpha = (_d = object.hasAlpha) !== null && _d !== void 0 ? _d : false;\n        return message;\n    },\n};\nfunction createBasePBUIButton() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n        fontSize: 0,\n        fontWeight: \"\",\n        thickness: 0,\n        cornerRadius: 0,\n        color: undefined,\n        background: undefined,\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        shadowColor: undefined,\n        text: \"\",\n    };\n}\nconst PBUIButton = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.fontSize !== 0) {\n            writer.uint32(101).float(message.fontSize);\n        }\n        if (message.fontWeight !== \"\") {\n            writer.uint32(106).string(message.fontWeight);\n        }\n        if (message.thickness !== 0) {\n            writer.uint32(117).float(message.thickness);\n        }\n        if (message.cornerRadius !== 0) {\n            writer.uint32(125).float(message.cornerRadius);\n        }\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(130).fork()).ldelim();\n        }\n        if (message.background !== undefined) {\n            PBColor4.encode(message.background, writer.uint32(138).fork()).ldelim();\n        }\n        if (message.paddingTop !== 0) {\n            writer.uint32(149).float(message.paddingTop);\n        }\n        if (message.paddingRight !== 0) {\n            writer.uint32(157).float(message.paddingRight);\n        }\n        if (message.paddingBottom !== 0) {\n            writer.uint32(165).float(message.paddingBottom);\n        }\n        if (message.paddingLeft !== 0) {\n            writer.uint32(173).float(message.paddingLeft);\n        }\n        if (message.shadowBlur !== 0) {\n            writer.uint32(181).float(message.shadowBlur);\n        }\n        if (message.shadowOffsetX !== 0) {\n            writer.uint32(189).float(message.shadowOffsetX);\n        }\n        if (message.shadowOffsetY !== 0) {\n            writer.uint32(197).float(message.shadowOffsetY);\n        }\n        if (message.shadowColor !== undefined) {\n            PBColor4.encode(message.shadowColor, writer.uint32(202).fork()).ldelim();\n        }\n        if (message.text !== \"\") {\n            writer.uint32(210).string(message.text);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUIButton();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.fontSize = reader.float();\n                    break;\n                case 13:\n                    message.fontWeight = reader.string();\n                    break;\n                case 14:\n                    message.thickness = reader.float();\n                    break;\n                case 15:\n                    message.cornerRadius = reader.float();\n                    break;\n                case 16:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.background = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 18:\n                    message.paddingTop = reader.float();\n                    break;\n                case 19:\n                    message.paddingRight = reader.float();\n                    break;\n                case 20:\n                    message.paddingBottom = reader.float();\n                    break;\n                case 21:\n                    message.paddingLeft = reader.float();\n                    break;\n                case 22:\n                    message.shadowBlur = reader.float();\n                    break;\n                case 23:\n                    message.shadowOffsetX = reader.float();\n                    break;\n                case 24:\n                    message.shadowOffsetY = reader.float();\n                    break;\n                case 25:\n                    message.shadowColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 26:\n                    message.text = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n            fontSize: isSet(object.fontSize) ? Number(object.fontSize) : 0,\n            fontWeight: isSet(object.fontWeight) ? String(object.fontWeight) : \"\",\n            thickness: isSet(object.thickness) ? Number(object.thickness) : 0,\n            cornerRadius: isSet(object.cornerRadius) ? Number(object.cornerRadius) : 0,\n            color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined,\n            background: isSet(object.background) ? PBColor4.fromJSON(object.background) : undefined,\n            paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : 0,\n            paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : 0,\n            paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : 0,\n            paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : 0,\n            shadowBlur: isSet(object.shadowBlur) ? Number(object.shadowBlur) : 0,\n            shadowOffsetX: isSet(object.shadowOffsetX) ? Number(object.shadowOffsetX) : 0,\n            shadowOffsetY: isSet(object.shadowOffsetY) ? Number(object.shadowOffsetY) : 0,\n            shadowColor: isSet(object.shadowColor) ? PBColor4.fromJSON(object.shadowColor) : undefined,\n            text: isSet(object.text) ? String(object.text) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        message.fontSize !== undefined && (obj.fontSize = message.fontSize);\n        message.fontWeight !== undefined && (obj.fontWeight = message.fontWeight);\n        message.thickness !== undefined && (obj.thickness = message.thickness);\n        message.cornerRadius !== undefined && (obj.cornerRadius = message.cornerRadius);\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        message.background !== undefined &&\n            (obj.background = message.background ? PBColor4.toJSON(message.background) : undefined);\n        message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);\n        message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);\n        message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);\n        message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);\n        message.shadowBlur !== undefined && (obj.shadowBlur = message.shadowBlur);\n        message.shadowOffsetX !== undefined && (obj.shadowOffsetX = message.shadowOffsetX);\n        message.shadowOffsetY !== undefined && (obj.shadowOffsetY = message.shadowOffsetY);\n        message.shadowColor !== undefined &&\n            (obj.shadowColor = message.shadowColor ? PBColor4.toJSON(message.shadowColor) : undefined);\n        message.text !== undefined && (obj.text = message.text);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x;\n        const message = createBasePBUIButton();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        message.fontSize = (_l = object.fontSize) !== null && _l !== void 0 ? _l : 0;\n        message.fontWeight = (_m = object.fontWeight) !== null && _m !== void 0 ? _m : \"\";\n        message.thickness = (_o = object.thickness) !== null && _o !== void 0 ? _o : 0;\n        message.cornerRadius = (_p = object.cornerRadius) !== null && _p !== void 0 ? _p : 0;\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        message.background = (object.background !== undefined && object.background !== null)\n            ? PBColor4.fromPartial(object.background)\n            : undefined;\n        message.paddingTop = (_q = object.paddingTop) !== null && _q !== void 0 ? _q : 0;\n        message.paddingRight = (_r = object.paddingRight) !== null && _r !== void 0 ? _r : 0;\n        message.paddingBottom = (_s = object.paddingBottom) !== null && _s !== void 0 ? _s : 0;\n        message.paddingLeft = (_t = object.paddingLeft) !== null && _t !== void 0 ? _t : 0;\n        message.shadowBlur = (_u = object.shadowBlur) !== null && _u !== void 0 ? _u : 0;\n        message.shadowOffsetX = (_v = object.shadowOffsetX) !== null && _v !== void 0 ? _v : 0;\n        message.shadowOffsetY = (_w = object.shadowOffsetY) !== null && _w !== void 0 ? _w : 0;\n        message.shadowColor = (object.shadowColor !== undefined && object.shadowColor !== null)\n            ? PBColor4.fromPartial(object.shadowColor)\n            : undefined;\n        message.text = (_x = object.text) !== null && _x !== void 0 ? _x : \"\";\n        return message;\n    },\n};\nfunction createBasePBUICanvas() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n    };\n}\nconst PBUICanvas = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUICanvas();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        const message = createBasePBUICanvas();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBUIContainerRect() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n        adaptWidth: false,\n        adaptHeight: false,\n        thickness: 0,\n        color: undefined,\n        alignmentUsesSize: false,\n    };\n}\nconst PBUIContainerRect = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.adaptWidth === true) {\n            writer.uint32(96).bool(message.adaptWidth);\n        }\n        if (message.adaptHeight === true) {\n            writer.uint32(104).bool(message.adaptHeight);\n        }\n        if (message.thickness !== 0) {\n            writer.uint32(117).float(message.thickness);\n        }\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(122).fork()).ldelim();\n        }\n        if (message.alignmentUsesSize === true) {\n            writer.uint32(128).bool(message.alignmentUsesSize);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUIContainerRect();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.adaptWidth = reader.bool();\n                    break;\n                case 13:\n                    message.adaptHeight = reader.bool();\n                    break;\n                case 14:\n                    message.thickness = reader.float();\n                    break;\n                case 15:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 16:\n                    message.alignmentUsesSize = reader.bool();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n            adaptWidth: isSet(object.adaptWidth) ? Boolean(object.adaptWidth) : false,\n            adaptHeight: isSet(object.adaptHeight) ? Boolean(object.adaptHeight) : false,\n            thickness: isSet(object.thickness) ? Number(object.thickness) : 0,\n            color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined,\n            alignmentUsesSize: isSet(object.alignmentUsesSize) ? Boolean(object.alignmentUsesSize) : false,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        message.adaptWidth !== undefined && (obj.adaptWidth = message.adaptWidth);\n        message.adaptHeight !== undefined && (obj.adaptHeight = message.adaptHeight);\n        message.thickness !== undefined && (obj.thickness = message.thickness);\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        message.alignmentUsesSize !== undefined && (obj.alignmentUsesSize = message.alignmentUsesSize);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        const message = createBasePBUIContainerRect();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        message.adaptWidth = (_l = object.adaptWidth) !== null && _l !== void 0 ? _l : false;\n        message.adaptHeight = (_m = object.adaptHeight) !== null && _m !== void 0 ? _m : false;\n        message.thickness = (_o = object.thickness) !== null && _o !== void 0 ? _o : 0;\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        message.alignmentUsesSize = (_p = object.alignmentUsesSize) !== null && _p !== void 0 ? _p : false;\n        return message;\n    },\n};\nfunction createBasePBUIContainerStack() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n        adaptWidth: false,\n        adaptHeight: false,\n        color: undefined,\n        stackOrientation: 0,\n        spacing: 0,\n    };\n}\nconst PBUIContainerStack = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.adaptWidth === true) {\n            writer.uint32(96).bool(message.adaptWidth);\n        }\n        if (message.adaptHeight === true) {\n            writer.uint32(104).bool(message.adaptHeight);\n        }\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(114).fork()).ldelim();\n        }\n        if (message.stackOrientation !== 0) {\n            writer.uint32(120).int32(message.stackOrientation);\n        }\n        if (message.spacing !== 0) {\n            writer.uint32(133).float(message.spacing);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUIContainerStack();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.adaptWidth = reader.bool();\n                    break;\n                case 13:\n                    message.adaptHeight = reader.bool();\n                    break;\n                case 14:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.stackOrientation = reader.int32();\n                    break;\n                case 16:\n                    message.spacing = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n            adaptWidth: isSet(object.adaptWidth) ? Boolean(object.adaptWidth) : false,\n            adaptHeight: isSet(object.adaptHeight) ? Boolean(object.adaptHeight) : false,\n            color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined,\n            stackOrientation: isSet(object.stackOrientation) ? pBUIStackOrientationFromJSON(object.stackOrientation) : 0,\n            spacing: isSet(object.spacing) ? Number(object.spacing) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        message.adaptWidth !== undefined && (obj.adaptWidth = message.adaptWidth);\n        message.adaptHeight !== undefined && (obj.adaptHeight = message.adaptHeight);\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        message.stackOrientation !== undefined &&\n            (obj.stackOrientation = pBUIStackOrientationToJSON(message.stackOrientation));\n        message.spacing !== undefined && (obj.spacing = message.spacing);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;\n        const message = createBasePBUIContainerStack();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        message.adaptWidth = (_l = object.adaptWidth) !== null && _l !== void 0 ? _l : false;\n        message.adaptHeight = (_m = object.adaptHeight) !== null && _m !== void 0 ? _m : false;\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        message.stackOrientation = (_o = object.stackOrientation) !== null && _o !== void 0 ? _o : 0;\n        message.spacing = (_p = object.spacing) !== null && _p !== void 0 ? _p : 0;\n        return message;\n    },\n};\nfunction createBasePBUIImage() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n        sourceLeft: 0,\n        sourceTop: 0,\n        sourceWidth: 0,\n        sourceHeight: 0,\n        source: undefined,\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        sizeInPixels: false,\n        onClick: undefined,\n    };\n}\nconst PBUIImage = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.sourceLeft !== 0) {\n            writer.uint32(101).float(message.sourceLeft);\n        }\n        if (message.sourceTop !== 0) {\n            writer.uint32(109).float(message.sourceTop);\n        }\n        if (message.sourceWidth !== 0) {\n            writer.uint32(117).float(message.sourceWidth);\n        }\n        if (message.sourceHeight !== 0) {\n            writer.uint32(125).float(message.sourceHeight);\n        }\n        if (message.source !== undefined) {\n            PBTexture.encode(message.source, writer.uint32(130).fork()).ldelim();\n        }\n        if (message.paddingTop !== 0) {\n            writer.uint32(141).float(message.paddingTop);\n        }\n        if (message.paddingRight !== 0) {\n            writer.uint32(149).float(message.paddingRight);\n        }\n        if (message.paddingBottom !== 0) {\n            writer.uint32(157).float(message.paddingBottom);\n        }\n        if (message.paddingLeft !== 0) {\n            writer.uint32(165).float(message.paddingLeft);\n        }\n        if (message.sizeInPixels === true) {\n            writer.uint32(168).bool(message.sizeInPixels);\n        }\n        if (message.onClick !== undefined) {\n            PBUUIDCallback.encode(message.onClick, writer.uint32(178).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUIImage();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.sourceLeft = reader.float();\n                    break;\n                case 13:\n                    message.sourceTop = reader.float();\n                    break;\n                case 14:\n                    message.sourceWidth = reader.float();\n                    break;\n                case 15:\n                    message.sourceHeight = reader.float();\n                    break;\n                case 16:\n                    message.source = PBTexture.decode(reader, reader.uint32());\n                    break;\n                case 17:\n                    message.paddingTop = reader.float();\n                    break;\n                case 18:\n                    message.paddingRight = reader.float();\n                    break;\n                case 19:\n                    message.paddingBottom = reader.float();\n                    break;\n                case 20:\n                    message.paddingLeft = reader.float();\n                    break;\n                case 21:\n                    message.sizeInPixels = reader.bool();\n                    break;\n                case 22:\n                    message.onClick = PBUUIDCallback.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n            sourceLeft: isSet(object.sourceLeft) ? Number(object.sourceLeft) : 0,\n            sourceTop: isSet(object.sourceTop) ? Number(object.sourceTop) : 0,\n            sourceWidth: isSet(object.sourceWidth) ? Number(object.sourceWidth) : 0,\n            sourceHeight: isSet(object.sourceHeight) ? Number(object.sourceHeight) : 0,\n            source: isSet(object.source) ? PBTexture.fromJSON(object.source) : undefined,\n            paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : 0,\n            paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : 0,\n            paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : 0,\n            paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : 0,\n            sizeInPixels: isSet(object.sizeInPixels) ? Boolean(object.sizeInPixels) : false,\n            onClick: isSet(object.onClick) ? PBUUIDCallback.fromJSON(object.onClick) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        message.sourceLeft !== undefined && (obj.sourceLeft = message.sourceLeft);\n        message.sourceTop !== undefined && (obj.sourceTop = message.sourceTop);\n        message.sourceWidth !== undefined && (obj.sourceWidth = message.sourceWidth);\n        message.sourceHeight !== undefined && (obj.sourceHeight = message.sourceHeight);\n        message.source !== undefined && (obj.source = message.source ? PBTexture.toJSON(message.source) : undefined);\n        message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);\n        message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);\n        message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);\n        message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);\n        message.sizeInPixels !== undefined && (obj.sizeInPixels = message.sizeInPixels);\n        message.onClick !== undefined &&\n            (obj.onClick = message.onClick ? PBUUIDCallback.toJSON(message.onClick) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u;\n        const message = createBasePBUIImage();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        message.sourceLeft = (_l = object.sourceLeft) !== null && _l !== void 0 ? _l : 0;\n        message.sourceTop = (_m = object.sourceTop) !== null && _m !== void 0 ? _m : 0;\n        message.sourceWidth = (_o = object.sourceWidth) !== null && _o !== void 0 ? _o : 0;\n        message.sourceHeight = (_p = object.sourceHeight) !== null && _p !== void 0 ? _p : 0;\n        message.source = (object.source !== undefined && object.source !== null)\n            ? PBTexture.fromPartial(object.source)\n            : undefined;\n        message.paddingTop = (_q = object.paddingTop) !== null && _q !== void 0 ? _q : 0;\n        message.paddingRight = (_r = object.paddingRight) !== null && _r !== void 0 ? _r : 0;\n        message.paddingBottom = (_s = object.paddingBottom) !== null && _s !== void 0 ? _s : 0;\n        message.paddingLeft = (_t = object.paddingLeft) !== null && _t !== void 0 ? _t : 0;\n        message.sizeInPixels = (_u = object.sizeInPixels) !== null && _u !== void 0 ? _u : false;\n        message.onClick = (object.onClick !== undefined && object.onClick !== null)\n            ? PBUUIDCallback.fromPartial(object.onClick)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBUUIDCallback() {\n    return { type: \"\", uuid: \"\" };\n}\nconst PBUUIDCallback = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.type !== \"\") {\n            writer.uint32(10).string(message.type);\n        }\n        if (message.uuid !== \"\") {\n            writer.uint32(18).string(message.uuid);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUUIDCallback();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.type = reader.string();\n                    break;\n                case 2:\n                    message.uuid = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { type: isSet(object.type) ? String(object.type) : \"\", uuid: isSet(object.uuid) ? String(object.uuid) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.type !== undefined && (obj.type = message.type);\n        message.uuid !== undefined && (obj.uuid = message.uuid);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b;\n        const message = createBasePBUUIDCallback();\n        message.type = (_a = object.type) !== null && _a !== void 0 ? _a : \"\";\n        message.uuid = (_b = object.uuid) !== null && _b !== void 0 ? _b : \"\";\n        return message;\n    },\n};\nfunction createBasePBUIInputText() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n        outlineWidth: 0,\n        outlineColor: undefined,\n        color: undefined,\n        thickness: 0,\n        fontSize: 0,\n        fontWeight: \"\",\n        value: \"\",\n        placeholderColor: undefined,\n        placeholder: \"\",\n        margin: 0,\n        maxWidth: 0,\n        hTextAlign: \"\",\n        vTextAlign: \"\",\n        autoStretchWidth: false,\n        background: undefined,\n        focusedBackground: undefined,\n        textWrapping: false,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        shadowColor: undefined,\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        onTextSubmit: undefined,\n        onChanged: undefined,\n        onFocus: undefined,\n        onBlur: undefined,\n    };\n}\nconst PBUIInputText = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.outlineWidth !== 0) {\n            writer.uint32(101).float(message.outlineWidth);\n        }\n        if (message.outlineColor !== undefined) {\n            PBColor4.encode(message.outlineColor, writer.uint32(106).fork()).ldelim();\n        }\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(114).fork()).ldelim();\n        }\n        if (message.thickness !== 0) {\n            writer.uint32(125).float(message.thickness);\n        }\n        if (message.fontSize !== 0) {\n            writer.uint32(133).float(message.fontSize);\n        }\n        if (message.fontWeight !== \"\") {\n            writer.uint32(138).string(message.fontWeight);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(146).string(message.value);\n        }\n        if (message.placeholderColor !== undefined) {\n            PBColor4.encode(message.placeholderColor, writer.uint32(154).fork()).ldelim();\n        }\n        if (message.placeholder !== \"\") {\n            writer.uint32(162).string(message.placeholder);\n        }\n        if (message.margin !== 0) {\n            writer.uint32(173).float(message.margin);\n        }\n        if (message.maxWidth !== 0) {\n            writer.uint32(181).float(message.maxWidth);\n        }\n        if (message.hTextAlign !== \"\") {\n            writer.uint32(186).string(message.hTextAlign);\n        }\n        if (message.vTextAlign !== \"\") {\n            writer.uint32(194).string(message.vTextAlign);\n        }\n        if (message.autoStretchWidth === true) {\n            writer.uint32(200).bool(message.autoStretchWidth);\n        }\n        if (message.background !== undefined) {\n            PBColor4.encode(message.background, writer.uint32(210).fork()).ldelim();\n        }\n        if (message.focusedBackground !== undefined) {\n            PBColor4.encode(message.focusedBackground, writer.uint32(218).fork()).ldelim();\n        }\n        if (message.textWrapping === true) {\n            writer.uint32(224).bool(message.textWrapping);\n        }\n        if (message.shadowBlur !== 0) {\n            writer.uint32(237).float(message.shadowBlur);\n        }\n        if (message.shadowOffsetX !== 0) {\n            writer.uint32(245).float(message.shadowOffsetX);\n        }\n        if (message.shadowOffsetY !== 0) {\n            writer.uint32(253).float(message.shadowOffsetY);\n        }\n        if (message.shadowColor !== undefined) {\n            PBColor4.encode(message.shadowColor, writer.uint32(258).fork()).ldelim();\n        }\n        if (message.paddingTop !== 0) {\n            writer.uint32(269).float(message.paddingTop);\n        }\n        if (message.paddingRight !== 0) {\n            writer.uint32(277).float(message.paddingRight);\n        }\n        if (message.paddingBottom !== 0) {\n            writer.uint32(285).float(message.paddingBottom);\n        }\n        if (message.paddingLeft !== 0) {\n            writer.uint32(293).float(message.paddingLeft);\n        }\n        if (message.onTextSubmit !== undefined) {\n            PBUUIDCallback.encode(message.onTextSubmit, writer.uint32(298).fork()).ldelim();\n        }\n        if (message.onChanged !== undefined) {\n            PBUUIDCallback.encode(message.onChanged, writer.uint32(306).fork()).ldelim();\n        }\n        if (message.onFocus !== undefined) {\n            PBUUIDCallback.encode(message.onFocus, writer.uint32(314).fork()).ldelim();\n        }\n        if (message.onBlur !== undefined) {\n            PBUUIDCallback.encode(message.onBlur, writer.uint32(322).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUIInputText();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.outlineWidth = reader.float();\n                    break;\n                case 13:\n                    message.outlineColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.thickness = reader.float();\n                    break;\n                case 16:\n                    message.fontSize = reader.float();\n                    break;\n                case 17:\n                    message.fontWeight = reader.string();\n                    break;\n                case 18:\n                    message.value = reader.string();\n                    break;\n                case 19:\n                    message.placeholderColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 20:\n                    message.placeholder = reader.string();\n                    break;\n                case 21:\n                    message.margin = reader.float();\n                    break;\n                case 22:\n                    message.maxWidth = reader.float();\n                    break;\n                case 23:\n                    message.hTextAlign = reader.string();\n                    break;\n                case 24:\n                    message.vTextAlign = reader.string();\n                    break;\n                case 25:\n                    message.autoStretchWidth = reader.bool();\n                    break;\n                case 26:\n                    message.background = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 27:\n                    message.focusedBackground = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 28:\n                    message.textWrapping = reader.bool();\n                    break;\n                case 29:\n                    message.shadowBlur = reader.float();\n                    break;\n                case 30:\n                    message.shadowOffsetX = reader.float();\n                    break;\n                case 31:\n                    message.shadowOffsetY = reader.float();\n                    break;\n                case 32:\n                    message.shadowColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 33:\n                    message.paddingTop = reader.float();\n                    break;\n                case 34:\n                    message.paddingRight = reader.float();\n                    break;\n                case 35:\n                    message.paddingBottom = reader.float();\n                    break;\n                case 36:\n                    message.paddingLeft = reader.float();\n                    break;\n                case 37:\n                    message.onTextSubmit = PBUUIDCallback.decode(reader, reader.uint32());\n                    break;\n                case 38:\n                    message.onChanged = PBUUIDCallback.decode(reader, reader.uint32());\n                    break;\n                case 39:\n                    message.onFocus = PBUUIDCallback.decode(reader, reader.uint32());\n                    break;\n                case 40:\n                    message.onBlur = PBUUIDCallback.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n            outlineWidth: isSet(object.outlineWidth) ? Number(object.outlineWidth) : 0,\n            outlineColor: isSet(object.outlineColor) ? PBColor4.fromJSON(object.outlineColor) : undefined,\n            color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined,\n            thickness: isSet(object.thickness) ? Number(object.thickness) : 0,\n            fontSize: isSet(object.fontSize) ? Number(object.fontSize) : 0,\n            fontWeight: isSet(object.fontWeight) ? String(object.fontWeight) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n            placeholderColor: isSet(object.placeholderColor) ? PBColor4.fromJSON(object.placeholderColor) : undefined,\n            placeholder: isSet(object.placeholder) ? String(object.placeholder) : \"\",\n            margin: isSet(object.margin) ? Number(object.margin) : 0,\n            maxWidth: isSet(object.maxWidth) ? Number(object.maxWidth) : 0,\n            hTextAlign: isSet(object.hTextAlign) ? String(object.hTextAlign) : \"\",\n            vTextAlign: isSet(object.vTextAlign) ? String(object.vTextAlign) : \"\",\n            autoStretchWidth: isSet(object.autoStretchWidth) ? Boolean(object.autoStretchWidth) : false,\n            background: isSet(object.background) ? PBColor4.fromJSON(object.background) : undefined,\n            focusedBackground: isSet(object.focusedBackground) ? PBColor4.fromJSON(object.focusedBackground) : undefined,\n            textWrapping: isSet(object.textWrapping) ? Boolean(object.textWrapping) : false,\n            shadowBlur: isSet(object.shadowBlur) ? Number(object.shadowBlur) : 0,\n            shadowOffsetX: isSet(object.shadowOffsetX) ? Number(object.shadowOffsetX) : 0,\n            shadowOffsetY: isSet(object.shadowOffsetY) ? Number(object.shadowOffsetY) : 0,\n            shadowColor: isSet(object.shadowColor) ? PBColor4.fromJSON(object.shadowColor) : undefined,\n            paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : 0,\n            paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : 0,\n            paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : 0,\n            paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : 0,\n            onTextSubmit: isSet(object.onTextSubmit) ? PBUUIDCallback.fromJSON(object.onTextSubmit) : undefined,\n            onChanged: isSet(object.onChanged) ? PBUUIDCallback.fromJSON(object.onChanged) : undefined,\n            onFocus: isSet(object.onFocus) ? PBUUIDCallback.fromJSON(object.onFocus) : undefined,\n            onBlur: isSet(object.onBlur) ? PBUUIDCallback.fromJSON(object.onBlur) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        message.outlineWidth !== undefined && (obj.outlineWidth = message.outlineWidth);\n        message.outlineColor !== undefined &&\n            (obj.outlineColor = message.outlineColor ? PBColor4.toJSON(message.outlineColor) : undefined);\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        message.thickness !== undefined && (obj.thickness = message.thickness);\n        message.fontSize !== undefined && (obj.fontSize = message.fontSize);\n        message.fontWeight !== undefined && (obj.fontWeight = message.fontWeight);\n        message.value !== undefined && (obj.value = message.value);\n        message.placeholderColor !== undefined &&\n            (obj.placeholderColor = message.placeholderColor ? PBColor4.toJSON(message.placeholderColor) : undefined);\n        message.placeholder !== undefined && (obj.placeholder = message.placeholder);\n        message.margin !== undefined && (obj.margin = message.margin);\n        message.maxWidth !== undefined && (obj.maxWidth = message.maxWidth);\n        message.hTextAlign !== undefined && (obj.hTextAlign = message.hTextAlign);\n        message.vTextAlign !== undefined && (obj.vTextAlign = message.vTextAlign);\n        message.autoStretchWidth !== undefined && (obj.autoStretchWidth = message.autoStretchWidth);\n        message.background !== undefined &&\n            (obj.background = message.background ? PBColor4.toJSON(message.background) : undefined);\n        message.focusedBackground !== undefined &&\n            (obj.focusedBackground = message.focusedBackground ? PBColor4.toJSON(message.focusedBackground) : undefined);\n        message.textWrapping !== undefined && (obj.textWrapping = message.textWrapping);\n        message.shadowBlur !== undefined && (obj.shadowBlur = message.shadowBlur);\n        message.shadowOffsetX !== undefined && (obj.shadowOffsetX = message.shadowOffsetX);\n        message.shadowOffsetY !== undefined && (obj.shadowOffsetY = message.shadowOffsetY);\n        message.shadowColor !== undefined &&\n            (obj.shadowColor = message.shadowColor ? PBColor4.toJSON(message.shadowColor) : undefined);\n        message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);\n        message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);\n        message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);\n        message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);\n        message.onTextSubmit !== undefined &&\n            (obj.onTextSubmit = message.onTextSubmit ? PBUUIDCallback.toJSON(message.onTextSubmit) : undefined);\n        message.onChanged !== undefined &&\n            (obj.onChanged = message.onChanged ? PBUUIDCallback.toJSON(message.onChanged) : undefined);\n        message.onFocus !== undefined &&\n            (obj.onFocus = message.onFocus ? PBUUIDCallback.toJSON(message.onFocus) : undefined);\n        message.onBlur !== undefined && (obj.onBlur = message.onBlur ? PBUUIDCallback.toJSON(message.onBlur) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;\n        const message = createBasePBUIInputText();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        message.outlineWidth = (_l = object.outlineWidth) !== null && _l !== void 0 ? _l : 0;\n        message.outlineColor = (object.outlineColor !== undefined && object.outlineColor !== null)\n            ? PBColor4.fromPartial(object.outlineColor)\n            : undefined;\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        message.thickness = (_m = object.thickness) !== null && _m !== void 0 ? _m : 0;\n        message.fontSize = (_o = object.fontSize) !== null && _o !== void 0 ? _o : 0;\n        message.fontWeight = (_p = object.fontWeight) !== null && _p !== void 0 ? _p : \"\";\n        message.value = (_q = object.value) !== null && _q !== void 0 ? _q : \"\";\n        message.placeholderColor = (object.placeholderColor !== undefined && object.placeholderColor !== null)\n            ? PBColor4.fromPartial(object.placeholderColor)\n            : undefined;\n        message.placeholder = (_r = object.placeholder) !== null && _r !== void 0 ? _r : \"\";\n        message.margin = (_s = object.margin) !== null && _s !== void 0 ? _s : 0;\n        message.maxWidth = (_t = object.maxWidth) !== null && _t !== void 0 ? _t : 0;\n        message.hTextAlign = (_u = object.hTextAlign) !== null && _u !== void 0 ? _u : \"\";\n        message.vTextAlign = (_v = object.vTextAlign) !== null && _v !== void 0 ? _v : \"\";\n        message.autoStretchWidth = (_w = object.autoStretchWidth) !== null && _w !== void 0 ? _w : false;\n        message.background = (object.background !== undefined && object.background !== null)\n            ? PBColor4.fromPartial(object.background)\n            : undefined;\n        message.focusedBackground = (object.focusedBackground !== undefined && object.focusedBackground !== null)\n            ? PBColor4.fromPartial(object.focusedBackground)\n            : undefined;\n        message.textWrapping = (_x = object.textWrapping) !== null && _x !== void 0 ? _x : false;\n        message.shadowBlur = (_y = object.shadowBlur) !== null && _y !== void 0 ? _y : 0;\n        message.shadowOffsetX = (_z = object.shadowOffsetX) !== null && _z !== void 0 ? _z : 0;\n        message.shadowOffsetY = (_0 = object.shadowOffsetY) !== null && _0 !== void 0 ? _0 : 0;\n        message.shadowColor = (object.shadowColor !== undefined && object.shadowColor !== null)\n            ? PBColor4.fromPartial(object.shadowColor)\n            : undefined;\n        message.paddingTop = (_1 = object.paddingTop) !== null && _1 !== void 0 ? _1 : 0;\n        message.paddingRight = (_2 = object.paddingRight) !== null && _2 !== void 0 ? _2 : 0;\n        message.paddingBottom = (_3 = object.paddingBottom) !== null && _3 !== void 0 ? _3 : 0;\n        message.paddingLeft = (_4 = object.paddingLeft) !== null && _4 !== void 0 ? _4 : 0;\n        message.onTextSubmit = (object.onTextSubmit !== undefined && object.onTextSubmit !== null)\n            ? PBUUIDCallback.fromPartial(object.onTextSubmit)\n            : undefined;\n        message.onChanged = (object.onChanged !== undefined && object.onChanged !== null)\n            ? PBUUIDCallback.fromPartial(object.onChanged)\n            : undefined;\n        message.onFocus = (object.onFocus !== undefined && object.onFocus !== null)\n            ? PBUUIDCallback.fromPartial(object.onFocus)\n            : undefined;\n        message.onBlur = (object.onBlur !== undefined && object.onBlur !== null)\n            ? PBUUIDCallback.fromPartial(object.onBlur)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBUIScrollRect() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n        valueX: 0,\n        valueY: 0,\n        borderColor: undefined,\n        backgroundColor: undefined,\n        isHorizontal: false,\n        isVertical: false,\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0,\n        onChanged: undefined,\n    };\n}\nconst PBUIScrollRect = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.valueX !== 0) {\n            writer.uint32(101).float(message.valueX);\n        }\n        if (message.valueY !== 0) {\n            writer.uint32(109).float(message.valueY);\n        }\n        if (message.borderColor !== undefined) {\n            PBColor4.encode(message.borderColor, writer.uint32(114).fork()).ldelim();\n        }\n        if (message.backgroundColor !== undefined) {\n            PBColor4.encode(message.backgroundColor, writer.uint32(122).fork()).ldelim();\n        }\n        if (message.isHorizontal === true) {\n            writer.uint32(128).bool(message.isHorizontal);\n        }\n        if (message.isVertical === true) {\n            writer.uint32(136).bool(message.isVertical);\n        }\n        if (message.paddingTop !== 0) {\n            writer.uint32(149).float(message.paddingTop);\n        }\n        if (message.paddingRight !== 0) {\n            writer.uint32(157).float(message.paddingRight);\n        }\n        if (message.paddingBottom !== 0) {\n            writer.uint32(165).float(message.paddingBottom);\n        }\n        if (message.paddingLeft !== 0) {\n            writer.uint32(173).float(message.paddingLeft);\n        }\n        if (message.onChanged !== undefined) {\n            PBUUIDCallback.encode(message.onChanged, writer.uint32(178).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUIScrollRect();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.valueX = reader.float();\n                    break;\n                case 13:\n                    message.valueY = reader.float();\n                    break;\n                case 14:\n                    message.borderColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.backgroundColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 16:\n                    message.isHorizontal = reader.bool();\n                    break;\n                case 17:\n                    message.isVertical = reader.bool();\n                    break;\n                case 18:\n                    message.paddingTop = reader.float();\n                    break;\n                case 19:\n                    message.paddingRight = reader.float();\n                    break;\n                case 20:\n                    message.paddingBottom = reader.float();\n                    break;\n                case 21:\n                    message.paddingLeft = reader.float();\n                    break;\n                case 22:\n                    message.onChanged = PBUUIDCallback.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n            valueX: isSet(object.valueX) ? Number(object.valueX) : 0,\n            valueY: isSet(object.valueY) ? Number(object.valueY) : 0,\n            borderColor: isSet(object.borderColor) ? PBColor4.fromJSON(object.borderColor) : undefined,\n            backgroundColor: isSet(object.backgroundColor) ? PBColor4.fromJSON(object.backgroundColor) : undefined,\n            isHorizontal: isSet(object.isHorizontal) ? Boolean(object.isHorizontal) : false,\n            isVertical: isSet(object.isVertical) ? Boolean(object.isVertical) : false,\n            paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : 0,\n            paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : 0,\n            paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : 0,\n            paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : 0,\n            onChanged: isSet(object.onChanged) ? PBUUIDCallback.fromJSON(object.onChanged) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        message.valueX !== undefined && (obj.valueX = message.valueX);\n        message.valueY !== undefined && (obj.valueY = message.valueY);\n        message.borderColor !== undefined &&\n            (obj.borderColor = message.borderColor ? PBColor4.toJSON(message.borderColor) : undefined);\n        message.backgroundColor !== undefined &&\n            (obj.backgroundColor = message.backgroundColor ? PBColor4.toJSON(message.backgroundColor) : undefined);\n        message.isHorizontal !== undefined && (obj.isHorizontal = message.isHorizontal);\n        message.isVertical !== undefined && (obj.isVertical = message.isVertical);\n        message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);\n        message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);\n        message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);\n        message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);\n        message.onChanged !== undefined &&\n            (obj.onChanged = message.onChanged ? PBUUIDCallback.toJSON(message.onChanged) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;\n        const message = createBasePBUIScrollRect();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        message.valueX = (_l = object.valueX) !== null && _l !== void 0 ? _l : 0;\n        message.valueY = (_m = object.valueY) !== null && _m !== void 0 ? _m : 0;\n        message.borderColor = (object.borderColor !== undefined && object.borderColor !== null)\n            ? PBColor4.fromPartial(object.borderColor)\n            : undefined;\n        message.backgroundColor = (object.backgroundColor !== undefined && object.backgroundColor !== null)\n            ? PBColor4.fromPartial(object.backgroundColor)\n            : undefined;\n        message.isHorizontal = (_o = object.isHorizontal) !== null && _o !== void 0 ? _o : false;\n        message.isVertical = (_p = object.isVertical) !== null && _p !== void 0 ? _p : false;\n        message.paddingTop = (_q = object.paddingTop) !== null && _q !== void 0 ? _q : 0;\n        message.paddingRight = (_r = object.paddingRight) !== null && _r !== void 0 ? _r : 0;\n        message.paddingBottom = (_s = object.paddingBottom) !== null && _s !== void 0 ? _s : 0;\n        message.paddingLeft = (_t = object.paddingLeft) !== null && _t !== void 0 ? _t : 0;\n        message.onChanged = (object.onChanged !== undefined && object.onChanged !== null)\n            ? PBUUIDCallback.fromPartial(object.onChanged)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBUIShape() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n    };\n}\nconst PBUIShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUIShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;\n        const message = createBasePBUIShape();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        return message;\n    },\n};\nfunction createBasePBUITextShape() {\n    return {\n        name: \"\",\n        visible: false,\n        opacity: 0,\n        hAlign: \"\",\n        vAlign: \"\",\n        width: \"\",\n        height: \"\",\n        positionX: \"\",\n        positionY: \"\",\n        isPointerBlocker: false,\n        parent: undefined,\n        outlineWidth: 0,\n        outlineColor: undefined,\n        color: undefined,\n        fontSize: 0,\n        fontAutoSize: false,\n        fontWeight: \"\",\n        value: \"\",\n        lineSpacing: 0,\n        lineCount: 0,\n        adaptWidth: false,\n        adaptHeight: false,\n        textWrapping: false,\n        shadowBlur: 0,\n        shadowOffsetX: 0,\n        shadowOffsetY: 0,\n        shadowColor: undefined,\n        hTextAlign: \"\",\n        vTextAlign: \"\",\n        paddingTop: 0,\n        paddingRight: 0,\n        paddingBottom: 0,\n        paddingLeft: 0,\n    };\n}\nconst PBUITextShape = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.name !== \"\") {\n            writer.uint32(10).string(message.name);\n        }\n        if (message.visible === true) {\n            writer.uint32(16).bool(message.visible);\n        }\n        if (message.opacity !== 0) {\n            writer.uint32(29).float(message.opacity);\n        }\n        if (message.hAlign !== \"\") {\n            writer.uint32(34).string(message.hAlign);\n        }\n        if (message.vAlign !== \"\") {\n            writer.uint32(42).string(message.vAlign);\n        }\n        if (message.width !== \"\") {\n            writer.uint32(50).string(message.width);\n        }\n        if (message.height !== \"\") {\n            writer.uint32(58).string(message.height);\n        }\n        if (message.positionX !== \"\") {\n            writer.uint32(66).string(message.positionX);\n        }\n        if (message.positionY !== \"\") {\n            writer.uint32(74).string(message.positionY);\n        }\n        if (message.isPointerBlocker === true) {\n            writer.uint32(80).bool(message.isPointerBlocker);\n        }\n        if (message.parent !== undefined) {\n            PBUIShape.encode(message.parent, writer.uint32(90).fork()).ldelim();\n        }\n        if (message.outlineWidth !== 0) {\n            writer.uint32(101).float(message.outlineWidth);\n        }\n        if (message.outlineColor !== undefined) {\n            PBColor4.encode(message.outlineColor, writer.uint32(106).fork()).ldelim();\n        }\n        if (message.color !== undefined) {\n            PBColor4.encode(message.color, writer.uint32(114).fork()).ldelim();\n        }\n        if (message.fontSize !== 0) {\n            writer.uint32(125).float(message.fontSize);\n        }\n        if (message.fontAutoSize === true) {\n            writer.uint32(128).bool(message.fontAutoSize);\n        }\n        if (message.fontWeight !== \"\") {\n            writer.uint32(138).string(message.fontWeight);\n        }\n        if (message.value !== \"\") {\n            writer.uint32(146).string(message.value);\n        }\n        if (message.lineSpacing !== 0) {\n            writer.uint32(157).float(message.lineSpacing);\n        }\n        if (message.lineCount !== 0) {\n            writer.uint32(165).float(message.lineCount);\n        }\n        if (message.adaptWidth === true) {\n            writer.uint32(168).bool(message.adaptWidth);\n        }\n        if (message.adaptHeight === true) {\n            writer.uint32(176).bool(message.adaptHeight);\n        }\n        if (message.textWrapping === true) {\n            writer.uint32(184).bool(message.textWrapping);\n        }\n        if (message.shadowBlur !== 0) {\n            writer.uint32(197).float(message.shadowBlur);\n        }\n        if (message.shadowOffsetX !== 0) {\n            writer.uint32(205).float(message.shadowOffsetX);\n        }\n        if (message.shadowOffsetY !== 0) {\n            writer.uint32(213).float(message.shadowOffsetY);\n        }\n        if (message.shadowColor !== undefined) {\n            PBColor4.encode(message.shadowColor, writer.uint32(218).fork()).ldelim();\n        }\n        if (message.hTextAlign !== \"\") {\n            writer.uint32(226).string(message.hTextAlign);\n        }\n        if (message.vTextAlign !== \"\") {\n            writer.uint32(234).string(message.vTextAlign);\n        }\n        if (message.paddingTop !== 0) {\n            writer.uint32(245).float(message.paddingTop);\n        }\n        if (message.paddingRight !== 0) {\n            writer.uint32(253).float(message.paddingRight);\n        }\n        if (message.paddingBottom !== 0) {\n            writer.uint32(261).float(message.paddingBottom);\n        }\n        if (message.paddingLeft !== 0) {\n            writer.uint32(269).float(message.paddingLeft);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBUITextShape();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.name = reader.string();\n                    break;\n                case 2:\n                    message.visible = reader.bool();\n                    break;\n                case 3:\n                    message.opacity = reader.float();\n                    break;\n                case 4:\n                    message.hAlign = reader.string();\n                    break;\n                case 5:\n                    message.vAlign = reader.string();\n                    break;\n                case 6:\n                    message.width = reader.string();\n                    break;\n                case 7:\n                    message.height = reader.string();\n                    break;\n                case 8:\n                    message.positionX = reader.string();\n                    break;\n                case 9:\n                    message.positionY = reader.string();\n                    break;\n                case 10:\n                    message.isPointerBlocker = reader.bool();\n                    break;\n                case 11:\n                    message.parent = PBUIShape.decode(reader, reader.uint32());\n                    break;\n                case 12:\n                    message.outlineWidth = reader.float();\n                    break;\n                case 13:\n                    message.outlineColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 14:\n                    message.color = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 15:\n                    message.fontSize = reader.float();\n                    break;\n                case 16:\n                    message.fontAutoSize = reader.bool();\n                    break;\n                case 17:\n                    message.fontWeight = reader.string();\n                    break;\n                case 18:\n                    message.value = reader.string();\n                    break;\n                case 19:\n                    message.lineSpacing = reader.float();\n                    break;\n                case 20:\n                    message.lineCount = reader.float();\n                    break;\n                case 21:\n                    message.adaptWidth = reader.bool();\n                    break;\n                case 22:\n                    message.adaptHeight = reader.bool();\n                    break;\n                case 23:\n                    message.textWrapping = reader.bool();\n                    break;\n                case 24:\n                    message.shadowBlur = reader.float();\n                    break;\n                case 25:\n                    message.shadowOffsetX = reader.float();\n                    break;\n                case 26:\n                    message.shadowOffsetY = reader.float();\n                    break;\n                case 27:\n                    message.shadowColor = PBColor4.decode(reader, reader.uint32());\n                    break;\n                case 28:\n                    message.hTextAlign = reader.string();\n                    break;\n                case 29:\n                    message.vTextAlign = reader.string();\n                    break;\n                case 30:\n                    message.paddingTop = reader.float();\n                    break;\n                case 31:\n                    message.paddingRight = reader.float();\n                    break;\n                case 32:\n                    message.paddingBottom = reader.float();\n                    break;\n                case 33:\n                    message.paddingLeft = reader.float();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            name: isSet(object.name) ? String(object.name) : \"\",\n            visible: isSet(object.visible) ? Boolean(object.visible) : false,\n            opacity: isSet(object.opacity) ? Number(object.opacity) : 0,\n            hAlign: isSet(object.hAlign) ? String(object.hAlign) : \"\",\n            vAlign: isSet(object.vAlign) ? String(object.vAlign) : \"\",\n            width: isSet(object.width) ? String(object.width) : \"\",\n            height: isSet(object.height) ? String(object.height) : \"\",\n            positionX: isSet(object.positionX) ? String(object.positionX) : \"\",\n            positionY: isSet(object.positionY) ? String(object.positionY) : \"\",\n            isPointerBlocker: isSet(object.isPointerBlocker) ? Boolean(object.isPointerBlocker) : false,\n            parent: isSet(object.parent) ? PBUIShape.fromJSON(object.parent) : undefined,\n            outlineWidth: isSet(object.outlineWidth) ? Number(object.outlineWidth) : 0,\n            outlineColor: isSet(object.outlineColor) ? PBColor4.fromJSON(object.outlineColor) : undefined,\n            color: isSet(object.color) ? PBColor4.fromJSON(object.color) : undefined,\n            fontSize: isSet(object.fontSize) ? Number(object.fontSize) : 0,\n            fontAutoSize: isSet(object.fontAutoSize) ? Boolean(object.fontAutoSize) : false,\n            fontWeight: isSet(object.fontWeight) ? String(object.fontWeight) : \"\",\n            value: isSet(object.value) ? String(object.value) : \"\",\n            lineSpacing: isSet(object.lineSpacing) ? Number(object.lineSpacing) : 0,\n            lineCount: isSet(object.lineCount) ? Number(object.lineCount) : 0,\n            adaptWidth: isSet(object.adaptWidth) ? Boolean(object.adaptWidth) : false,\n            adaptHeight: isSet(object.adaptHeight) ? Boolean(object.adaptHeight) : false,\n            textWrapping: isSet(object.textWrapping) ? Boolean(object.textWrapping) : false,\n            shadowBlur: isSet(object.shadowBlur) ? Number(object.shadowBlur) : 0,\n            shadowOffsetX: isSet(object.shadowOffsetX) ? Number(object.shadowOffsetX) : 0,\n            shadowOffsetY: isSet(object.shadowOffsetY) ? Number(object.shadowOffsetY) : 0,\n            shadowColor: isSet(object.shadowColor) ? PBColor4.fromJSON(object.shadowColor) : undefined,\n            hTextAlign: isSet(object.hTextAlign) ? String(object.hTextAlign) : \"\",\n            vTextAlign: isSet(object.vTextAlign) ? String(object.vTextAlign) : \"\",\n            paddingTop: isSet(object.paddingTop) ? Number(object.paddingTop) : 0,\n            paddingRight: isSet(object.paddingRight) ? Number(object.paddingRight) : 0,\n            paddingBottom: isSet(object.paddingBottom) ? Number(object.paddingBottom) : 0,\n            paddingLeft: isSet(object.paddingLeft) ? Number(object.paddingLeft) : 0,\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.name !== undefined && (obj.name = message.name);\n        message.visible !== undefined && (obj.visible = message.visible);\n        message.opacity !== undefined && (obj.opacity = message.opacity);\n        message.hAlign !== undefined && (obj.hAlign = message.hAlign);\n        message.vAlign !== undefined && (obj.vAlign = message.vAlign);\n        message.width !== undefined && (obj.width = message.width);\n        message.height !== undefined && (obj.height = message.height);\n        message.positionX !== undefined && (obj.positionX = message.positionX);\n        message.positionY !== undefined && (obj.positionY = message.positionY);\n        message.isPointerBlocker !== undefined && (obj.isPointerBlocker = message.isPointerBlocker);\n        message.parent !== undefined && (obj.parent = message.parent ? PBUIShape.toJSON(message.parent) : undefined);\n        message.outlineWidth !== undefined && (obj.outlineWidth = message.outlineWidth);\n        message.outlineColor !== undefined &&\n            (obj.outlineColor = message.outlineColor ? PBColor4.toJSON(message.outlineColor) : undefined);\n        message.color !== undefined && (obj.color = message.color ? PBColor4.toJSON(message.color) : undefined);\n        message.fontSize !== undefined && (obj.fontSize = message.fontSize);\n        message.fontAutoSize !== undefined && (obj.fontAutoSize = message.fontAutoSize);\n        message.fontWeight !== undefined && (obj.fontWeight = message.fontWeight);\n        message.value !== undefined && (obj.value = message.value);\n        message.lineSpacing !== undefined && (obj.lineSpacing = message.lineSpacing);\n        message.lineCount !== undefined && (obj.lineCount = message.lineCount);\n        message.adaptWidth !== undefined && (obj.adaptWidth = message.adaptWidth);\n        message.adaptHeight !== undefined && (obj.adaptHeight = message.adaptHeight);\n        message.textWrapping !== undefined && (obj.textWrapping = message.textWrapping);\n        message.shadowBlur !== undefined && (obj.shadowBlur = message.shadowBlur);\n        message.shadowOffsetX !== undefined && (obj.shadowOffsetX = message.shadowOffsetX);\n        message.shadowOffsetY !== undefined && (obj.shadowOffsetY = message.shadowOffsetY);\n        message.shadowColor !== undefined &&\n            (obj.shadowColor = message.shadowColor ? PBColor4.toJSON(message.shadowColor) : undefined);\n        message.hTextAlign !== undefined && (obj.hTextAlign = message.hTextAlign);\n        message.vTextAlign !== undefined && (obj.vTextAlign = message.vTextAlign);\n        message.paddingTop !== undefined && (obj.paddingTop = message.paddingTop);\n        message.paddingRight !== undefined && (obj.paddingRight = message.paddingRight);\n        message.paddingBottom !== undefined && (obj.paddingBottom = message.paddingBottom);\n        message.paddingLeft !== undefined && (obj.paddingLeft = message.paddingLeft);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3, _4;\n        const message = createBasePBUITextShape();\n        message.name = (_a = object.name) !== null && _a !== void 0 ? _a : \"\";\n        message.visible = (_b = object.visible) !== null && _b !== void 0 ? _b : false;\n        message.opacity = (_c = object.opacity) !== null && _c !== void 0 ? _c : 0;\n        message.hAlign = (_d = object.hAlign) !== null && _d !== void 0 ? _d : \"\";\n        message.vAlign = (_e = object.vAlign) !== null && _e !== void 0 ? _e : \"\";\n        message.width = (_f = object.width) !== null && _f !== void 0 ? _f : \"\";\n        message.height = (_g = object.height) !== null && _g !== void 0 ? _g : \"\";\n        message.positionX = (_h = object.positionX) !== null && _h !== void 0 ? _h : \"\";\n        message.positionY = (_j = object.positionY) !== null && _j !== void 0 ? _j : \"\";\n        message.isPointerBlocker = (_k = object.isPointerBlocker) !== null && _k !== void 0 ? _k : false;\n        message.parent = (object.parent !== undefined && object.parent !== null)\n            ? PBUIShape.fromPartial(object.parent)\n            : undefined;\n        message.outlineWidth = (_l = object.outlineWidth) !== null && _l !== void 0 ? _l : 0;\n        message.outlineColor = (object.outlineColor !== undefined && object.outlineColor !== null)\n            ? PBColor4.fromPartial(object.outlineColor)\n            : undefined;\n        message.color = (object.color !== undefined && object.color !== null)\n            ? PBColor4.fromPartial(object.color)\n            : undefined;\n        message.fontSize = (_m = object.fontSize) !== null && _m !== void 0 ? _m : 0;\n        message.fontAutoSize = (_o = object.fontAutoSize) !== null && _o !== void 0 ? _o : false;\n        message.fontWeight = (_p = object.fontWeight) !== null && _p !== void 0 ? _p : \"\";\n        message.value = (_q = object.value) !== null && _q !== void 0 ? _q : \"\";\n        message.lineSpacing = (_r = object.lineSpacing) !== null && _r !== void 0 ? _r : 0;\n        message.lineCount = (_s = object.lineCount) !== null && _s !== void 0 ? _s : 0;\n        message.adaptWidth = (_t = object.adaptWidth) !== null && _t !== void 0 ? _t : false;\n        message.adaptHeight = (_u = object.adaptHeight) !== null && _u !== void 0 ? _u : false;\n        message.textWrapping = (_v = object.textWrapping) !== null && _v !== void 0 ? _v : false;\n        message.shadowBlur = (_w = object.shadowBlur) !== null && _w !== void 0 ? _w : 0;\n        message.shadowOffsetX = (_x = object.shadowOffsetX) !== null && _x !== void 0 ? _x : 0;\n        message.shadowOffsetY = (_y = object.shadowOffsetY) !== null && _y !== void 0 ? _y : 0;\n        message.shadowColor = (object.shadowColor !== undefined && object.shadowColor !== null)\n            ? PBColor4.fromPartial(object.shadowColor)\n            : undefined;\n        message.hTextAlign = (_z = object.hTextAlign) !== null && _z !== void 0 ? _z : \"\";\n        message.vTextAlign = (_0 = object.vTextAlign) !== null && _0 !== void 0 ? _0 : \"\";\n        message.paddingTop = (_1 = object.paddingTop) !== null && _1 !== void 0 ? _1 : 0;\n        message.paddingRight = (_2 = object.paddingRight) !== null && _2 !== void 0 ? _2 : 0;\n        message.paddingBottom = (_3 = object.paddingBottom) !== null && _3 !== void 0 ? _3 : 0;\n        message.paddingLeft = (_4 = object.paddingLeft) !== null && _4 !== void 0 ? _4 : 0;\n        return message;\n    },\n};\nfunction createBasePBOpenExternalUrl() {\n    return { url: \"\" };\n}\nconst PBOpenExternalUrl = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.url !== \"\") {\n            writer.uint32(10).string(message.url);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBOpenExternalUrl();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.url = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return { url: isSet(object.url) ? String(object.url) : \"\" };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.url !== undefined && (obj.url = message.url);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a;\n        const message = createBasePBOpenExternalUrl();\n        message.url = (_a = object.url) !== null && _a !== void 0 ? _a : \"\";\n        return message;\n    },\n};\nfunction createBasePBOpenNFTDialog() {\n    return { assetContractAddress: \"\", tokenId: \"\", comment: \"\" };\n}\nconst PBOpenNFTDialog = {\n    encode(message, writer = protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Writer.create()) {\n        if (message.assetContractAddress !== \"\") {\n            writer.uint32(10).string(message.assetContractAddress);\n        }\n        if (message.tokenId !== \"\") {\n            writer.uint32(18).string(message.tokenId);\n        }\n        if (message.comment !== \"\") {\n            writer.uint32(26).string(message.comment);\n        }\n        return writer;\n    },\n    decode(input, length) {\n        const reader = input instanceof protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader ? input : new protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.Reader(input);\n        let end = length === undefined ? reader.len : reader.pos + length;\n        const message = createBasePBOpenNFTDialog();\n        while (reader.pos < end) {\n            const tag = reader.uint32();\n            switch (tag >>> 3) {\n                case 1:\n                    message.assetContractAddress = reader.string();\n                    break;\n                case 2:\n                    message.tokenId = reader.string();\n                    break;\n                case 3:\n                    message.comment = reader.string();\n                    break;\n                default:\n                    reader.skipType(tag & 7);\n                    break;\n            }\n        }\n        return message;\n    },\n    fromJSON(object) {\n        return {\n            assetContractAddress: isSet(object.assetContractAddress) ? String(object.assetContractAddress) : \"\",\n            tokenId: isSet(object.tokenId) ? String(object.tokenId) : \"\",\n            comment: isSet(object.comment) ? String(object.comment) : \"\",\n        };\n    },\n    toJSON(message) {\n        const obj = {};\n        message.assetContractAddress !== undefined && (obj.assetContractAddress = message.assetContractAddress);\n        message.tokenId !== undefined && (obj.tokenId = message.tokenId);\n        message.comment !== undefined && (obj.comment = message.comment);\n        return obj;\n    },\n    fromPartial(object) {\n        var _a, _b, _c;\n        const message = createBasePBOpenNFTDialog();\n        message.assetContractAddress = (_a = object.assetContractAddress) !== null && _a !== void 0 ? _a : \"\";\n        message.tokenId = (_b = object.tokenId) !== null && _b !== void 0 ? _b : \"\";\n        message.comment = (_c = object.comment) !== null && _c !== void 0 ? _c : \"\";\n        return message;\n    },\n};\nvar globalThis = (() => {\n    if (typeof globalThis !== \"undefined\") {\n        return globalThis;\n    }\n    if (typeof self !== \"undefined\") {\n        return self;\n    }\n    if (typeof window !== \"undefined\") {\n        return window;\n    }\n    if (typeof global !== \"undefined\") {\n        return global;\n    }\n    throw \"Unable to locate global object\";\n})();\nfunction longToNumber(long) {\n    if (long.gt(Number.MAX_SAFE_INTEGER)) {\n        throw new globalThis.Error(\"Value is larger than Number.MAX_SAFE_INTEGER\");\n    }\n    return long.toNumber();\n}\nif (protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.util.Long !== long__WEBPACK_IMPORTED_MODULE_0___default.a) {\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.util.Long = long__WEBPACK_IMPORTED_MODULE_0___default.a;\n    protobufjs_minimal__WEBPACK_IMPORTED_MODULE_1___default.a.configure();\n}\nfunction isSet(value) {\n    return value !== null && value !== undefined;\n}\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../node_modules/webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./packages/shared/protocol/renderer-protocol/EngineInterface.gen.ts?");

/***/ }),

/***/ "./packages/shared/store/isolatedStore.ts":
/*!************************************************!*\
  !*** ./packages/shared/store/isolatedStore.ts ***!
  \************************************************/
/*! exports provided: store, setStore */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"store\", function() { return store; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"setStore\", function() { return setStore; });\nlet store;\nfunction setStore(_store) {\n    store = _store;\n}\n\n\n//# sourceURL=webpack:///./packages/shared/store/isolatedStore.ts?");

/***/ })

/******/ })));